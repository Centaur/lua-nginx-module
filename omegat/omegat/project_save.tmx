<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.3.0_1"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>#    return ngx.arg[1]..ngx.arg[2]</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035710Z" changeid="xf">
        <seg>#    返回 ngx.arg[1]..ngx.arg[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $ngx_prefix/conf/concat.lua contents:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035659Z" changeid="xf">
        <seg># $ngx_prefix/conf/concat.lua 的内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># MIME type determined by default_type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035405Z" changeid="xf">
        <seg># 使用默认的 MIME 类型:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># WARN: contents in nginx var must be carefully filtered,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040343Z" changeid="xf">
        <seg># 注意：nginx 变量中的内容必须被小心过滤</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># absolute script path not modified</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035746Z" changeid="xf">
        <seg># 直接使用绝对路径 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># force reading request body (default off)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035859Z" changeid="xf">
        <seg># 强制读取 request body (默认关闭)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># inline Lua script</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035430Z" changeid="xf">
        <seg># 内嵌Lua脚本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># otherwise there'll be great security risk!</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040125Z" changeid="xf">
        <seg># 否则会产生巨大的安全漏洞!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># script path relative to nginx prefix</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035650Z" changeid="xf">
        <seg># 使用相对于$ngx_prefix的脚本路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># set search paths for Lua external libraries written in C (can also use ';;'):</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035333Z" changeid="xf">
        <seg># 设置用C编写的外部库的查找路径 (也可以使用 ';;'):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># set search paths for pure Lua external libraries (';;' is the default path):</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035307Z" changeid="xf">
        <seg># 设置纯Lua编写的外部库的查找路径 (';;' 是默认查找路径):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># transparent non-blocking I/O in Lua via subrequests</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035937Z" changeid="xf">
        <seg># 在Lua中使用subrequests进行透明的非阻塞I/O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># try access /nginx_var?a=hello,world</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035832Z" changeid="xf">
        <seg># 试试访问 /nginx_var?a=hello,world</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># use nginx var in code path</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040349Z" changeid="xf">
        <seg># 在代码路径中使用 nginx 变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># whether the current request body is already larger than the [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]],
# and whether [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]] has been switched on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022403Z" changeid="xf">
        <seg># 当前请求体是否已经超过了 [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] 的大小,
# 是否打开了 [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''WARNING''' When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032621Z" changeid="xf">
        <seg>'''警告''' 在读取Nginx变量时, Nginx将在每个请求的内存池中分配内存，只有当请求结束时，这个内存池才被释放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''http''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T054114Z" changeid="xf">
        <seg>'''可包含于:''' ''http''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''http, server, location''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102537Z" changeid="xf">
        <seg>'''可包含于:''' ''http, server, location''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''http, server, location, location if''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074340Z" changeid="xf">
        <seg>'''可包含于:''' ''http, server, location, location if''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''http, server, location, location-if''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015813Z" changeid="xf">
        <seg>'''可包含于:''' ''http, server, location, location-if''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041548Z" changeid="xf">
        <seg>'''可包含于:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033738Z" changeid="xf">
        <seg>'''可包含于:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''location, location if''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073845Z" changeid="xf">
        <seg>'''可包含于:''' ''location, location if''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''main | server | location''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101517Z" changeid="xf">
        <seg>'''可包含于:''' ''main | server | location''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''main''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061028Z" changeid="xf">
        <seg>'''可包含于:''' ''main''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''main, server, location, location if''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061103Z" changeid="xf">
        <seg>'''可包含于:''' ''main, server, location, location if''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035834Z" changeid="xf">
        <seg>'''可包含于:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083803Z" changeid="xf">
        <seg>'''可包含于:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''server, server if, location, location if''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073402Z" changeid="xf">
        <seg>'''可包含于:''' ''server, server if, location, location if''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, body_filter_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024456Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, body_filter_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024337Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094408Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020726Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095706Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032030Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102531Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''The content of LUA_CPATH environment variable or Lua's compiled-in defaults.''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062249Z" changeid="xf">
        <seg>'''默认值:''' ''环境变量LUA_CPATH的内容或 Lua编译时指定的默认值.''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''The content of LUA_PATH environ variable or Lua's compiled-in defaults.''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061022Z" changeid="xf">
        <seg>'''默认值:''' ''The content of LUA_PATH environ variable or Lua's compiled-in defaults.''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_check_client_abort off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020949Z" changeid="xf">
        <seg>'''默认值:''' ''lua_check_client_abort off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_code_cache on''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041953Z" changeid="xf">
        <seg>'''默认值:''' ''lua_code_cache on''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_http10_buffering on''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015809Z" changeid="xf">
        <seg>'''默认值:''' ''lua_http10_buffering on''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_max_pending_timers 1024''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022509Z" changeid="xf">
        <seg>'''默认值:''' ''lua_max_pending_timers 1024''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_max_running_timers 256''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022702Z" changeid="xf">
        <seg>'''默认值:''' ''lua_max_running_timers 256''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_regex_cache_max_entries 1024''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T054048Z" changeid="xf">
        <seg>'''默认值:''' ''lua_regex_cache_max_entries 1024''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_regex_match_limit 0''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060242Z" changeid="xf">
        <seg>'''默认值:''' ''lua_regex_match_limit 0''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_buffer_size 4k/8k''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103146Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_buffer_size 4k/8k''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_connect_timeout 60s''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102533Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_connect_timeout 60s''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_keepalive_timeout 60s''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104352Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_keepalive_timeout 60s''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_log_errors on''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104530Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_log_errors on''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_pool_size 30''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103328Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_pool_size 30''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_read_timeout 60s''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103030Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_read_timeout 60s''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_send_lowat 0''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102852Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_send_lowat 0''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_send_timeout 60s''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102754Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_send_timeout 60s''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_transform_underscores_in_response_headers on''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020724Z" changeid="xf">
        <seg>'''默认值:''' ''lua_transform_underscores_in_response_headers on''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''no''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102327Z" changeid="xf">
        <seg>'''默认值:''' ''no''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101513Z" changeid="xf">
        <seg>'''默认值:''' ''off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''rewrite_by_lua_no_postpone off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020501Z" changeid="xf">
        <seg>'''默认值:''' ''rewrite_by_lua_no_postpone off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''access tail''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080904Z" changeid="xf">
        <seg>'''执行阶段:''' ''access tail''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''content''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073850Z" changeid="xf">
        <seg>'''执行阶段:''' ''content''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''depends on usage''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101521Z" changeid="xf">
        <seg>'''执行阶段:''' ''depends on usage''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''loading-config''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062457Z" changeid="xf">
        <seg>'''执行阶段:''' ''loading-config''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''log''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T090904Z" changeid="xf">
        <seg>'''执行阶段:''' ''log''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''output-body-filter''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094804Z" changeid="xf">
        <seg>'''执行阶段:''' ''output-body-filter''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''output-header-filter''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094438Z" changeid="xf">
        <seg>'''执行阶段:''' ''output-header-filter''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''rewrite tail''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074343Z" changeid="xf">
        <seg>'''执行阶段:''' ''rewrite tail''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''server-rewrite, rewrite''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072152Z" changeid="xf">
        <seg>'''执行阶段:''' ''server-rewrite, rewrite''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''access_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080857Z" changeid="xf">
        <seg>'''语法:''' ''access_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''access_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094315Z" changeid="xf">
        <seg>'''语法:''' ''access_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''body_filter_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094758Z" changeid="xf">
        <seg>'''语法:''' ''body_filter_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''body_filter_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091649Z" changeid="xf">
        <seg>'''语法:''' ''body_filter_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''content_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073841Z" changeid="xf">
        <seg>'''语法:''' ''content_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''content_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074154Z" changeid="xf">
        <seg>'''语法:''' ''content_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''header_filter_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094434Z" changeid="xf">
        <seg>'''语法:''' ''header_filter_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''header_filter_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094727Z" changeid="xf">
        <seg>'''语法:''' ''header_filter_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''init_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062431Z" changeid="xf">
        <seg>'''语法:''' ''init_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''init_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064458Z" changeid="xf">
        <seg>'''语法:''' ''init_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''log_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T090847Z" changeid="xf">
        <seg>'''语法:''' ''log_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''log_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101432Z" changeid="xf">
        <seg>'''语法:''' ''log_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_check_client_abort on|off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020945Z" changeid="xf">
        <seg>'''语法:''' ''lua_check_client_abort on|off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_http10_buffering on|off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015805Z" changeid="xf">
        <seg>'''语法:''' ''lua_http10_buffering on|off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_max_pending_timers &lt;count&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022505Z" changeid="xf">
        <seg>'''语法:''' ''lua_max_pending_timers &lt;count&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_max_running_timers &lt;count&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022657Z" changeid="xf">
        <seg>'''语法:''' ''lua_max_running_timers &lt;count&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_need_request_body &lt;on|off&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101507Z" changeid="xf">
        <seg>'''语法:''' ''lua_need_request_body &lt;on|off&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_package_cpath &lt;lua-style-cpath-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062204Z" changeid="xf">
        <seg>'''语法:''' ''lua_package_cpath &lt;lua-style-cpath-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_package_path &lt;lua-style-path-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061017Z" changeid="xf">
        <seg>'''语法:''' ''lua_package_path &lt;lua-style-path-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_shared_dict &lt;name&gt; &lt;size&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102322Z" changeid="xf">
        <seg>'''语法:''' ''lua_shared_dict &lt;name&gt; &lt;size&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_buffer_size &lt;size&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103143Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_buffer_size &lt;size&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_connect_timeout &lt;time&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102529Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_connect_timeout &lt;time&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_keepalive_timeout &lt;time&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104349Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_keepalive_timeout &lt;time&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_log_errors on|off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104528Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_log_errors on|off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_pool_size &lt;size&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103325Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_pool_size &lt;size&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_read_timeout &lt;time&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103026Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_read_timeout &lt;time&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_send_lowat &lt;size&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102849Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_send_lowat &lt;size&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_send_timeout &lt;time&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102751Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_send_timeout &lt;time&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_transform_underscores_in_response_headers on|off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020720Z" changeid="xf">
        <seg>'''语法:''' ''lua_transform_underscores_in_response_headers on|off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''rewrite_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074335Z" changeid="xf">
        <seg>'''语法:''' ''rewrite_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''rewrite_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080626Z" changeid="xf">
        <seg>'''语法:''' ''rewrite_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''rewrite_by_lua_no_postpone on|off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020457Z" changeid="xf">
        <seg>'''语法:''' ''rewrite_by_lua_no_postpone on|off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''set_by_lua $res &lt;lua-script-str&gt; [$arg1 $arg2 ...]''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072141Z" changeid="xf">
        <seg>'''语法:''' ''set_by_lua $res &lt;lua-script-str&gt; [$arg1 $arg2 ...]''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''value = ngx.header.HEADER''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083756Z" changeid="xf">
        <seg>'''语法:''' ''value = ngx.header.HEADER''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>''This module is not distributed with the Nginx source.'' See [[#Installation|the installation instructions]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034900Z" changeid="xf">
        <seg>''此模块属于第三方扩展，不包含在Nginx源码发布包中。 参阅 [[#Installation|安装]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Before the &lt;code&gt;v0.7.14&lt;/code&gt; release, the &quot;eof&quot; flag does not work at all in subrequests.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094408Z" changeid="xf">
        <seg>(在&lt;code&gt;v0.7.14&lt;/code&gt;之前的版本中, &quot;eof&quot; 标记对子请求无效.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;args&lt;/code&gt;
: specify the subrequest's URI query arguments (both string value and Lua tables are accepted)
* &lt;code&gt;ctx&lt;/code&gt;
: specify a Lua table to be the [[#ngx.ctx|ngx.ctx]] table for the subrequest.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041707Z" changeid="xf">
        <seg>* &lt;code&gt;args&lt;/code&gt;
: 指定子请求的URI请求参数 (接受字符串值和Lua table)
* &lt;code&gt;ctx&lt;/code&gt;
: 为子请求指定 [[#ngx.ctx|ngx.ctx]] table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;body&lt;/code&gt;
: specify the subrequest's request body (string value only).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041558Z" changeid="xf">
        <seg>* &lt;code&gt;body&lt;/code&gt;
: 指定子请求的请求体 (只允许字符串值).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;copy_all_vars&lt;/code&gt;
: specify whether to copy over all the Nginx variable values of the current request to the subrequest in question.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041951Z" changeid="xf">
        <seg>* &lt;code&gt;copy_all_vars&lt;/code&gt;
: 指定是否将当前请求中的所有Ngin变量复制到子请求中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;method&lt;/code&gt;
: specify the subrequest's request method, which only accepts constants like &lt;code&gt;ngx.HTTP_POST&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041533Z" changeid="xf">
        <seg>* &lt;code&gt;method&lt;/code&gt;
: 指定子请求的请求方法，只接受 &lt;code&gt;ngx.HTTP_POST&lt;/code&gt; 这样的常量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;share_all_vars&lt;/code&gt;
: specify whether to share all the Nginx variables of the subrequest with the current (parent) request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T042045Z" changeid="xf">
        <seg>* &lt;code&gt;share_all_vars&lt;/code&gt;
: 指定是否将本（父）请求中的Nginx变量值与子请求共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;vars&lt;/code&gt;
: take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option's value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041902Z" changeid="xf">
        <seg>* &lt;code&gt;vars&lt;/code&gt;
: Lua table，其内部的值将作为子请求的Nginx 变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Output API functions (e.g., [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
* Control API functions (e.g., [[#ngx.exit|ngx.exit]] and [[#ngx.exec|ngx.exec]])
* Subrequest API functions (e.g., [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
* Cosocket API functions (e.g., [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094539Z" changeid="xf">
        <seg>* Output API 函数(例如, [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
* Control API 函数(例如, [[#ngx.exit|ngx.exit]]) 
* Subrequest API 函数(例如, [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
* Cosocket API 函数(例如, [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Output API functions (e.g., [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
* Control API functions (e.g., [[#ngx.exit|ngx.exit]]) 
* Subrequest API functions (e.g., [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
* Cosocket API functions (e.g., [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072625Z" changeid="xf">
        <seg>* Output API 函数(例如, [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
* Control API 函数(例如, [[#ngx.exit|ngx.exit]]) 
* Subrequest API 函数(例如, [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
* Cosocket API 函数(例如, [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- check if the request body contains bad words</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040239Z" changeid="xf">
        <seg>-- 检查request body中是否包含恶意词或敏感词</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- check the client IP address is in our black list</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040205Z" changeid="xf">
        <seg>-- 检查客户端IP是否在黑名单里</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- equivalent to ngx.header[&quot;Content-Type&quot;] = 'text/plain'</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084117Z" changeid="xf">
        <seg>-- 等价于 ngx.header[&quot;Content-Type&quot;] = 'text/plain'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- just throw away any remaining chunk data</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T095022Z" changeid="xf">
        <seg>-- 丢弃剩下的块数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- tests passed</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040253Z" changeid="xf">
        <seg>-- 测试通过</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--- use the val repeatedly later
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032734Z" changeid="xf">
        <seg>--- 后续重复使用val
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;GET /test?=hello&amp;=world&lt;/code&gt; will yield an empty output for instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102942Z" changeid="xf">
        <seg>例如，&lt;code&gt;GET /test?=hello&amp;=world&lt;/code&gt; 的结果为空.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;GET /test?foo&amp;bar&lt;/code&gt; will yield:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102830Z" changeid="xf">
        <seg>&lt;code&gt;GET /test?foo&amp;bar&lt;/code&gt; 的结果:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;ngx.flush&lt;/code&gt; accepts an optional boolean &lt;code&gt;wait&lt;/code&gt; argument (Default: &lt;code&gt;false&lt;/code&gt;) first introduced in the &lt;code&gt;v0.3.1rc34&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041932Z" changeid="xf">
        <seg>&lt;code&gt;ngx.flush&lt;/code&gt; 接受可选的 boolean &lt;code&gt;wait&lt;/code&gt; 参数(默认值: &lt;code&gt;false&lt;/code&gt;)，从 &lt;code&gt;v0.3.1rc34&lt;/code&gt; 版本开始引入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;res.body&lt;/code&gt; holds the subrequest's response body data, which might be truncated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041151Z" changeid="xf">
        <seg>&lt;code&gt;res.body&lt;/code&gt; 保存子请求响应体数据，有可能被截断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;res.header&lt;/code&gt; holds all the response headers of the
subrequest and it is a normal Lua table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041006Z" changeid="xf">
        <seg>&lt;code&gt;res.header&lt;/code&gt; 的值是子请求的所有响应头，这是一个正常的Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;res.status&lt;/code&gt; holds the response status code for the subrequest response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040946Z" changeid="xf">
        <seg>&lt;code&gt;res.status&lt;/code&gt; 的值是子请求响应的响应状态码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Description =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040559Z" changeid="xf">
        <seg>= 说明 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Directives =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041653Z" changeid="xf">
        <seg>= 命令 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Name =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034722Z" changeid="xf">
        <seg>= 名称 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Nginx API for Lua =
== Introduction ==
The various &lt;code&gt;*_by_lua&lt;/code&gt; and &lt;code&gt;*_by_lua_file&lt;/code&gt; configuration directives serve as gateways to the Lua API within the &lt;code&gt;nginx.conf&lt;/code&gt; file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023520Z" changeid="xf">
        <seg>= 可供Lua调用的Nginx API =
== 简介 ==
各种 &lt;code&gt;*_by_lua&lt;/code&gt; and &lt;code&gt;*_by_lua_file&lt;/code&gt; 配置命令的作用是在&lt;code&gt;nginx.conf&lt;/code&gt;文件内部提供访问Lua API的入口.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Status =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034913Z" changeid="xf">
        <seg>= 状态 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Synopsis =
&lt;geshi lang=&quot;nginx&quot;&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035107Z" changeid="xf">
        <seg>= 示例 =
&lt;geshi lang=&quot;nginx&quot;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Version =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034958Z" changeid="xf">
        <seg>= 版本 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== Core constants ==
'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, *log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032827Z" changeid="xf">
        <seg>== 核心常量 ==
'''可包含于:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, *log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== HTTP method constants ==
'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033148Z" changeid="xf">
        <seg>== HTTP 请求方法常量 ==
'''可包含于:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== HTTP status constants ==
'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033525Z" changeid="xf">
        <seg>== HTTP status constants ==
'''可包含于:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== Nginx log level constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033551Z" changeid="xf">
        <seg>== Nginx 日志级别常量 ==
'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== lua_code_cache ==
'''syntax:''' ''lua_code_cache on | off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041947Z" changeid="xf">
        <seg>== lua_code_cache ==
'''语法:''' ''lua_code_cache on | off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== lua_regex_cache_max_entries ==
'''syntax:''' ''lua_regex_cache_max_entries &lt;num&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T053917Z" changeid="xf">
        <seg>== lua_regex_cache_max_entries ==
'''语法:''' ''lua_regex_cache_max_entries &lt;num&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== lua_regex_match_limit ==
'''syntax:''' ''lua_regex_match_limit &lt;num&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060238Z" changeid="xf">
        <seg>== lua_regex_match_limit ==
'''语法:''' ''lua_regex_match_limit &lt;num&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.arg ==
'''syntax:''' ''val = ngx.arg[index]''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024446Z" changeid="xf">
        <seg>== ngx.arg ==
'''语法:''' ''val = ngx.arg[index]''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.ctx ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034410Z" changeid="xf">
        <seg>== ngx.ctx ==
'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.exec ==
'''syntax:''' ''ngx.exec(uri, args?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032243Z" changeid="xf">
        <seg>== ngx.exec ==
'''语法:''' ''ngx.exec(uri, args?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.exit ==
'''syntax:''' ''ngx.exit(status)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042435Z" changeid="xf">
        <seg>== ngx.exit ==
'''语法:''' ''ngx.exit(status)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.flush ==
'''syntax:''' ''ok, err = ngx.flush(wait?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041750Z" changeid="xf">
        <seg>== ngx.flush ==
'''语法:''' ''ok, err = ngx.flush(wait?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.header.HEADER ==
'''syntax:''' ''ngx.header.HEADER = VALUE''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083750Z" changeid="xf">
        <seg>== ngx.header.HEADER ==
'''语法:''' ''ngx.header.HEADER = VALUE''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.headers_sent ==
'''syntax:''' ''value = ngx.headers_sent''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040439Z" changeid="xf">
        <seg>== ngx.headers_sent ==
'''语法:''' ''value = ngx.headers_sent''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.location.capture ==
'''syntax:''' ''res = ngx.location.capture(uri, options?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035830Z" changeid="xf">
        <seg>== ngx.location.capture ==
'''语法:''' ''res = ngx.location.capture(uri, options?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.location.capture_multi ==
'''syntax:''' ''res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082750Z" changeid="xf">
        <seg>== ngx.location.capture_multi ==
'''语法:''' ''res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.log ==
'''syntax:''' ''ngx.log(log_level, ...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041545Z" changeid="xf">
        <seg>== ngx.log ==
'''语法:''' ''ngx.log(log_level, ...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.print ==
'''syntax:''' ''ok, err = ngx.print(...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040810Z" changeid="xf">
        <seg>== ngx.print ==
'''语法:''' ''ok, err = ngx.print(...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.redirect ==
'''syntax:''' ''ngx.redirect(uri, status?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034226Z" changeid="xf">
        <seg>== ngx.redirect ==
'''语法:''' ''ngx.redirect(uri, status?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.append_body ==
'''syntax:''' ''ngx.req.append_body(data_chunk)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030913Z" changeid="xf">
        <seg>== ngx.req.append_body ==
'''语法:''' ''ngx.req.append_body(data_chunk)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.clear_header ==
'''syntax:''' ''ngx.req.clear_header(header_name)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021231Z" changeid="xf">
        <seg>== ngx.req.clear_header ==
'''语法:''' ''ngx.req.clear_header(header_name)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.discard_body ==
'''syntax:''' ''ngx.req.discard_body()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022555Z" changeid="xf">
        <seg>== ngx.req.discard_body ==
'''语法:''' ''ngx.req.discard_body()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.finish_body ==
'''syntax:''' ''ngx.req.finish_body()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031045Z" changeid="xf">
        <seg>== ngx.req.finish_body ==
'''语法:''' ''ngx.req.finish_body()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.get_body_data ==
'''syntax:''' ''data = ngx.req.get_body_data()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023007Z" changeid="xf">
        <seg>== ngx.req.get_body_data ==
'''语法:''' ''data = ngx.req.get_body_data()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.get_body_file ==
'''syntax:''' ''file_name = ngx.req.get_body_file()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023531Z" changeid="xf">
        <seg>== ngx.req.get_body_file ==
'''语法:''' ''file_name = ngx.req.get_body_file()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.get_method ==
'''syntax:''' ''method_name = ngx.req.get_method()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095342Z" changeid="xf">
        <seg>== ngx.req.get_method ==
'''语法:''' ''method_name = ngx.req.get_method()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.get_post_args ==
'''syntax:''' ''args, err = ngx.req.get_post_args(max_args?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103351Z" changeid="xf">
        <seg>== ngx.req.get_post_args ==
'''语法:''' ''args, err = ngx.req.get_post_args(max_args?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.get_uri_args ==
'''syntax:''' ''args = ngx.req.get_uri_args(max_args?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102527Z" changeid="xf">
        <seg>== ngx.req.get_uri_args ==
'''语法:''' ''args = ngx.req.get_uri_args(max_args?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.http_version ==
'''syntax:''' ''num = ngx.req.http_version()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094405Z" changeid="xf">
        <seg>== ngx.req.http_version ==
'''语法:''' ''num = ngx.req.http_version()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.init_body ==
'''syntax:''' ''ngx.req.init_body(buffer_size?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024333Z" changeid="xf">
        <seg>== ngx.req.init_body ==
'''语法:''' ''ngx.req.init_body(buffer_size?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.raw_header ==
'''syntax:''' ''str = ngx.req.raw_header(no_request_line?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095149Z" changeid="xf">
        <seg>== ngx.req.raw_header ==
'''语法:''' ''str = ngx.req.raw_header(no_request_line?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.read_body ==
'''syntax:''' ''ngx.req.read_body()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021301Z" changeid="xf">
        <seg>== ngx.req.read_body ==
'''语法:''' ''ngx.req.read_body()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_body_data ==
'''syntax:''' ''ngx.req.set_body_data(data)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023813Z" changeid="xf">
        <seg>== ngx.req.set_body_data ==
'''语法:''' ''ngx.req.set_body_data(data)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_body_file ==
'''syntax:''' ''ngx.req.set_body_file(file_name, auto_clean?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024046Z" changeid="xf">
        <seg>== ngx.req.set_body_file ==
'''语法:''' ''ngx.req.set_body_file(file_name, auto_clean?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_header ==
'''syntax:''' ''ngx.req.set_header(header_name, header_value)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020723Z" changeid="xf">
        <seg>== ngx.req.set_header ==
'''语法:''' ''ngx.req.set_header(header_name, header_value)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_method ==
'''syntax:''' ''ngx.req.set_method(method_id)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095529Z" changeid="xf">
        <seg>== ngx.req.set_method ==
'''语法:''' ''ngx.req.set_method(method_id)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_uri ==
'''syntax:''' ''ngx.req.set_uri(uri, jump?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095703Z" changeid="xf">
        <seg>== ngx.req.set_uri ==
'''语法:''' ''ngx.req.set_uri(uri, jump?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_uri_args ==
'''syntax:''' ''ngx.req.set_uri_args(args)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102238Z" changeid="xf">
        <seg>== ngx.req.set_uri_args ==
'''语法:''' ''ngx.req.set_uri_args(args)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.socket ==
'''syntax:''' ''tcpsock, err = ngx.req.socket()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031229Z" changeid="xf">
        <seg>== ngx.req.socket ==
'''语法:''' ''tcpsock, err = ngx.req.socket()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.start_time ==
'''syntax:''' ''secs = ngx.req.start_time()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091413Z" changeid="xf">
        <seg>== ngx.req.start_time ==
'''语法:''' ''secs = ngx.req.start_time()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.say ==
'''syntax:''' ''ok, err = ngx.say(...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041515Z" changeid="xf">
        <seg>== ngx.say ==
'''语法:''' ''ok, err = ngx.say(...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.send_headers ==
'''syntax:''' ''ok, err = ngx.send_headers()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040144Z" changeid="xf">
        <seg>== ngx.send_headers ==
'''语法:''' ''ok, err = ngx.send_headers()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.status ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083555Z" changeid="xf">
        <seg>== ngx.status ==
'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.var.VARIABLE ==
'''syntax:''' ''ngx.var.VAR_NAME''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032025Z" changeid="xf">
        <seg>== ngx.var.VARIABLE ==
'''语法:''' ''ngx.var.VAR_NAME''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== print ==
'''syntax:''' ''print(...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033734Z" changeid="xf">
        <seg>== print ==
'''语法:''' ''print(...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== set_by_lua_file ==
'''syntax:''' ''set_by_lua_file $res &lt;path-to-lua-script-file&gt; [$arg1 $arg2 ...]''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073346Z" changeid="xf">
        <seg>== set_by_lua_file ==
'''语法:''' ''set_by_lua_file $res &lt;path-to-lua-script-file&gt; [$arg1 $arg2 ...]''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more sophisticated example involving regex substitutions is as follows</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102121Z" changeid="xf">
        <seg>下面是一个更复杂的包含正则替换的例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing &lt;code&gt;/lua&lt;/code&gt; will yield the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T080725Z" changeid="xf">
        <seg>访问 &lt;code&gt;/lua&lt;/code&gt; 的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via [[#ngx.req.socket|ngx.req.socket]], then ngx_lua will neither stop all the running &quot;light threads&quot; nor call the user callback (if [[#ngx.on_abort|ngx.on_abort]] has been called).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021649Z" changeid="xf">
        <seg>但是，根据当前的实现，如果客户端在Lua代码使用[[#ngx.req.socketngx.req.socket]]读取请求体数据之前就关闭的连接, ngx_lua模块既不会停止所有运行中的 &quot;轻量线程&quot; 也不会调用用户回调 (如果 [[#ngx.on_abort|ngx.on_abort]] 曾经被调用的话).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acts as a &quot;content handler&quot; and executes Lua code string specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; for every request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073936Z" changeid="xf">
        <seg>作为一个 &quot;content handler&quot;，为每个请求执行 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt;中的代码.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acts as a rewrite phase handler and executes Lua code string specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; for every request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074441Z" changeid="xf">
        <seg>作为一个 rewrite phase handler，为每个请求执行 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; 中的代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acts as an access phase handler and executes Lua code string specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; for every request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T081031Z" changeid="xf">
        <seg>作为一个 access phase handler运行，为每个请求执行 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; 中的代码.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these directives will run in the same order as they appear in the config file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073153Z" changeid="xf">
        <seg>所有的命令按照它们在配置文件中出现的次序执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Almost all the Nginx modules can be used with this ngx_lua module by means of [[#ngx.location.capture|ngx.location.capture]] or [[#ngx.location.capture_multi|ngx.location.capture_multi]] but it is recommended to use those &lt;code&gt;lua-resty-*&lt;/code&gt; libraries instead of creating subrequests to access the Nginx upstream modules because the former is usually much more flexible and memory-efficient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041351Z" changeid="xf">
        <seg>几乎所有的Nginx模块都可以通过 [[#ngx.location.capture|ngx.location.capture]] 或 [[#ngx.location.capture_multi|ngx.location.capture_multi]]来使用ngx_lua模块。但推荐使用 &lt;code&gt;lua-resty-*&lt;/code&gt; 库而不是创建subrequest来访问Nginx upstream模块，因为前者通常有高得多的灵活性和内存效率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that subrequests just mimic the HTTP interface but there is ''no'' extra HTTP/TCP traffic ''nor'' IPC involved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040616Z" changeid="xf">
        <seg>请注意子请求只是模拟了 HTTP 接口，但事实上 ''并没有'' 额外的 HTTP/TCP 流量 ''也没有'' IPC 调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, Lua files which are loaded by &lt;code&gt;dofile&lt;/code&gt; or &lt;code&gt;loadfile&lt;/code&gt;
in *_by_lua_file will never be cached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T042851Z" changeid="xf">
        <seg>还有，*_by_lua_file中使用 &lt;code&gt;dofile&lt;/code&gt; 或 &lt;code&gt;loadfile&lt;/code&gt;加载的Lua文件决不会被缓存.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, by default, an &lt;code&gt;__index&lt;/code&gt; metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020546Z" changeid="xf">
        <seg>同样, 默认会为结果Lua table添加一个 &lt;code&gt;__index&lt;/code&gt; 元方法，它会将所有的key都转换成纯小写形式，并且将所有的下划线转换成减号，以防止查找失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, when this function is used together with [[#ngx.req.socket|ngx.req.socket]], it is required to call [[#ngx.req.socket|ngx.req.socket]] ''before'' this function, or you will get the &quot;request body already exists&quot; error message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030628Z" changeid="xf">
        <seg>还有，如果此函数与 [[#ngx.req.socket|ngx.req.socket]] 一起使用, 必须在调用此函数之前 ''先'' 调用 [[#ngx.req.socket|ngx.req.socket]] , 否则将出现 &quot;request body already exists&quot; 错误.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, a Lua table can be passed for the &lt;code&gt;args&lt;/code&gt; argument for ngx_lua to carry out URI escaping and string concatenation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032459Z" changeid="xf">
        <seg>或者可以传一个Lua table给 &lt;code&gt;args&lt;/code&gt; 参数，让ngx_lua去完成URI转义和字符串拼接.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional option table can be fed as the second
argument, which supports the options:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041510Z" changeid="xf">
        <seg>可以为第2个可选参数提供一个选项table, 支持如下选项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And the &lt;code&gt;ngx.null&lt;/code&gt; constant will yield the &lt;code&gt;&quot;null&quot;&lt;/code&gt; string output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034047Z" changeid="xf">
        <seg>&lt;code&gt;ngx.null&lt;/code&gt; 常量也写入为 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And this is the default value of this directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060955Z" changeid="xf">
        <seg>0也是这个命令的默认值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And when there is such an event, it will call the user Lua function callback (registered by [[#ngx.on_abort|ngx.on_abort]]) or just stop and clean up all the Lua &quot;light threads&quot; running in the current request's request handler when there is no user callback function registered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021457Z" changeid="xf">
        <seg>当这种事件发生时，模块将调用用户提供的回调函数 (使用[[#ngx.on_abort|ngx.on_abort]]注册) ，如果用户没有提供回调函数，模块会简单地停止和清除所有在当前请求处理器中的Lua &quot;轻量线程&quot; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Append new data chunk specified by the &lt;code&gt;data_chunk&lt;/code&gt; argument onto the existing request body created by the [[#ngx.req.init_body|ngx.req.init_body]] call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030947Z" changeid="xf">
        <seg>将 &lt;code&gt;data_chunk&lt;/code&gt; 参数指定的数据块加到用[[#ngx.req.init_bodyngx.req.init_body]]创建的请求体中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arbitrary data values, including Lua closures and nested tables, can be inserted into this &quot;magic&quot; table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035719Z" changeid="xf">
        <seg>任何数据，包括Lua closure和嵌套的table，都可以被放入这个“神奇的”table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments without the &lt;code&gt;=&lt;value&gt;&lt;/code&gt; parts are treated as boolean arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102825Z" changeid="xf">
        <seg>没有 &lt;code&gt;=&lt;value&gt;&lt;/code&gt; 的部分将被视为 boolean 参数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As from the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release, Nginx variable interpolation is disabled in the &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; argument of this directive and therefore, the dollar sign character (&lt;code&gt;$&lt;/code&gt;) can be used directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073321Z" changeid="xf">
        <seg>从 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 起, 本命令中的&lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt;中禁止使用Nginx 变量 interpolation ，因此,(&lt;code&gt;$&lt;/code&gt;)可以直接使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As from the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release, the special notation &lt;code&gt;$prefix&lt;/code&gt; or &lt;code&gt;${prefix}&lt;/code&gt; can be used in the search path string to indicate the path of the &lt;code&gt;server prefix&lt;/code&gt; usually determined by the &lt;code&gt;-p PATH&lt;/code&gt; command-line option while starting the Nginx server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062200Z" changeid="xf">
        <seg>从&lt;code&gt;v0.5.0rc29&lt;/code&gt;版本开始, 特殊标记 &lt;code&gt;$prefix&lt;/code&gt; 或 &lt;code&gt;${prefix}&lt;/code&gt; 可以在路径字符串中用来表示 &lt;code&gt;server prefix&lt;/code&gt; 的路径，它通常可由在Nginx服务器启动时使用 &lt;code&gt;-p PATH&lt;/code&gt; 命令行参数来得到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with other access phase handlers, [[#access_by_lua|access_by_lua]] will ''not'' run in subrequests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094223Z" changeid="xf">
        <seg>与其它的 rewrite phase handlers一样, [[#access_by_luaaccess_by_lua]]也''不会''运行在 subrequests 中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At least the following Lua libraries and Nginx modules can be used with this ngx_lua module:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041203Z" changeid="xf">
        <seg>至少下列Lua库和Nginx模块可以与ngx_lua模块一同使用:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064250Z" changeid="xf">
        <seg>基本上你可以在这个上下文中安全地使用进行阻塞I/O的Lua库，因为在启动阶段阻塞主进程是完全ok的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the [http://en.wikipedia.org/wiki/Copy-on-write Copy-on-write (COW)] feature provided by many operating systems among all the worker processes, thus saving a lot of memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064038Z" changeid="xf">
        <seg>由于在这个上下文中的Lua代码是在Nginx fork它的worker进程（如果有的话）之前运行的，所以这里加载和数据或代码会在work进程之间享受很多操作系统都提供的 [http://en.wikipedia.org/wiki/Copy-on-write Copy-on-write (COW)]特性，能够节省大量内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because when the content length exceeds [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] but less than [[HttpCoreModule#client_max_body_size|client_max_body_size]], Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the [[HttpCoreModule#$request_body|$request_body]] variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102004Z" changeid="xf">
        <seg>因为如果内容长度超过了[[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] 但小于 [[HttpCoreModule#client_max_body_size|client_max_body_size]], Nginx 将会把数据缓存到存盘上的临时文件中， [[HttpCoreModule#$request_body|$request_body]]变量中将是空值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scene, the &quot;eof&quot; flag is just the &lt;code&gt;last_buf&lt;/code&gt; (for main requests) or &lt;code&gt;last_in_chain&lt;/code&gt; (for subrequests) flag of the Nginx chain link buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094337Z" changeid="xf">
        <seg>在内部实现里， &quot;eof&quot; 标记其实是Nginx缓冲区链中的 &lt;code&gt;last_buf&lt;/code&gt; (主请求) 或 &lt;code&gt;last_in_chain&lt;/code&gt; (子请求) 标记</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But note that, the [[#lua_shared_dict|lua_shared_dict]]'s shm storage will not be cleared through a config reload (via the &lt;code&gt;HUP&lt;/code&gt; signal, for example).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063337Z" changeid="xf">
        <seg>但请注意， [[#lua_shared_dict|lua_shared_dict]]的共享存储在重新加载配置文件（如通过&lt;code&gt;HUP&lt;/code&gt;信号）时不会被清空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But special care must be taken for injection attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073556Z" changeid="xf">
        <seg>但是要特别小心防止注入攻击。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, all the subrequests subsequently initiated by [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] will inherit the new header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021014Z" changeid="xf">
        <seg>所有用[[#ngx.location.capturengx.location.capture]] and [[#ngx.location.capture_multingx.location.capture_multi]]发起的子请求都默认继承新设置的头。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the request line and trailing &lt;code&gt;CR LF&lt;/code&gt; terminator will also be included.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095249Z" changeid="xf">
        <seg>默认情况下，包含请求行及结尾的 &lt;code&gt;CR LF&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, this directive is turned off and the Lua code is postponed to run at the end of the &lt;code&gt;rewrite&lt;/code&gt; phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020707Z" changeid="xf">
        <seg>默认情况下，本命令处于关闭状态，  Lua 代码在 &lt;code&gt;rewrite&lt;/code&gt; 阶段的最后运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the function with the &lt;code&gt;wait&lt;/code&gt; argument set to &lt;code&gt;true&lt;/code&gt; switches to synchronous mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042037Z" changeid="xf">
        <seg>如果 &lt;code&gt;wait&lt;/code&gt; 参数设为 &lt;code&gt;true&lt;/code&gt; 则切换到同步模式.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Care should be taken in using this option as variable scope sharing can have unexpected side effects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053834Z" changeid="xf">
        <seg>要谨慎使用这个选项，因为变量域的共享可能会带来预料之外的副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request's variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T054908Z" changeid="xf">
        <seg>子请求对这些变量的修改不会影响到父请求和那些分享父请求变量的子请求。.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check out [[#Nginx log level constants|Nginx log level constants]] for details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041743Z" changeid="xf">
        <seg>详情见 [[#Nginx log level constants|Nginx日志级别常量]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clear the current request's request header named &lt;code&gt;header_name&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021246Z" changeid="xf">
        <seg>清除当前请求中名为 &lt;code&gt;header_name&lt;/code&gt; 的头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Completes the construction process of the new request body created by the [[#ngx.req.init_body|ngx.req.init_body]] and [[#ngx.req.append_body|ngx.req.append_body]] calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031141Z" changeid="xf">
        <seg>完成由[[#ngx.req.init_bodyngx.req.init_body]] and [[#ngx.req.append_bodyngx.req.append_body]]实现的请求体创建过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034523Z" changeid="xf">
        <seg>考虑以下示例,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls the &lt;code&gt;lowat&lt;/code&gt; (low water) value for the cosocket send buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103021Z" changeid="xf">
        <seg>控制cosocket发送缓冲区的 &lt;code&gt;lowat&lt;/code&gt; 值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:send|send]] method and can be overridden by the [[#tcpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102834Z" changeid="xf">
        <seg>本命令控制 TCP/unix-domain socket 对象[[#tcpsock:send|send]] 方法中使用的默认超时时间， 可以用 [[#tcpsock:settimeout|settimeout]] 方法进行修改.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls the maximum number of &quot;running timers&quot; allowed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022803Z" changeid="xf">
        <seg>控制“正在运行的定时器“数量的上限.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls the maximum number of pending timers allowed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022739Z" changeid="xf">
        <seg>控制未过期定时器数量的上限.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls whether or not to disable postponing [[#rewrite_by_lua|rewrite_by_lua]] and [[#rewrite_by_lua_file|rewrite_by_lua_file]] directives to run at the end of the &lt;code&gt;rewrite&lt;/code&gt; request-processing phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020629Z" changeid="xf">
        <seg>控制是否禁止延后 [[#rewrite_by_lua|rewrite_by_lua]] 和[[#rewrite_by_lua_file|rewrite_by_lua_file]] 命令，使其在 &lt;code&gt;rewrite&lt;/code&gt; 请求处理阶段的最后运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls whether to transform underscores (&lt;code&gt;_&lt;/code&gt;) in the response header names specified in the [[#ngx.header.HEADER|ngx.header.HEADER]] API to hypens (&lt;code&gt;-&lt;/code&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020937Z" changeid="xf">
        <seg>控制是否将 [[#ngx.header.HEADER|ngx.header.HEADER]] API中指定的响应头名称里的下划线 (&lt;code&gt;_&lt;/code&gt;) 转换成减号 (&lt;code&gt;-&lt;/code&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the [[#ngx.req.append_body|ngx.req.append_body]] and [[#ngx.req.finish_body|ngx.req.finish_body]] APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T025041Z" changeid="xf">
        <seg>为当前请求创建一个新的空请求体，初始化其缓冲区供后续的 [[#ngx.req.append_body|ngx.req.append_body]] 和 [[#ngx.req.finish_body|ngx.req.finish_body]] 写入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Current possible values are 1.0, 1.1, and 0.9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094445Z" changeid="xf">
        <seg>目前可能的值有 1.0, 1.1, 和 0.9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently only numerical [[#HTTP method constants|method constants]] are supported, like &lt;code&gt;ngx.HTTP_POST&lt;/code&gt; and &lt;code&gt;ngx.HTTP_GET&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095619Z" changeid="xf">
        <seg>当前仅支持数字 [[#HTTP method constants|方法常量]], 如&lt;code&gt;ngx.HTTP_POST&lt;/code&gt; 和 &lt;code&gt;ngx.HTTP_GET&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declares a shared memory zone, &lt;code&gt;&lt;name&gt;&lt;/code&gt;, to serve as storage for the shm based Lua dictionary &lt;code&gt;ngx.shared.&lt;name&gt;&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102432Z" changeid="xf">
        <seg>声明一个共享内存区， &lt;code&gt;&lt;name&gt;&lt;/code&gt;, 作为基于共享内存的 Lua 字典 &lt;code&gt;ngx.shared.&lt;name&gt;&lt;/code&gt;的存储区.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default to 30 connections for every pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104147Z" changeid="xf">
        <seg>默认每个连接池最多30个连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delegating all network and disk I/O operations to Nginx's subrequests (via the [[#ngx.location.capture|ngx.location.capture]] method and similar) is strongly recommended for maximum performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024440Z" changeid="xf">
        <seg>为获得最好的性能，强烈推荐将网络和磁盘I/O委托给 Nginx's 子请求 (通过 [[#ngx.location.capture|ngx.location.capture]] 或类似的方法)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101613Z" changeid="xf">
        <seg>决定在运行 rewrite/access/access_by_lua* 之前是否强制读取请求体数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disabling the Lua code cache is strongly
discouraged for production use and should only be used during 
development as it has a significant negative impact on overall performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T052540Z" changeid="xf">
        <seg>禁止代码缓存在生产环境中是非常不推荐的，对整体的性能有很大的负面影响，只应用于开发阶段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disk operations with relatively small amount of data can be done using the standard Lua &lt;code&gt;io&lt;/code&gt; library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024349Z" changeid="xf">
        <seg>对少量数据的磁盘操作可以用标准Lua &lt;code&gt;io&lt;/code&gt; 库来完成，但是应尽可能避免对大文件的读取和写入，因为这会严重阻塞Nginx进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not activate the &lt;code&gt;o&lt;/code&gt; option for regular expressions (and/or &lt;code&gt;replace&lt;/code&gt; string arguments for [[#ngx.re.sub|ngx.re.sub]] and [[#ngx.re.gsub|ngx.re.gsub]]) that are generated ''on the fly'' and give rise to infinite variations to avoid hitting the specified limit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060232Z" changeid="xf">
        <seg>不要为运行时动态生成的正则表达式设置&lt;code&gt;o&lt;/code&gt;模式，（或是为 [[#ngx.re.sub|ngx.re.sub]] 和 [[#ngx.re.gsub|ngx.re.gsub]] 提供&lt;code&gt;replace&lt;/code&gt; 字符串参数) 以避免超限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not turn on the [[#lua_need_request_body|lua_need_request_body]] directive, and do not mix this call with [[#ngx.req.read_body|ngx.req.read_body]] and [[#ngx.req.discard_body|ngx.req.discard_body]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032030Z" changeid="xf">
        <seg>不要打开 [[#lua_need_request_body|lua_need_request_body]] 命令, 而且不要将本函数与 [[#ngx.req.read_body|ngx.req.read_body]] 和 [[#ngx.req.discard_body|ngx.req.discard_body]] 混用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not use this directive and other content handler directives in the same location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074119Z" changeid="xf">
        <seg>在同一个location中不要同时使用本命令和其它content handler命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does an internal redirect to &lt;code&gt;uri&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032310Z" changeid="xf">
        <seg>使用&lt;code&gt;args&lt;/code&gt;作为参数发起到 &lt;code&gt;uri&lt;/code&gt; 的内部重定向 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits arguments concatenated to the HTTP client (as response body).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040851Z" changeid="xf">
        <seg>将参数（作为响应体）发送给客户端.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty key arguments are discarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102923Z" changeid="xf">
        <seg>空的key参数将被丢弃.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enables or disables automatic response buffering for HTTP 1.0 (or older) requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015900Z" changeid="xf">
        <seg>打开/关闭 HTTP 1.0(或更低版本)的请求的自动响应缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enables or disables the Lua code cache for [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#rewrite_by_lua_file|rewrite_by_lua_file]], and
[[#access_by_lua_file|access_by_lua_file]], and also force Lua module reloading on a per-request basis.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T042233Z" changeid="xf">
        <seg>为 [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#rewrite_by_lua_file|rewrite_by_lua_file]], and
[[#access_by_lua_file|access_by_lua_file]] 打开或关闭Lua代码缓存, 同时强制为每个请求重新加载Lua模块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#access_by_lua|access_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094350Z" changeid="xf">
        <seg>同 [[#access_by_lua|access_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含 Lua 代码, 或者, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#body_filter_by_lua|body_filter_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091639Z" changeid="xf">
        <seg>同 [[#body_filter_by_lua|body_filter_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含 Lua 代码, 或者, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#content_by_lua|content_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074238Z" changeid="xf">
        <seg>同 [[#content_by_lua|content_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含或, 从&lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#header_filter_by_lua|header_filter_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094748Z" changeid="xf">
        <seg>同 [[#header_filter_by_luaheader_filter_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含 Lua 代码, 或者, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#init_by_lua|init_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code or [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T071952Z" changeid="xf">
        <seg>类似 [[#init_by_lua|init_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含 Lua 代码或是 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#log_by_lua|log_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101453Z" changeid="xf">
        <seg>同[[#log_by_lua|log_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含或, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含[[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#rewrite_by_lua|rewrite_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080713Z" changeid="xf">
        <seg>同[[#rewrite_by_lua|rewrite_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含或, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含[[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#set_by_lua|set_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073511Z" changeid="xf">
        <seg>同 [[#set_by_lua|set_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含 Lua 代码, 或者, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even the Nginx core does blocking I/O (at least on resolving upstream's host names) at the configure-loading phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064341Z" changeid="xf">
        <seg> Nginx 内核自己在加载配置的阶段也用阻塞 I/O (至少在解析 upstream 主机名时) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every request, including subrequests, has its own copy of the table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035150Z" changeid="xf">
        <seg>每个请求, 包括子请求, 都有对这个table的独立拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Everything works internally, efficiently, on the C level.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040744Z" changeid="xf">
        <seg>一切都在内部C这一层高效运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executes code specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; with optional input arguments &lt;code&gt;$arg1 $arg2 ...&lt;/code&gt;, and returns string output to &lt;code&gt;$res&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073007Z" changeid="xf">
        <seg>执行 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; 中的代码，可选参数 &lt;code&gt;$arg1 $arg2 ...&lt;/code&gt;, 返回字符串输出到 &lt;code&gt;$res&lt;/code&gt;中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022634Z" changeid="xf">
        <seg>显式地丢弃请求体，即, 从连接中读取数据但是马上丢掉它.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly send out the response headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040202Z" changeid="xf">
        <seg>显式地发送响应头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flushes response output to the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041807Z" changeid="xf">
        <seg>将响应数据输出至客户端.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For (soft) real-time web applications, it is highly recommended to configure the [http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html TCP keepalive] support in your system's TCP stack implementation in order to detect &quot;half-open&quot; TCP connections in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022251Z" changeid="xf">
        <seg>对于 (软) 实时web应用, 强烈推荐为系统的TCP栈实现配置 [http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html TCP keepalive] 支持以便随时检测 &quot;半开&quot;TCP连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074847Z" changeid="xf">
        <seg>例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if a request header &lt;code&gt;My-Foo-Header&lt;/code&gt; is present, then the following invocations will all pick up the value of this header correctly:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020614Z" changeid="xf">
        <seg>例如，如果有一个请求头 &lt;code&gt;My-Foo-Header&lt;/code&gt; , 以下各种写法都能正确获得这个头的值:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, on Linux, you can configure the standard [[HttpCoreModule#listen|listen]] directive in your &lt;code&gt;nginx.conf&lt;/code&gt; file like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022334Z" changeid="xf">
        <seg>例如，在Linux上，你可以在&lt;code&gt;nginx.conf&lt;/code&gt;文件中这样配置标准的 [[HttpCoreModule#listen|listen]] 命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, response headers</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091221Z" changeid="xf">
        <seg>例如，响应头</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following nginx config snippet</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101928Z" changeid="xf">
        <seg>例如，下面的nginx配置代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this directive and the [[HttpProxyModule#proxy_pass|proxy_pass]] directive should not be used in the same location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074150Z" changeid="xf">
        <seg>例如， 这条命令和 [[HttpProxyModule#proxy_pass|proxy_pass]] 命令不允许在同一个location中使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to transform all the lowercase letters in the response body, we can just write:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094653Z" changeid="xf">
        <seg>例如，要将转换响应体中的所有小写字母，可以写:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when using the standard &lt;code&gt;ngx_proxy&lt;/code&gt; module to serve
subrequests, an &quot;Accept-Encoding: gzip&quot; header in the main request may result
in gzipped responses that cannot be handled properly in Lua code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082222Z" changeid="xf">
        <seg>例如，如果用标准的 &lt;code&gt;ngx_proxy&lt;/code&gt; 模块来为子请求服务, 主请求中的 &quot;Accept-Encoding: gzip&quot; 头可能会导致无法被Lua代码正常处理的被压缩的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032119Z" changeid="xf">
        <seg>例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035521Z" changeid="xf">
        <seg>例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, Nginx config</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102210Z" changeid="xf">
        <seg>例如，Nginx配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if the subrequest response headers contain the following
lines:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041109Z" changeid="xf">
        <seg>例如， 如果子请求响应头包含 :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For multi-value headers, all of the values of header will be collected in order and returned as a Lua table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091215Z" changeid="xf">
        <seg>对于多值头，所有的值将按顺序放在一个Lua table中返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For multi-value response headers,
the value is a Lua (array) table that holds all the values in the order that
they appear.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041050Z" changeid="xf">
        <seg>对于有多值的响应头,
其值是装有按出现顺序排序的所有值的 Lua (数组) table</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For multiple instances of request headers such as:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015506Z" changeid="xf">
        <seg>对于有多个值的请求头如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For reading ''request'' headers, use the [[#ngx.req.get_headers|ngx.req.get_headers]] function instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091409Z" changeid="xf">
        <seg>要读取 ''请求'' 头, 用 [[#ngx.req.get_headers|ngx.req.get_headers]] 函数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, changes to Nginx variables made by a subrequest will affect the current request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053805Z" changeid="xf">
        <seg>这样，子请求中对Nginx变量的修改将会影响到当前请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a basic example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040824Z" changeid="xf">
        <seg>这是一个基本的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024615Z" changeid="xf">
        <seg>示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example assuming the current server name is &lt;code&gt;localhost&lt;/code&gt; and that it is listening on Port 1984:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034415Z" changeid="xf">
        <seg>以下的例子假设当前的服务器名为 &lt;code&gt;localhost&lt;/code&gt; 监听 1984 端口:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example for pre-loading Lua modules:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063012Z" changeid="xf">
        <seg>以下是预加载 Lua 的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example for this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063119Z" changeid="xf">
        <seg>例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example of gathering average data for [[HttpUpstreamModule#$upstream_response_time|$upstream_response_time]]:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101253Z" changeid="xf">
        <seg>以下是收集 [[HttpUpstreamModule#$upstream_response_time|$upstream_response_time]] 平均值的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094616Z" changeid="xf">
        <seg>下面是在Lua 头过滤器中重写（如果没有就添加）一个响应头的例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example of setting the &lt;code&gt;Content-Length&lt;/code&gt; header:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021031Z" changeid="xf">
        <seg>以下是设置 &lt;code&gt;Content-Length&lt;/code&gt; 头的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the &lt;code&gt;args&lt;/code&gt; table will always look like</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103042Z" changeid="xf">
        <seg>这里 &lt;code&gt;args&lt;/code&gt; table 的内容为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the Lua code &lt;code&gt;ngx.exit(503)&lt;/code&gt; will never run.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080226Z" changeid="xf">
        <seg>此处 &lt;code&gt;ngx.exit(503)&lt;/code&gt; 不会被执行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, modification of the &lt;code&gt;ngx.ctx.blah&lt;/code&gt; entry in the subrequest does not affect the one in the parent request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035421Z" changeid="xf">
        <seg>这里，对子请求中的 &lt;code&gt;ngx.ctx.blah&lt;/code&gt; 进行修改不会影响其父请求中的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a workaround is possible using the [[#ngx.var.VARIABLE|ngx.var.VARIABLE]] interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072544Z" changeid="xf">
        <seg>但是可以使用 [[#ngx.var.VARIABLE|ngx.var.VARIABLE]] 来绕过这个限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the optional &lt;code&gt;max_args&lt;/code&gt; function argument can be used to override this limit:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103242Z" changeid="xf">
        <seg>但是, 可以用可选的&lt;code&gt;max_args&lt;/code&gt; 函数参数修改这个上限:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the optional &lt;code&gt;max_headers&lt;/code&gt; function argument can be used to override this limit:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015648Z" changeid="xf">
        <seg>但是, 可以用可选的&lt;code&gt;max_headers&lt;/code&gt; 函数参数修改这个上限:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they are different from arguments taking empty string values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102908Z" changeid="xf">
        <seg>要注意，这与value为空字符串的参数是不一样的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032230Z" changeid="xf">
        <seg>如果已经有请求体数据被预加载进了Nginx核心请求处理器缓冲区， 返回的cosocket对象将考虑到这一点，以避免这种预加载造成的潜在数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If response headers have not been sent, this function will send headers out first and then output body data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040915Z" changeid="xf">
        <seg>如果尚未发送响应头，此函数将先发送头，再发送体数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;code&gt;break&lt;/code&gt; modifier is used instead, there will be no internal redirection and the &lt;code&gt;rewrite_by_lua&lt;/code&gt; code will be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080509Z" changeid="xf">
        <seg>相反，如果使用了 &lt;code&gt;break&lt;/code&gt; , 就不会有内部重定向， &lt;code&gt;rewrite_by_lua&lt;/code&gt; 将被执行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;code&gt;buffer_size&lt;/code&gt; argument is specified, then its value will be used for the size of the memory buffer for body writing with [[#ngx.req.append_body|ngx.req.append_body]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T025126Z" changeid="xf">
        <seg>如果指定了 &lt;code&gt;buffer_size&lt;/code&gt; 参数, 则将会用这个值作为供 [[#ngx.req.append_bodyngx.req.append_body]] 写入的内存缓冲区的大小.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Lua code explicitly sets a &lt;code&gt;Content-Length&lt;/code&gt; response header before sending the headers (either explicitly via [[#ngx.send_headers|ngx.send_headers]] or implicitly via the first [[#ngx.say|ngx.say]] or [[#ngx.print|ngx.print]] call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020326Z" changeid="xf">
        <seg>如果Lua代码在发送头（显式地通过[[#ngx.send_headersngx.send_headers]]或者隐式地通过第一个[[#ngx.sayngx.say]] 或 [[#ngx.printngx.print]]调用）之前显式地设置了 &lt;code&gt;Content-Length&lt;/code&gt; 响应头，, 那么即使本命令被打开， 也不会进行HTTP 1.0 响应缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the [[HttpRewriteModule]]'s [[HttpRewriteModule#rewrite|rewrite]] directive is used to change the URI and initiate location re-lookups (internal redirections), then any [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] code sequences within the current location will not be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080159Z" changeid="xf">
        <seg>如果使用了 [[HttpRewriteModule]] 的 [[HttpRewriteModule#rewrite|rewrite]] 命令来修改 URI 和初始 location re-lookups (内部重定向), 则当前location中的任何 [[#rewrite_by_lua|rewrite_by_lua]] 或 [[#rewrite_by_lua_file|rewrite_by_lua_file]] 代码都不会被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the argument is omitted, then the value specified by the standard [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] directive will be used instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030232Z" changeid="xf">
        <seg>如果没有这个参数, 将使用标准 [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] 命令指定的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current location includes [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] directives,
then the request body will be read just before the [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] code is run (and also at the
&lt;code&gt;rewrite&lt;/code&gt; phase).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102108Z" changeid="xf">
        <seg>如果当前的 location 包含[[#rewrite_by_lua|rewrite_by_lua]] 或 [[#rewrite_by_lua_file|rewrite_by_lua_file]] 命令,
那么请求体将在 [[#rewrite_by_lua|rewrite_by_lua]] 或 [[#rewrite_by_lua_file|rewrite_by_lua_file]] 代码运行之前被读取 (也是在
&lt;code&gt;rewrite&lt;/code&gt; 阶段).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current request is an Nginx subrequest, then the subrequest's method name will be returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095514Z" changeid="xf">
        <seg>如果当前请求是Nginx子请求, 将返回子请求的请求方法名称.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current request is an Nginx subrequest, then the subrequest's method will be overridden.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095653Z" changeid="xf">
        <seg>如果当前请求是Nginx子请求, 则子请求的请求方法将被设置为新值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current request's request body has not been read, then it will be properly discarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023937Z" changeid="xf">
        <seg>如果当前请求的请求体尚未被读取，则其将被正确地丢弃.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the message size exceeds this limit, Nginx will truncate the message text accordingly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034211Z" changeid="xf">
        <seg>如果消息长度超限，Nginx 会做相应的截断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional &lt;code&gt;auto_clean&lt;/code&gt; argument is given a &lt;code&gt;true&lt;/code&gt; value, then this file will be removed at request completion or the next time this function or [[#ngx.req.set_body_data|ngx.req.set_body_data]] are called in the same request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024222Z" changeid="xf">
        <seg>如果可选参数 &lt;code&gt;auto_clean&lt;/code&gt; 被设置为 &lt;code&gt;true&lt;/code&gt; , 则文件将在请求结束时，或同一次请求中再次调用 [[#ngx.req.set_body_data|ngx.req.set_body_data]] 时被删除.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body has already been explicitly discarded, either by the [[#ngx.req.discard_body|ngx.req.discard_body]] function or other modules, this function does not run and returns immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022009Z" changeid="xf">
        <seg>如果用[[#ngx.req.discard_bodyngx.req.discard_body]]函数或其它模块显式地丢弃了请求体，则此函数不会执行，立即返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body has already been read, this function does nothing and returns immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022947Z" changeid="xf">
        <seg>如果请求体已经被读取过了，则本函数不做任何事，直接返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body has been read into disk files, try calling the [[#ngx.req.get_body_file|ngx.req.get_body_file]] function instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023315Z" changeid="xf">
        <seg>如果请求体已经被读进磁盘临时文件, 试试调用[[#ngx.req.get_body_file|ngx.req.get_body_file]] 函数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body has been read into memory, try calling the [[#ngx.req.get_body_data|ngx.req.get_body_data]] function instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023749Z" changeid="xf">
        <seg>如果请求体已经被读入内存, 试试调用 [[#ngx.req.get_body_data|ngx.req.get_body_data]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body has not been read yet, call [[#ngx.req.read_body|ngx.req.read_body]] first (or turned on [[#lua_need_request_body|lua_need_request_body]] to force this module to read the request body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023233Z" changeid="xf">
        <seg>如果请求体尚未被读取, 先调用[[#ngx.req.read_body|ngx.req.read_body]] (或打开[[#lua_need_request_body|lua_need_request_body]] 来强制本模块读取请求体.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body is already read previously by turning on [[#lua_need_request_body|lua_need_request_body]] or by using other modules, then this function does not run and returns immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021924Z" changeid="xf">
        <seg>如果打开了[[#lua_need_request_bodylua_need_request_body]]或其它模块导致请求体已被读取，则此函数不会执行，立即返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the response header is not present at all, &lt;code&gt;nil&lt;/code&gt; will be returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091108Z" changeid="xf">
        <seg>如果没有响应头，则返回 &lt;code&gt;nil&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this option is set to &lt;code&gt;true&lt;/code&gt;, then the current request and associated subrequests will share the same Nginx variable scope.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053745Z" changeid="xf">
        <seg>如果这个选项被置为 &lt;code&gt;true&lt;/code&gt;, 则当前的请求与相关的子请求会共同同样的Nginx 变量域.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015751Z" changeid="xf">
        <seg>如果你的Lua代码中已经进行了正确的错误处理和记录日志，那么建议将此命令关闭，以避免在nginx错误日志文件中不必要的数据（这通常有很大的开销）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the two settings above, it is possible to specify
values for variables in the subrequest using the &lt;code&gt;vars&lt;/code&gt; option.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T055053Z" changeid="xf">
        <seg>除了上面两种设置外，也可以在子请求中通过 &lt;code&gt;vars&lt;/code&gt; 选项设置变量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, note that this directive can only write out a value to a single Nginx variable at
a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072520Z" changeid="xf">
        <seg>另外，注意这条命令每次只能写入一个Nginx变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, race conditions when reloading Lua modules are common for concurrent requests
when the code cache is disabled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T053856Z" changeid="xf">
        <seg>另外，如果禁止了代码缓存，在并发请求中重新加载模块经常会导致race condition。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of error, &lt;code&gt;nil&lt;/code&gt; will be returned as well as a string describing the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031817Z" changeid="xf">
        <seg>如果出错，将返回 &lt;code&gt;nil&lt;/code&gt; 和 描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception ''or'' terminate the current request with a 500 status code immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022109Z" changeid="xf">
        <seg>在出错的情况下，如在读取数据时的连接错误, 此函数会抛出Lua异常 ''或'' 直接终止当前请求并立即返回 500 状态码.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In cases where current request may have a request body and the request body data is not required, The [[#ngx.req.discard_body|ngx.req.discard_body]] function must be used to explicitly discard the request body to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022907Z" changeid="xf">
        <seg>有时候当前请求可能有但不一定有请求体，需要使用 [[#ngx.req.discard_body|ngx.req.discard_body]] 函数来显式地丢弃请求体，以防止在HTTP 1.1 keepalive或HTTP 1.1 pipelining时出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In older versions of Nginx, the limit was &lt;code&gt;50&lt;/code&gt; concurrent subrequests and in more recent versions, Nginx &lt;code&gt;1.1.x&lt;/code&gt; onwards, this was increased to &lt;code&gt;200&lt;/code&gt; concurrent subrequests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082516Z" changeid="xf">
        <seg>在旧版本的Nginx中, 这个上限是 &lt;code&gt;50&lt;/code&gt; 而在最近的版本, Nginx &lt;code&gt;1.1.x&lt;/code&gt; 以上, 这个上限增加到了 &lt;code&gt;200&lt;/code&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the [[HttpCoreModule#send_timeout|send_timeout]] setting has expired.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042137Z" changeid="xf">
        <seg>在同步模式中， 函数只有当所有输出数据全部写入系统发送缓冲区后，或到达 [[HttpCoreModule#send_timeout|send_timeout]] 设置的超时时限时才返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the settings above, &lt;code&gt;GET /test?a%20b=1%61+2&lt;/code&gt; will yield:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102753Z" changeid="xf">
        <seg>在上面的设置中, &lt;code&gt;GET /test?a%20b=1%61+2&lt;/code&gt; 的结果为:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the reading operation on [[#ngx.req.socket|ngx.req.socket]] will just return the error message &quot;client aborted&quot; as the second return value (the first return value is surely &lt;code&gt;nil&lt;/code&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021749Z" changeid="xf">
        <seg>而是从对[[#ngx.req.socket|ngx.req.socket]]的读操作中返回，携带错误信息 &quot;client aborted&quot; 作为第二个返回值 (第一个返回值当然是 &lt;code&gt;nil&lt;/code&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internal redirection will destroy the original request &lt;code&gt;ngx.ctx&lt;/code&gt; data (if any) and the new request will have an empty &lt;code&gt;ngx.ctx&lt;/code&gt; table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035518Z" changeid="xf">
        <seg>内部重定向将删除原始请求的 request &lt;code&gt;ngx.ctx&lt;/code&gt; 数据(如果有的话)，请的请求有一个空的 &lt;code&gt;ngx.ctx&lt;/code&gt; table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Issue a synchronous but still non-blocking ''Nginx Subrequest'' using &lt;code&gt;uri&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040005Z" changeid="xf">
        <seg>对&lt;code&gt;uri&lt;/code&gt;发起一个同步的但仍是非阻塞的 ''Nginx子请求''。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Issue an &lt;code&gt;HTTP 301&lt;/code&gt; or &lt;code&gt;302&lt;/code&gt; redirection to &lt;code&gt;uri&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034315Z" changeid="xf">
        <seg>发起到&lt;code&gt;uri&lt;/code&gt;的 &lt;code&gt;HTTP 301&lt;/code&gt; 或 &lt;code&gt;302&lt;/code&gt; 重定向.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Issuing a POST subrequest, for example, can be done as follows</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T042121Z" changeid="xf">
        <seg>例如，可以这样发起一个POST子请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also allows the registration of custom meta methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035743Z" changeid="xf">
        <seg>而且还允许注册自定义的元方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be the current request's [[#ngx.ctx|ngx.ctx]] table, which effectively makes the parent and its subrequest to share exactly the same context table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041754Z" changeid="xf">
        <seg>这个值可以是当前请求的 [[#ngx.ctx|ngx.ctx]] table, 其结果是父请求和子请求共享同一个context able</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is &lt;code&gt;302&lt;/code&gt; (&lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt;) by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034348Z" changeid="xf">
        <seg>默认值是 &lt;code&gt;302&lt;/code&gt; (&lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt;) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to directly require the packages in external Lua modules:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023904Z" changeid="xf">
        <seg>也可以直接在外部Lua模块里require这两个包:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to use this &lt;code&gt;ctx&lt;/code&gt; option to share the same [[#ngx.ctx|ngx.ctx]] table between the current (parent) request and the subrequest:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T081945Z" changeid="xf">
        <seg>也可以用 &lt;code&gt;ctx&lt;/code&gt; 在当前（父）请求和子请求之间共享同一个 [[#ngx.ctx|ngx.ctx]] table:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is equivalent to</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033829Z" changeid="xf">
        <seg>等价于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to always call the [[#ngx.req.finish_body|ngx.req.finish_body]] after all the data has been appended onto the current request body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030435Z" changeid="xf">
        <seg>有一点很重要，在所有数据都已加到当前请求体中后，必须调用 [[#ngx.req.finish_body|ngx.req.finish_body]] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended however, to use the [[#ngx.req.read_body|ngx.req.read_body]] and [[#ngx.req.discard_body|ngx.req.discard_body]] functions for finer control over the request body reading process instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102305Z" changeid="xf">
        <seg>推荐使用 [[#ngx.req.read_body|ngx.req.read_body]] 和 [[#ngx.req.discard_body|ngx.req.discard_body]] 函数来对请求体的读取过程进行精细控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended to combine the &lt;code&gt;return&lt;/code&gt; statement with this call, i.e., &lt;code&gt;return ngx.redirect(...)&lt;/code&gt;, so as to be more explicit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040140Z" changeid="xf">
        <seg>建议将本方法与 &lt;code&gt;return&lt;/code&gt; 一起使用, 即, &lt;code&gt;return ngx.redirect(...)&lt;/code&gt;, 这样意义更明确.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is strongly recommended to combine the &lt;code&gt;return&lt;/code&gt; statement with this call, i.e., &lt;code&gt;return ngx.exec(...)&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032920Z" changeid="xf">
        <seg>强烈建议将此函数与 &lt;code&gt;return&lt;/code&gt; 一起使用, 即, &lt;code&gt;return ngx.exec(...)&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns a Lua string rather than a Lua table holding all the parsed query arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023043Z" changeid="xf">
        <seg>它返回装有所有解析过的请求参数的Lua字符串，而不是Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should not be manually modified, renamed, or removed in Lua code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023726Z" changeid="xf">
        <seg>还要在Lua代码中对其进行修改，重命名或删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as [[#ngx.print|ngx.print]] but also emit a trailing newline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041541Z" changeid="xf">
        <seg>同 [[#ngx.print|ngx.print]] 但多发送一个尾部换行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as any other rewrite phase handlers, [[#rewrite_by_lua|rewrite_by_lua]] also runs in subrequests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074924Z" changeid="xf">
        <seg>与其它的 rewrite phase handlers一样, [[#rewrite_by_lua|rewrite_by_lua]]也运行在 subrequests 中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like [[#ngx.location.capture|ngx.location.capture]], but supports multiple subrequests running in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082813Z" changeid="xf">
        <seg>同[[#ngx.location.capture|ngx.location.capture]], 但是支持并行的多个子请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys and values are unescaped according to URI escaping rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102737Z" changeid="xf">
        <seg>key和value都根据URI转义规则进行转义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, new &quot;eof&quot; flag can also be specified by setting a boolean value to [[#ngx.arg|ngx.arg]][2].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094958Z" changeid="xf">
        <seg>类似的，也可以将[[#ngx.argngx.arg]][2]的值设为新的boolean值来修改 &quot;eof&quot; 标记。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loaded Lua modules persist in the nginx worker process level resulting in a small memory footprint in Lua even when under heavy loads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041648Z" changeid="xf">
        <seg>被加载的Lua模块保存在nginx worker进程一级，即使在高负载情况下也只有很小的内存开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Location jump will not be triggered otherwise, and only the current request's URI will be modified, which is also the default behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101832Z" changeid="xf">
        <seg>否则不会触发Location跳转, 而只是改变当前请求的 URI, 这也是默认的行为.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Log arguments concatenated to error.log with the given logging level.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041612Z" changeid="xf">
        <seg>用指定的日志级别将参数添加到error.log</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logically speaking, the [[#ngx.location.capture|ngx.location.capture]] can be implemented like this</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083542Z" changeid="xf">
        <seg>从逻辑上说, [[#ngx.location.capture|ngx.location.capture]] 可以这样来实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lua &lt;code&gt;nil&lt;/code&gt; arguments are accepted and result in literal &lt;code&gt;&quot;nil&quot;&lt;/code&gt; string while Lua booleans result in literal &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; string outputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041655Z" changeid="xf">
        <seg>Lua &lt;code&gt;nil&lt;/code&gt; 将输出 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 字符串 Lua boolean值输出 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lua &lt;code&gt;nil&lt;/code&gt; arguments are accepted and result in literal &lt;code&gt;&quot;nil&quot;&lt;/code&gt; strings while Lua booleans result in literal &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033946Z" changeid="xf">
        <seg>可接受Lua &lt;code&gt;nil&lt;/code&gt; 参数，写入的值为 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 字符串， 而Lua boolean值会被写入成 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lua &lt;code&gt;nil&lt;/code&gt; values will output &lt;code&gt;&quot;nil&quot;&lt;/code&gt; strings and Lua boolean values will output &lt;code&gt;&quot;true&quot;&lt;/code&gt; and &lt;code&gt;&quot;false&quot;&lt;/code&gt; literal strings respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041036Z" changeid="xf">
        <seg>Lua &lt;code&gt;nil&lt;/code&gt; 值输出为 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 字符串 ，Lua boolean 值分别输出为 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083446Z" changeid="xf">
        <seg>如果要发起的子请求的数量事先并不确定，可以在请求或响应中使用Lua table:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More Nginx APIs for Lua may be supported in this context upon future user requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064149Z" changeid="xf">
        <seg>如果将来有更多用户要求的话，会为这个上下文添加更多的Nginx API支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-value arguments are also supported:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102448Z" changeid="xf">
        <seg>也支持多值参数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-value headers can be set this way:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084130Z" changeid="xf">
        <seg>多值头可以这样设置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102717Z" changeid="xf">
        <seg>如果一个参数的key出现多次，则其value是一个按出现顺序保存多个值的table</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named locations are also supported, but query strings are ignored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032332Z" changeid="xf">
        <seg>支持具名location，但是query string将被忽略.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named locations like &lt;code&gt;@foo&lt;/code&gt; are not allowed due to a limitation in
the nginx core.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041328Z" changeid="xf">
        <seg>由于nginx内核的限制， 不允许有&lt;code&gt;@foo&lt;/code&gt; 这样的具名location。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041058Z" changeid="xf">
        <seg>支持嵌套的字符串数组，数组中的元素将一个一个地发送:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024152Z" changeid="xf">
        <seg>用户代码中的网络I/O操作只允许通过Nginx Lua API来进行，否则Nginx事件循环可能被阻塞，导致性能大降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091743Z" changeid="xf">
        <seg>Nginx 输入过滤器对单个请求可能被调用多次，这是因为响应体可能是分段发送的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nginx regex group capturing variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;, and etc, can be read by this
interface as well, by writing &lt;code&gt;ngx.var[1]&lt;/code&gt;, &lt;code&gt;ngx.var[2]&lt;/code&gt;, &lt;code&gt;ngx.var[3]&lt;/code&gt;, and etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032429Z" changeid="xf">
        <seg>Nginx 正则表达式组捕捉变量 &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;等也可以使用这一接口来读取, 写法是 &lt;code&gt;ngx.var[1]&lt;/code&gt;, &lt;code&gt;ngx.var[2]&lt;/code&gt;, &lt;code&gt;ngx.var[3]&lt;/code&gt;, 等等.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nginx variable interpolation is supported in the &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; argument string of this directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073537Z" changeid="xf">
        <seg>本命令的&lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt;参数支持Nginx 变量 interpolation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nginx variables can be used in the &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; string to provide flexibility.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074301Z" changeid="xf">
        <seg>为了更灵活， &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 中允许使用Nginx变量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nginx's subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or ''any'' other nginx C modules like &lt;code&gt;ngx_proxy&lt;/code&gt;, &lt;code&gt;ngx_fastcgi&lt;/code&gt;, &lt;code&gt;ngx_memc&lt;/code&gt;,
&lt;code&gt;ngx_postgres&lt;/code&gt;, &lt;code&gt;ngx_drizzle&lt;/code&gt;, and even ngx_lua itself and etc etc etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040515Z" changeid="xf">
        <seg>Nginx子请求提供了向其它location发起非阻塞的内部请求的强大手段，这些location可以用磁盘文件路径或 ''任何'' 其它ngixn C 模块如 &lt;code&gt;ngx_proxy&lt;/code&gt;, &lt;code&gt;ngx_fastcgi&lt;/code&gt;, &lt;code&gt;ngx_memc&lt;/code&gt;,
&lt;code&gt;ngx_postgres&lt;/code&gt;, &lt;code&gt;ngx_drizzle&lt;/code&gt;, 甚至是ngx_lua自己等等来配置.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-array table arguments will cause a Lua exception to be thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041130Z" changeid="xf">
        <seg>非数组table参数将抛出Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>None of the current request's subrequests will be affected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021256Z" changeid="xf">
        <seg>当前请求的任何子请求都不会受影响.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;code&gt;ngx.flush&lt;/code&gt; is non functional when in the HTTP 1.0 output buffering mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042406Z" changeid="xf">
        <seg>注意在HTTP 1.0 输出缓冲模式下 &lt;code&gt;ngx.flush&lt;/code&gt; 无效.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;code&gt;ngx.header&lt;/code&gt; is not a normal Lua table and as such, it is not possible to iterate through it using the Lua &lt;code&gt;ipairs&lt;/code&gt; function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091351Z" changeid="xf">
        <seg>注意 &lt;code&gt;ngx.header&lt;/code&gt; 不是一个正常的Lua table，所以不能使用&lt;code&gt;ipairs&lt;/code&gt;函数来对它进行遍历.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103214Z" changeid="xf">
        <seg>注意，默认最多只解析100个请求参数 (包括名称一样的) ，多出来的请求参数将被简单丢弃，以防止DOS攻击.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015634Z" changeid="xf">
        <seg>注意，默认最多只解析100个请求头 (包括名称一样的) ，多出来的请求头将被简单丢弃，以防止DOS攻击.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that calling this function instead of using &lt;code&gt;ngx.var.request_body&lt;/code&gt; or &lt;code&gt;ngx.var.echo_request_body&lt;/code&gt; is more efficient because it can save one dynamic memory allocation and one data copy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023523Z" changeid="xf">
        <seg>注意此方法比 &lt;code&gt;ngx.var.request_body&lt;/code&gt; 或 &lt;code&gt;ngx.var.echo_request_body&lt;/code&gt; 更高效，因为它可以节省一次动态内存分配和一次数据拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if both &lt;code&gt;share_all_vars&lt;/code&gt; and &lt;code&gt;copy_all_vars&lt;/code&gt; are set to true, then &lt;code&gt;share_all_vars&lt;/code&gt; takes precedence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T055024Z" changeid="xf">
        <seg>注意，如果 &lt;code&gt;share_all_vars&lt;/code&gt; 和 &lt;code&gt;copy_all_vars&lt;/code&gt; 都设为true, &lt;code&gt;share_all_vars&lt;/code&gt; 优先.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it is not possible to use this interface to rewrite URI arguments and that [[#ngx.req.set_uri_args|ngx.req.set_uri_args]] should be used for this instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102203Z" changeid="xf">
        <seg>注意不能使用这个接口来重写URI参数，请使用 [[#ngx.req.set_uri_args|ngx.req.set_uri_args]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that only already defined nginx variables can be written to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032116Z" changeid="xf">
        <seg>注意只有已经定义了的nginx变量可以被写入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that only three of these constants are utilized by the [[#Nginx API for Lua|Nginx API for Lua]] (i.e., [[#ngx.exit|ngx.exit]] accepts &lt;code&gt;NGX_OK&lt;/code&gt;, &lt;code&gt;NGX_ERROR&lt;/code&gt;, and &lt;code&gt;NGX_DECLINED&lt;/code&gt; as input).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033023Z" changeid="xf">
        <seg>注意这些常量中只有三个能被 [[#Nginx API for Lua|可供Lua调用的Nginx API]]使用 ([[#ngx.exit|ngx.exit]] 接受 &lt;code&gt;NGX_OK&lt;/code&gt;, &lt;code&gt;NGX_ERROR&lt;/code&gt;, and &lt;code&gt;NGX_DECLINED&lt;/code&gt; 作为输入).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that subrequests issued by [[#ngx.location.capture|ngx.location.capture]] inherit all the
request headers of the current request by default and that this may have unexpected side effects on the
subrequest responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082105Z" changeid="xf">
        <seg>注意在默认情况下 [[#ngx.location.capture|ngx.location.capture]] 发起的子请求将从当前请求中继承所有的请求头，这可能会对子请求的响应带来意料之外的副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the [[#ngx.var.VARIABLE|ngx.var.HEADER]] API call, which uses core [[HttpCoreModule#$http_HEADER|$http_HEADER]] variables, may be more preferable for reading individual request headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015443Z" changeid="xf">
        <seg>注意，使用内核模块[[HttpCoreModule#$http_HEADER$http_HEADER]]的 [[#ngx.var.VARIABLE|ngx.var.HEADER]] API, 可能更适合用来读取某一个头信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the [http://mdounin.ru/hg/ngx_http_auth_request_module/ ngx_auth_request] module can be approximated by using [[#access_by_lua|access_by_lua]]:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094135Z" changeid="xf">
        <seg>注意 [http://mdounin.ru/hg/ngx_http_auth_request_module/ ngx_auth_request] 模块可以用 [[#access_by_luaaccess_by_lua]]来实现.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the [http://www.grid.net.ru/nginx/eval.en.html ngx_eval] module can be approximated by using [[#rewrite_by_lua|rewrite_by_lua]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074843Z" changeid="xf">
        <seg>注意 [http://www.grid.net.ru/nginx/eval.en.html ngx_eval] 模块可以用 [[#rewrite_by_lua|rewrite_by_lua]]来实现.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104342Z" changeid="xf">
        <seg>注意cosocket连接池是每个nginx worker进程所有的而不是整个nginx服务器进程所有，所以这里所设置的上限也适用于每个单独的nginx worker 进程.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the following API functions are currently disabled within this context:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072426Z" changeid="xf">
        <seg>注意在这个上下文中以下 API 函数是被禁止的:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out
before content is output with [[#ngx.say|ngx.say]] or [[#ngx.print|ngx.print]] or when [[#content_by_lua|content_by_lua]] exits normally.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040435Z" changeid="xf">
        <seg>注意通常并不需要手动发送响应头，因为在[[#ngx.sayngx.say]] 或 [[#ngx.printngx.print]]之前或[[#content_by_luacontent_by_lua]]显式地退出时ngx_lua将自动地发送响应头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this handler always runs ''after'' the standard [[HttpAccessModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080947Z" changeid="xf">
        <seg>注意这个handler总是在标准 [[HttpAccessModule]] ''之后''执行 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this handler always runs ''after'' the standard [[HttpRewriteModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074529Z" changeid="xf">
        <seg>注意这个handler总是在标准 [[HttpRewriteModule]] ''之后''执行 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is very different from [[#ngx.redirect|ngx.redirect]] in that
it is just an internal redirect and no new HTTP traffic is involved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032556Z" changeid="xf">
        <seg>注意，这跟 [[#ngx.redirect|ngx.redirect]] 是完全不同的，它只是一个内部重定向，并没有新的HTTP流量产生.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042222Z" changeid="xf">
        <seg>注意使用Lua coroutine机制意味着此函数即使在同步模式下也不会阻塞 Nginx 事件循环.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when calling &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; within a [[#access_by_lua|access_by_lua]] handler, the nginx request processing control flow will still continue to the content handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094253Z" changeid="xf">
        <seg>注意在 [[#access_by_luaaccess_by_lua]] handler中调用&lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt;时, nginx请求处理控制流仍然会继续执行 content handler.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when calling &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; within a [[#rewrite_by_lua|rewrite_by_lua]] handler, the nginx request processing control flow will still continue to the content handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T075749Z" changeid="xf">
        <seg>注意在 [[#rewrite_by_lua|rewrite_by_lua]] handler中调用&lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt;时, nginx请求处理控制流仍然会继续执行 content handler.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022359Z" changeid="xf">
        <seg>在 FreeBSD 上, 你只能在系统级别配置 TCP keepalive, 如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, the following will not work as expected:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074627Z" changeid="xf">
        <seg>而下面的代码将不能得到预期的结果:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as &lt;code&gt;Content-Type&lt;/code&gt; that only accept a single value).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T090243Z" changeid="xf">
        <seg>仅支持 Lua table (对于只支持单个值的标准头如&lt;code&gt;Content-Type&lt;/code&gt;，只有table中的最后一个元素起作用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only [[#tcpsock:receive|receive]] and [[#tcpsock:receiveuntil|receiveuntil]] methods are supported on this object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031646Z" changeid="xf">
        <seg>此对象只支持 [[#tcpsock:receive|receive]] 和 [[#tcpsock:receiveuntil|receiveuntil]] 方法.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only a small set of the [[#Nginx API for Lua|Nginx API for Lua]] is supported in this context:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064106Z" changeid="xf">
        <seg>这个上下文中只支持很少一部分 [[#Nginx API for Lua|Nginx API for Lua]] :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Original request headers should be ignored by setting 
[[HttpProxyModule#proxy_pass_request_headers|proxy_pass_request_headers]] to &lt;code&gt;off&lt;/code&gt; in subrequest locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082305Z" changeid="xf">
        <seg>在子请求的location中应设置 
[[HttpProxyModule#proxy_pass_request_headers|proxy_pass_request_headers]] 为 &lt;code&gt;off&lt;/code&gt;来忽略主请求的头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overrides the current request's request method with the &lt;code&gt;request_id&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095554Z" changeid="xf">
        <seg>用&lt;code&gt;request_id&lt;/code&gt;参数覆盖当前请求的请求方法.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding &lt;code&gt;ngx.ctx&lt;/code&gt; with a new Lua table is also supported, for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035805Z" changeid="xf">
        <seg>用一个新的Lua table来覆盖 &lt;code&gt;ngx.ctx&lt;/code&gt; 也是支持的, 例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pending timers are those timers that have not expired yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022736Z" changeid="xf">
        <seg>未过期定时器指尚未过期的定时器.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please also refer to restrictions on capturing locations configured by [[#Locations_Configured_by_Subrequest_Directives_of_Other_Modules|subrequest directives of other modules]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082737Z" changeid="xf">
        <seg>请参阅 [[#Locations_Configured_by_Subrequest_Directives_of_Other_Modules|其它模块的子请求命令]]了解子请求location的限制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please ensure that the file specified by the &lt;code&gt;file_name&lt;/code&gt; argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024321Z" changeid="xf">
        <seg>请保证 &lt;code&gt;file_name&lt;/code&gt; 参数指定的文件真实存在，并且正确设置其访问权限，便利Nginx worker进程能够访问它，以避免抛出Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note however, that Lua code written inlined within nginx.conf
such as those specified by [[#set_by_lua|set_by_lua]], [[#content_by_lua|content_by_lua]],
[[#access_by_lua|access_by_lua]], and [[#rewrite_by_lua|rewrite_by_lua]] will ''always'' be
cached because only the Nginx config file parser can correctly parse the &lt;code&gt;nginx.conf&lt;/code&gt;
file and the only ways to to reload the config file
are to send a &lt;code&gt;HUP&lt;/code&gt; signal or to restart Nginx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T042755Z" changeid="xf">
        <seg>但是请注意，在nginx.conf中内置写入的 Lua 代码，如 [[#set_by_lua|set_by_lua]], [[#content_by_lua|content_by_lua]],
[[#access_by_lua|access_by_lua]], 和 [[#rewrite_by_lua|rewrite_by_lua]]中的，将“总是”被缓存，因为只有 Nginx 配置文件解析器能够正确解析 &lt;code&gt;nginx.conf&lt;/code&gt;
文件，重新加载配置文件的方法是发送 &lt;code&gt;HUP&lt;/code&gt; 信号或重启 Nginx.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note that both &lt;code&gt;ngx.print&lt;/code&gt; and [[#ngx.say|ngx.say]] will always invoke the whole Nginx output body filter chain, which is an expensive operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041427Z" changeid="xf">
        <seg>请注意 &lt;code&gt;ngx.print&lt;/code&gt; 和 [[#ngx.say|ngx.say]] 都将启动整个 Nginx 输出体过滤器链, 开销比较大.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note that ignoring request body is not the right way to discard it, and that this function must be called to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022851Z" changeid="xf">
        <seg>请注意，无视请求体（译注：无视指认为请求体不存在，与本方法的不同是不会从连接中读取请求体数据）不是丢弃它的正确方法, 因此必须调用本方法来防止在HTTP 1.1 keepalive 或 HTTP 1.1 pipelining时出错.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read and write Nginx variable values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032052Z" changeid="xf">
        <seg>读写Nginx变量的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read and write the current request's response status.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083614Z" changeid="xf">
        <seg>读写当前请求的响应状态码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading &lt;code&gt;ngx.header.HEADER&lt;/code&gt; will return the value of the response header named &lt;code&gt;HEADER&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T090951Z" changeid="xf">
        <seg>读取 &lt;code&gt;ngx.header.HEADER&lt;/code&gt; 将返回名为 &lt;code&gt;HEADER&lt;/code&gt;的响应头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reads the client request body synchronously without blocking the Nginx event loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021331Z" changeid="xf">
        <seg>同步读取客户端请求体，但是不阻塞Nginx事件循环.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redirecting arbitrary external URLs is also supported, for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034626Z" changeid="xf">
        <seg>也支持重定向到任意的外部URLs , 例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removing the &lt;code&gt;max_args&lt;/code&gt; cap is strongly discouraged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103340Z" changeid="xf">
        <seg>去除&lt;code&gt;max_args&lt;/code&gt; 限制是非常不推荐的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removing the &lt;code&gt;max_headers&lt;/code&gt; cap is strongly discouraged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015726Z" changeid="xf">
        <seg>去除&lt;code&gt;max_headers&lt;/code&gt; 限制是非常不推荐的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request &lt;code&gt;GET /lua&lt;/code&gt; will give the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T054939Z" changeid="xf">
        <seg>&lt;code&gt;GET /lua&lt;/code&gt; 的结果是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request &lt;code&gt;GET /lua&lt;/code&gt; yields the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T081959Z" changeid="xf">
        <seg>请求 &lt;code&gt;GET /lua&lt;/code&gt; 的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieves in-memory request body data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023020Z" changeid="xf">
        <seg>获取内存中的请求体数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieves the current request's request method name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095356Z" changeid="xf">
        <seg>获得当前请求的请求方法名称.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieves the file name for the in-file request body data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023558Z" changeid="xf">
        <seg>获取文件中请求体数据的文件名.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns &lt;code&gt;nil&lt;/code&gt; for unrecognized values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095131Z" changeid="xf">
        <seg>遇到不支持的版本号返回&lt;code&gt;nil&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns &lt;code&gt;nil&lt;/code&gt; if the request body has not been read or has been read into memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023651Z" changeid="xf">
        <seg>如果请求体尚未被读取或已经被读入内存，将返回&lt;code&gt;nil&lt;/code&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns &lt;code&gt;true&lt;/code&gt; if the response headers have been sent (by ngx_lua), and &lt;code&gt;false&lt;/code&gt; otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040621Z" changeid="xf">
        <seg>如果响应头已经被(ngx_lua)发送，返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Lua table holding all the current request URL query arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102601Z" changeid="xf">
        <seg>返回存有当前请求URL请求参数的Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Lua table holding all the current request headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015327Z" changeid="xf">
        <seg>返回持有当前请求所有头的Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Lua table with three slots (&lt;code&gt;res.status&lt;/code&gt;, &lt;code&gt;res.header&lt;/code&gt;, &lt;code&gt;res.body&lt;/code&gt;, and &lt;code&gt;res.truncated&lt;/code&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040924Z" changeid="xf">
        <seg>返回一个Lua table，内容包括三项 (&lt;code&gt;res.status&lt;/code&gt;, &lt;code&gt;res.header&lt;/code&gt;, &lt;code&gt;res.body&lt;/code&gt;, and &lt;code&gt;res.truncated&lt;/code&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094240Z" changeid="xf">
        <seg>返回表示当前请求创建时间的浮点数 (小数部分为毫秒).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a read-only cosocket object that wraps the downstream connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031251Z" changeid="xf">
        <seg>返回包装了下游连接的只读cosocket对象.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the HTTP version number for the current request as a Lua number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094434Z" changeid="xf">
        <seg>以Lua number的形式返回当前请求的HTTP版本号.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the original raw HTTP protocol header received by the Nginx server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095215Z" changeid="xf">
        <seg>返回Nginx服务器接收到的原始HTTP协议头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rewrite the current request's (parsed) URI by the &lt;code&gt;uri&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095730Z" changeid="xf">
        <seg>用&lt;code&gt;uri&lt;/code&gt;参数覆盖当前请求的 (解析过的) URI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rewrite the current request's URI query arguments by the &lt;code&gt;args&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102310Z" changeid="xf">
        <seg>用&lt;code&gt;args&lt;/code&gt;覆盖当前请求的URI请求参数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the Lua source code inlined as the &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; at the &lt;code&gt;log&lt;/code&gt; request processing phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091439Z" changeid="xf">
        <seg>在请求处理的 &lt;code&gt;log&lt;/code&gt; 阶段运行&lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt;中的lua代码.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running timers are those timers whose user callback functions are still running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022828Z" changeid="xf">
        <seg>正在运行的定时器指用户指定的回调函数仍在运行的定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Runs the Lua code specified by the argument &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062828Z" changeid="xf">
        <seg>在Nginx主进程（如果存在的话）加载Nginx配置文件时在全局Lua虚拟机级别运行由参数&lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt;指定的Lua代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See HTTP method constants methods other than POST.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053144Z" changeid="xf">
        <seg>除POST外还有其它的HTTP方法常量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See [[#HTTP 1.0 support|HTTP 1.0 support]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042416Z" changeid="xf">
        <seg>参阅 [[#HTTP 1.0 support|HTTP 1.0 支持]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See [[#ngx.flush|ngx.flush]] for more details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041336Z" changeid="xf">
        <seg>详情参阅 [[#ngx.flush|ngx.flush]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See [[#ngx.shared.DICT|ngx.shared.DICT]] for details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102508Z" changeid="xf">
        <seg>详情见[[#ngx.shared.DICT|ngx.shared.DICT]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.now|ngx.now]] and [[#ngx.update_time|ngx.update_time]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094401Z" changeid="xf">
        <seg>参阅 [[#ngx.now|ngx.now]] 和 [[#ngx.update_time|ngx.update_time]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.on_abort|ngx.on_abort]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022501Z" changeid="xf">
        <seg>参阅 [[#ngx.on_abort|ngx.on_abort]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.get_body_data|ngx.req.get_body_data]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023810Z" changeid="xf">
        <seg>参阅[[#ngx.req.get_body_data|ngx.req.get_body_data]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.get_method|ngx.req.get_method]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095659Z" changeid="xf">
        <seg>参阅 [[#ngx.req.get_method|ngx.req.get_method]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.init_body|ngx.req.init_body]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031041Z" changeid="xf">
        <seg>参阅 [[#ngx.req.init_body|ngx.req.init_body]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.read_body|ngx.req.read_body]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022952Z" changeid="xf">
        <seg>参阅[[#ngx.req.read_body|ngx.req.read_body]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.set_body_data|ngx.req.set_body_data]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024328Z" changeid="xf">
        <seg>参阅 [[#ngx.req.set_body_data|ngx.req.set_body_data]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.set_body_file|ngx.req.set_body_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024042Z" changeid="xf">
        <seg>参阅 [[#ngx.req.set_body_file|ngx.req.set_body_file]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.set_method|ngx.req.set_method]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095525Z" changeid="xf">
        <seg>参阅[[#ngx.req.set_method|ngx.req.set_method]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.set_uri|ngx.req.set_uri]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102523Z" changeid="xf">
        <seg>参阅[[#ngx.req.set_uri|ngx.req.set_uri]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set the current request's request body using the in-file data specified by the &lt;code&gt;file_name&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024124Z" changeid="xf">
        <seg>将当前请求的请求体设置成&lt;code&gt;file_name&lt;/code&gt; 参数指定的文件的内容.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set the current request's request body using the in-memory data specified by the &lt;code&gt;data&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023909Z" changeid="xf">
        <seg>将当前请求的请求体设置成&lt;code&gt;data&lt;/code&gt; 参数指定的内存数据 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set the current request's request header named &lt;code&gt;header_name&lt;/code&gt; to value &lt;code&gt;header_value&lt;/code&gt;, overriding any existing ones.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020903Z" changeid="xf">
        <seg>将当前请求名为 &lt;code&gt;header_name&lt;/code&gt; 的头的值设为&lt;code&gt;header_value&lt;/code&gt;, 替换其当前的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set, add to, or clear the current request's &lt;code&gt;HEADER&lt;/code&gt; response header that is to be sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084009Z" changeid="xf">
        <seg>对当前请求的 &lt;code&gt;HEADER&lt;/code&gt; 响应头进行设置、添加和清除.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the Lua C-module search path used by scripts specified by [[#set_by_lua|set_by_lua]],
[[#content_by_lua|content_by_lua]] and others.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062333Z" changeid="xf">
        <seg>设置由[[#set_by_luaset_by_lua]],
[[#content_by_luacontent_by_lua]]或其它指定写入的Lua脚本代码使用的C模块查找路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the Lua module search path used by scripts specified by [[#set_by_lua|set_by_lua]],
[[#content_by_lua|content_by_lua]] and others.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061758Z" changeid="xf">
        <seg>设置由 [[#set_by_luaset_by_lua]],
[[#content_by_luacontent_by_lua]]或其它指令写入的Lua脚本代码使用的Lua模块查找路径.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting &lt;code&gt;ngx.header.HEADER&lt;/code&gt; after sending out response headers (either explicitly with [[#ngx.send_headers|ngx.send_headers]] or implicitly with [[#ngx.print|ngx.print]] and similar) will throw out a Lua exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T090913Z" changeid="xf">
        <seg>在发送完响应头 (用 [[#ngx.send_headersngx.send_headers]]显式发送 或 用 [[#ngx.printngx.print]] 和类似方法隐式发送)设置&lt;code&gt;ngx.header.HEADER&lt;/code&gt; 将抛出Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting &lt;code&gt;ngx.status&lt;/code&gt; after the response header is sent out has no effect but leaving an error message in your nginx's error log file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083721Z" changeid="xf">
        <seg>在发送了响应头之后设置 &lt;code&gt;ngx.status&lt;/code&gt; 没有作用，但会在ngxin错误日志文件里产生一条错误信息: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting &lt;code&gt;ngx.var.Foo&lt;/code&gt; to a &lt;code&gt;nil&lt;/code&gt; value will unset the &lt;code&gt;$Foo&lt;/code&gt; Nginx variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032331Z" changeid="xf">
        <seg>将 &lt;code&gt;ngx.var.Foo&lt;/code&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; 将取消 &lt;code&gt;$Foo&lt;/code&gt; Nginx 变量的定义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting a slot to &lt;code&gt;nil&lt;/code&gt; effectively removes it from the response headers:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T090312Z" changeid="xf">
        <seg>将值设置成 &lt;code&gt;nil&lt;/code&gt; 的结果是将它从响应头中删除:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, Nginx config</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101947Z" changeid="xf">
        <seg>类似的, Nginx 配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if only [[#content_by_lua|content_by_lua]] is specified,
the request body will not be read until the content handler's Lua code is
about to run (i.e., the request body will be read during the content phase).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102227Z" changeid="xf">
        <seg>类似的，, 如果只设置了 [[#content_by_lua|content_by_lua]] , 请求体将在进行内容处理Lua 代码将要运行时被读取 (即, 请求体将在content阶段被读取).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;code&gt;v0.8.3&lt;/code&gt; this function returns &lt;code&gt;1&lt;/code&gt; on success, or returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040232Z" changeid="xf">
        <seg>从&lt;code&gt;v0.8.3&lt;/code&gt; 版本开始这个函数成功时返回 &lt;code&gt;1&lt;/code&gt; , 出错时 returns &lt;code&gt;nil&lt;/code&gt; 和 描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the &lt;code&gt;0.6.9&lt;/code&gt; release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the &lt;code&gt;raw&lt;/code&gt; argument is set to &lt;code&gt;true&lt;/code&gt; (default to &lt;code&gt;false&lt;/code&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015842Z" changeid="xf">
        <seg>从&lt;code&gt;0.6.9&lt;/code&gt;版本开始, 默认Lua table中的所有头名称将被转换成纯小写，除非 &lt;code&gt;raw&lt;/code&gt; 参数被设为 &lt;code&gt;true&lt;/code&gt; (默认为&lt;code&gt;false&lt;/code&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021224Z" changeid="xf">
        <seg>所以</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041512Z" changeid="xf">
        <seg>所以如果在循环中调用它们时要小心，请自行缓冲数据以减少调用次数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So even &lt;code&gt;1&lt;/code&gt; byte buffer size should still work everywhere but the performance could be terrible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103316Z" changeid="xf">
        <seg>所以即使是 &lt;code&gt;1&lt;/code&gt; 字节的缓冲区大小也可以工作，只是性能会很糟糕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if you do ''not'' want to re-initialize the shm storage in your &lt;code&gt;init_by_lua&lt;/code&gt; code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your &lt;code&gt;init_by_lua&lt;/code&gt; code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063904Z" changeid="xf">
        <seg>所以如果在这种情况下如果你不希望在&lt;code&gt;init_by_lua&lt;/code&gt;代码中重新对共享存储进行初始化，你只需要在共享存储中设置一个标记，并在 &lt;code&gt;init_by_lua&lt;/code&gt; 代码中检查这个标记.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the following will work as expected:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074545Z" changeid="xf">
        <seg>以下代码会得到预期的结果:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032721Z" changeid="xf">
        <seg>所以如果在Lua代码中需要多次读取一个Nginx变量, 请将Nginx变量的值赋给你自己的Lua变量, 例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some special nginx variables like &lt;code&gt;$args&lt;/code&gt; and &lt;code&gt;$limit_rate&lt;/code&gt; can be assigned a value,
some are not, like &lt;code&gt;$arg_PARAMETER&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032243Z" changeid="xf">
        <seg>有些nginx变量，如 &lt;code&gt;$args&lt;/code&gt; 和 &lt;code&gt;$limit_rate&lt;/code&gt; 可以被设值,
有些则不行, 如 &lt;code&gt;$arg_PARAMETER&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifies the &quot;match limit&quot; used by the PCRE library when executing the [[#ngx.re.match|ngx.re API]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060714Z" changeid="xf">
        <seg>指定在执行[[#ngx.re.matchngx.re API]]时PCRE库所使用的 &quot;match limit&quot; 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifies the buffer size used by cosocket reading operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103203Z" changeid="xf">
        <seg>指定cosocket读操作的缓冲区大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifies the maximum number of entries allowed in the worker process level compiled regex cache.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T054234Z" changeid="xf">
        <seg>设置在worker进程级别允许缓存的编译后正则表达式的条数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104135Z" changeid="xf">
        <seg>指定与每个远程服务器(由主机-端口号或unix domain socket文件路径标识)所关联的每个cosocket连接池的大小（连接数）上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings like &lt;code&gt;&quot;GET&quot;&lt;/code&gt; and &lt;code&gt;&quot;POST&quot;&lt;/code&gt; are returned instead of numerical [[#HTTP method constants|method constants]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095438Z" changeid="xf">
        <seg>返回值是如&lt;code&gt;&quot;GET&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;POST&quot;&lt;/code&gt; 这样的字符串而不是数字 [[#HTTP method constants|方法常量]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subrequests are completely different from HTTP 301/302 redirection (via [[#ngx.redirect|ngx.redirect]]) and internal redirection (via [[#ngx.exec|ngx.exec]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040817Z" changeid="xf">
        <seg>子请求与 HTTP 301/302 重定向(通过 [[#ngx.redirect|ngx.redirect]]) 和 内部重定向 (通过[[#ngx.exec|ngx.exec]]) 是完全不同的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by [[#access_by_lua|access_by_lua]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094042Z" changeid="xf">
        <seg>如果客户端的IP地址在黑名单中，则请求将在[[#access_by_luaaccess_by_lua]]进行MySQL查询进行更复杂的认证之前被拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, nginx variables cannot be created on-the-fly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032205Z" changeid="xf">
        <seg>也就是说，nginx变量不能随需创建.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the &lt;code&gt;ngx.ctx.foo&lt;/code&gt; entry persists across the rewrite, access, and content phases of a request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034946Z" changeid="xf">
        <seg>这说明 &lt;code&gt;ngx.ctx.foo&lt;/code&gt; 在请求的rewrite, access, 和 content各个阶段都有效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, they will take Lua boolean values &lt;code&gt;true&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102847Z" changeid="xf">
        <seg>即他们的值为 boolean 值&lt;code&gt;true&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, when the body filter sees a chunk containing the word &quot;hello&quot;, then it will set the &quot;eof&quot; flag to true immediately, resulting in truncated but still valid responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T095334Z" changeid="xf">
        <seg>当过滤器看到包含 &quot;hello&quot; 的数据块, 就立即将 &quot;eof&quot; 标记设为true, 产生被截断但仍然是有效的响应内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;&lt;size&gt;&lt;/code&gt; argument accepts size units such as &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102457Z" changeid="xf">
        <seg>&lt;code&gt;&lt;size&gt;&lt;/code&gt; 参数支持象 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt;这样的大小单位:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;&lt;time&gt;&lt;/code&gt; argument can be an integer, with an optional time unit, like &lt;code&gt;s&lt;/code&gt; (second), &lt;code&gt;ms&lt;/code&gt; (millisecond), &lt;code&gt;m&lt;/code&gt; (minute).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102710Z" changeid="xf">
        <seg>&lt;code&gt;&lt;time&gt;&lt;/code&gt; 参数可以是整数，时间单位可选, 如&lt;code&gt;s&lt;/code&gt; (秒), &lt;code&gt;ms&lt;/code&gt; (毫秒), &lt;code&gt;m&lt;/code&gt; (分钟).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;__index&lt;/code&gt; metamethod will not be added when the &lt;code&gt;raw&lt;/code&gt; argument is set to &lt;code&gt;true&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020715Z" changeid="xf">
        <seg>如果&lt;code&gt;raw&lt;/code&gt;参数被设为&lt;code&gt;true&lt;/code&gt;，则不会添加 &lt;code&gt;__index&lt;/code&gt; 元方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;args&lt;/code&gt; argument can be either a Lua string, as in</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102326Z" changeid="xf">
        <seg> &lt;code&gt;args&lt;/code&gt; 参数可以是 Lua 字符串, 如</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;args&lt;/code&gt; option can also take plain query strings:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053601Z" changeid="xf">
        <seg>&lt;code&gt;args&lt;/code&gt; 选项也可以直接使用 query string字符串:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;args&lt;/code&gt; option can specify extra URI arguments, for instance,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053230Z" changeid="xf">
        <seg> &lt;code&gt;args&lt;/code&gt; 选项可以用来指定其它的 URI 参数, 例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;args&lt;/code&gt;, &lt;code&gt;vars&lt;/code&gt;, or &lt;code&gt;copy_all_vars&lt;/code&gt; options are generally preferable instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053857Z" changeid="xf">
        <seg>更推荐使用 &lt;code&gt;args&lt;/code&gt;, &lt;code&gt;vars&lt;/code&gt;, 或 &lt;code&gt;copy_all_vars&lt;/code&gt; 这些选项.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;auto_clean&lt;/code&gt; is default to &lt;code&gt;false&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024230Z" changeid="xf">
        <seg> &lt;code&gt;auto_clean&lt;/code&gt; 默认为 &lt;code&gt;false&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;copy_all_vars&lt;/code&gt; option provides a copy of the parent request's Nginx variables to subrequests when such subrequests are issued.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T054130Z" changeid="xf">
        <seg> &lt;code&gt;copy_all_vars&lt;/code&gt; 在发起子请求时为子请求提供父请求Nginx变量的拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;ctx&lt;/code&gt; option can be used to specify a custom Lua table to serve as the [[#ngx.ctx|ngx.ctx]] table for the subrequest.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T081752Z" changeid="xf">
        <seg> &lt;code&gt;ctx&lt;/code&gt; 选项用来为子请求指定自定义的 [[#ngx.ctx|ngx.ctx]] table 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;header_value&lt;/code&gt; can take an array list of values,
for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021105Z" changeid="xf">
        <seg> &lt;code&gt;header_value&lt;/code&gt; 可以接受一个数组存放多个值,
例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;jump&lt;/code&gt; can only be set to &lt;code&gt;true&lt;/code&gt; in [[#rewrite_by_lua|rewrite_by_lua]] and [[#rewrite_by_lua_file|rewrite_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102032Z" changeid="xf">
        <seg> &lt;code&gt;jump&lt;/code&gt; 只能在[[#rewrite_by_luarewrite_by_lua]] 和 [[#rewrite_by_lua_filerewrite_by_lua_file]]中被设为 &lt;code&gt;true&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;log_level&lt;/code&gt; argument can take constants like &lt;code&gt;ngx.ERR&lt;/code&gt; and &lt;code&gt;ngx.WARN&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041720Z" changeid="xf">
        <seg> &lt;code&gt;log_level&lt;/code&gt; 参数可以是象&lt;code&gt;ngx.ERR&lt;/code&gt; &lt;code&gt;ngx.WARN&lt;/code&gt;这样的常量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;method&lt;/code&gt; option is &lt;code&gt;ngx.HTTP_GET&lt;/code&gt; by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053159Z" changeid="xf">
        <seg>默认的 &lt;code&gt;method&lt;/code&gt; 选项是 &lt;code&gt;ngx.HTTP_GET&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;ngx.DECLINED&lt;/code&gt; constant was first introduced in the &lt;code&gt;v0.5.0rc19&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033133Z" changeid="xf">
        <seg>&lt;code&gt;ngx.DECLINED&lt;/code&gt; 常量在 &lt;code&gt;v0.5.0rc19&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;ngx.null&lt;/code&gt; constant is a &lt;code&gt;NULL&lt;/code&gt; light userdata usually used to represent nil values in Lua tables etc and is similar to the [http://www.kyne.com.au/~mark/software/lua-cjson.php lua-cjson] library's &lt;code&gt;cjson.null&lt;/code&gt; constant.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033403Z" changeid="xf">
        <seg>&lt;code&gt;ngx.null&lt;/code&gt; 常量是一个 &lt;code&gt;NULL&lt;/code&gt; 轻量 userdata，通常用于表示Lua table等中的nil值，类似于 [http://www.kyne.com.au/~mark/software/lua-cjson.php lua-cjson] 库的&lt;code&gt;cjson.null&lt;/code&gt; 常量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;ngx.null&lt;/code&gt; constant will yield the &lt;code&gt;&quot;null&quot;&lt;/code&gt; string output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041220Z" changeid="xf">
        <seg> &lt;code&gt;ngx.null&lt;/code&gt; 常量输出为 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;rewrite_by_lua&lt;/code&gt; code will always run at the end of the &lt;code&gt;rewrite&lt;/code&gt; request-processing phase unless [[#rewrite_by_lua_no_postpone|rewrite_by_lua_no_postpone]] is turned on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080621Z" changeid="xf">
        <seg>除非[[#rewrite_by_lua_no_postpone|rewrite_by_lua_no_postpone]]被设成on， &lt;code&gt;rewrite_by_lua&lt;/code&gt;总是在&lt;code&gt;rewrite&lt;/code&gt;请求处理阶段的最后执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;rewrite_by_lua_file&lt;/code&gt; code will always run at the end of the &lt;code&gt;rewrite&lt;/code&gt; request-processing phase unless [[#rewrite_by_lua_no_postpone|rewrite_by_lua_no_postpone]] is turned on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080852Z" changeid="xf">
        <seg>除非[[#rewrite_by_lua_no_postpone|rewrite_by_lua_no_postpone]]被设成on， &lt;code&gt;rewrite_by_lua_file&lt;/code&gt;总是在&lt;code&gt;rewrite&lt;/code&gt;请求处理阶段的最后执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;share_all_vars&lt;/code&gt; option controls whether to share nginx variables among the current request and its subrequests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053706Z" changeid="xf">
        <seg>&lt;code&gt;share_all_vars&lt;/code&gt;选项控制是否将本请求中的Nginx变量值与子请求共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;uri&lt;/code&gt; argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095756Z" changeid="xf">
        <seg> &lt;code&gt;uri&lt;/code&gt; 参数必须是一个Lua string，长度必须大于0，不然会抛出Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The API is exposed to Lua in the form of two standard packages &lt;code&gt;ngx&lt;/code&gt; and &lt;code&gt;ndk&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023441Z" changeid="xf">
        <seg>这套API是以两个标准包 &lt;code&gt;ngx&lt;/code&gt; and &lt;code&gt;ndk&lt;/code&gt; 的形式暴露给Lua的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua code cache can be temporarily disabled during development by 
switching [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; in &lt;code&gt;nginx.conf&lt;/code&gt; to avoid reloading Nginx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073832Z" changeid="xf">
        <seg>在开发阶段，Lua代码缓存可以通过在&lt;code&gt;nginx.conf&lt;/code&gt;中设置 [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; 来避免重新加载Nginx配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua code cache can be temporarily disabled during development by switching [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; in &lt;code&gt;nginx.conf&lt;/code&gt; to avoid reloading Nginx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080811Z" changeid="xf">
        <seg>在开发阶段，Lua代码缓存可以通过在&lt;code&gt;nginx.conf&lt;/code&gt;中设置 [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; 来避免重新加载Nginx配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua code cache can be temporarily disabled during development by switching [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; in &lt;code&gt;nginx.conf&lt;/code&gt; to avoid repeatedly reloading Nginx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094420Z" changeid="xf">
        <seg>在开发阶段，Lua代码缓存可以通过在&lt;code&gt;nginx.conf&lt;/code&gt;中设置 [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; 来避免重新加载Nginx配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding [[#ngx.arg|ngx.arg]][1] with a Lua string or a Lua table of strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094720Z" changeid="xf">
        <seg>Lua 代码可以修改 [[#ngx.arg|ngx.arg]][1] 将自己修改后的输入数据块作为Lua string或装有string的Lua table送到下游的Nginx输出体过滤器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua code may make [[#Nginx API for Lua|API calls]] and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074051Z" changeid="xf">
        <seg>Lua代码可以调用 [[#Nginx API for Lua|API]] 并以一个拥有独立的全局环境的新生成的coroutine（即一个sandbox）的形式运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua files referenced in [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#access_by_lua_file|access_by_lua_file]],
and [[#rewrite_by_lua_file|rewrite_by_lua_file]] will not be cached
and the Lua &lt;code&gt;package.loaded&lt;/code&gt; table will be cleared
at the entry point of every request (such that Lua modules
will not be cached either).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T042421Z" changeid="xf">
        <seg>在[[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#access_by_lua_file|access_by_lua_file]],
和 [[#rewrite_by_lua_file|rewrite_by_lua_file]]中引用的Lua文件不会被缓存， Lua的 &lt;code&gt;package.loaded&lt;/code&gt; table会在每个请求的入口被清空 (所以 Lua 模块也不会被缓存).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua interpreter or LuaJIT instance is shared across all the requests in a single nginx worker process but request contexts are segregated using lightweight Lua coroutines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041534Z" changeid="xf">
        <seg>在单个nginx worker进程中Lua解释器或LuaJIT实例为所有请求所共享，但是请求上下文使用了轻量的Lua coroutine进行了隔离。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023405Z" changeid="xf">
        <seg>以下的 Nginx Lua API 只能由运行在这些配置命令上下文中的Lua代码进行调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned &lt;code&gt;on&lt;/code&gt; or the [[#ngx.req.read_body|ngx.req.read_body]] function should be called within the Lua code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101748Z" changeid="xf">
        <seg>Nginx内核默认不读取请求体，如果需要请求体数据, 就需要将本命令置为 &lt;code&gt;on&lt;/code&gt; ，或者在Lua代码中调用 [[#ngx.req.read_body|ngx.req.read_body]] 函数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The [[#ngx.location.capture|ngx.location.capture]] function is just a special form
of this function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083519Z" changeid="xf">
        <seg> [[#ngx.location.capture|ngx.location.capture]] 函数只是本函数的特殊形式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to require these packages was introduced in the &lt;code&gt;v0.2.1rc19&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023954Z" changeid="xf">
        <seg>require 这两个包的能力始于 &lt;code&gt;v0.2.1rc19&lt;/code&gt; 版本.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; can make [[#Nginx API for Lua|API calls]] and can retrieve input arguments from the &lt;code&gt;ngx.arg&lt;/code&gt; table (index starts from &lt;code&gt;1&lt;/code&gt; and increases sequentially).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072846Z" changeid="xf">
        <seg>&lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt;中的代码可以调用 [[#Nginx API for Lua|API]]并能从 &lt;code&gt;ngx.arg&lt;/code&gt; table中获取输入参数 (下标从 &lt;code&gt;1&lt;/code&gt;开始递增).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The cpath string is in standard Lua cpath form, and &lt;code&gt;;;&lt;/code&gt;
can be used to stand for the original cpath.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062407Z" changeid="xf">
        <seg>cpath字符串使用标准的Lua cpath格式， &lt;code&gt;;;&lt;/code&gt;
可用来表示原始的cpath.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data chunk and &quot;eof&quot; flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032000Z" changeid="xf">
        <seg>发往下游Nginx输出过滤器的数据块和 &quot;eof&quot; 标记可以通过对表中相应元素的直接赋值来进行修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the &lt;code&gt;o&lt;/code&gt; option was not specified) and there will be one, and only one, warning in the &lt;code&gt;error.log&lt;/code&gt; file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T055812Z" changeid="xf">
        <seg>默认的条数是1024，当达到这个上限时，新的正则表达式将不被缓存 (就象没有设置 &lt;code&gt;o&lt;/code&gt; 一样) ，同时在 &lt;code&gt;error.log&lt;/code&gt; 文件中会记录一条且仅记录一条warning:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default setting is &lt;code&gt;60s&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102733Z" changeid="xf">
        <seg>默认值是 &lt;code&gt;60s&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default time unit is &lt;code&gt;s&lt;/code&gt;, i.e., &quot;second&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102724Z" changeid="xf">
        <seg>默认的时间单位是 &lt;code&gt;s&lt;/code&gt;, 即, &quot;秒&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example emulates the &lt;code&gt;$request_time&lt;/code&gt; variable value (provided by [[HttpLogModule]]) in pure Lua:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094330Z" changeid="xf">
        <seg>下面的例子用纯Lua代码模拟 &lt;code&gt;$request_time&lt;/code&gt; 变量的值 (由 [[HttpLogModule]] 提供) in pure Lua:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format for the Lua table passed as the &lt;code&gt;args&lt;/code&gt; argument is identical to the format used in the [[#ngx.encode_args|ngx.encode_args]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053541Z" changeid="xf">
        <seg> &lt;code&gt;args&lt;/code&gt; 参数Lua table的格式与 [[#ngx.encode_args|ngx.encode_args]] 所使用的table格式一样.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The header names are matched case-insensitively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091046Z" changeid="xf">
        <seg>头名称的匹配是大小写无关的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The input data chunk is passed via [[#ngx.arg|ngx.arg]][1] (as a Lua string value) and the &quot;eof&quot; flag indicating the end of the response body data stream is passed via [[#ngx.arg|ngx.arg]][2] (as a Lua boolean value).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094231Z" changeid="xf">
        <seg>输入参数块由 [[#ngx.arg|ngx.arg]][1] (作为Lua string)传入， 标记标识响应体数据流结束的&quot;eof&quot;由 [[#ngx.arg|ngx.arg]][2] (作为Lua boolean)传入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The limit can be manually modified if required by editing the definition of the &lt;code&gt;NGX_HTTP_MAX_SUBREQUESTS&lt;/code&gt; macro in the &lt;code&gt;nginx/src/http/ngx_http_request.h&lt;/code&gt; file in the Nginx source tree.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082635Z" changeid="xf">
        <seg>可以手工修改Nginx代码树中的&lt;code&gt;nginx/src/http/ngx_http_request.h&lt;/code&gt;文件中的 &lt;code&gt;NGX_HTTP_MAX_SUBREQUESTS&lt;/code&gt; 宏定义来修改这个上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ngx_lua module does not currently support the &lt;code&gt;stat&lt;/code&gt; mode available with the
Apache &lt;code&gt;mod_lua&lt;/code&gt; module but this is planned for implementation in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T043051Z" changeid="xf">
        <seg>ngx_lua 模块目前不支持Apache &lt;code&gt;mod_lua&lt;/code&gt; module 中有的 &lt;code&gt;stat&lt;/code&gt; 模式，但我们计划在将来实现它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;code&gt;status&lt;/code&gt; parameter specifies whether
&lt;code&gt;301&lt;/code&gt; or &lt;code&gt;302&lt;/code&gt; to be used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034339Z" changeid="xf">
        <seg>可选的 &lt;code&gt;status&lt;/code&gt; 参数指定使用
&lt;code&gt;301&lt;/code&gt; 还是 &lt;code&gt;302&lt;/code&gt; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional boolean &lt;code&gt;jump&lt;/code&gt; argument can trigger location rematch (or location jump) as [[HttpRewriteModule]]'s [[HttpRewriteModule#rewrite|rewrite]] directive, that is, when &lt;code&gt;jump&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (default to &lt;code&gt;false&lt;/code&gt;), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later &lt;code&gt;post-rewrite&lt;/code&gt; phase and jumping to the new location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101743Z" changeid="xf">
        <seg>可选的boolean参数 &lt;code&gt;jump&lt;/code&gt; 可以象 [[HttpRewriteModule]] 的 [[HttpRewriteModule#rewriterewrite]] 命令一样触发location重匹配 (或称location跳转) , 如果 &lt;code&gt;jump&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; (默认为&lt;code&gt;false&lt;/code&gt;), 这个函数将不会返回，而是告诉 Nginx 在后面的&lt;code&gt;post-rewrite&lt;/code&gt;阶段尝试重新对新的URI值进行location匹配并中转到新的location.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional second &lt;code&gt;args&lt;/code&gt; can be used to specify extra URI query arguments, for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032417Z" changeid="xf">
        <seg>可选的第二个参数 &lt;code&gt;args&lt;/code&gt; 可用于指定额外的 URI 请求参数, 例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output data stream can be aborted immediately by running the following Lua statement:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094434Z" changeid="xf">
        <seg>可以用过执行下面的Lua语句来立即终止响应数据流:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The packages can be introduced into external Lua modules like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023650Z" changeid="xf">
        <seg>它们可以象这样被引入到外部 Lua 模块中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The path string is in standard Lua path form, and &lt;code&gt;;;&lt;/code&gt;
can be used to stand for the original search paths.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061902Z" changeid="xf">
        <seg>路径字符串使用标准的Lua路径格式，, &lt;code&gt;;;&lt;/code&gt;可用于表示原始的查找路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The regular expressions used in [[#ngx.re.match|ngx.re.match]], [[#ngx.re.gmatch|ngx.re.gmatch]], [[#ngx.re.sub|ngx.re.sub]], and [[#ngx.re.gsub|ngx.re.gsub]] will be cached within this cache if the regex option &lt;code&gt;o&lt;/code&gt; (i.e., compile-once flag) is specified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T055649Z" changeid="xf">
        <seg>[[#ngx.re.match|ngx.re.match]], [[#ngx.re.gmatch|ngx.re.gmatch]], [[#ngx.re.sub|ngx.re.sub]], and [[#ngx.re.gsub|ngx.re.gsub]]中使用的正则表达式，如果设置了 &lt;code&gt;o&lt;/code&gt; (即“仅编译一次”）模式，将在这个缓存中进行缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The request body data read using this function can be retrieved later via [[#ngx.req.get_body_data|ngx.req.get_body_data]] or, alternatively, the temporary file name for the body data cached to disk using [[#ngx.req.get_body_file|ngx.req.get_body_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022257Z" changeid="xf">
        <seg>使用此函数读取的请求体数据也可以延后，通过 [[#ngx.req.get_body_data|ngx.req.get_body_data]] 读取，或使用缓存的磁盘的临时文件名[[#ngx.req.get_body_filengx.req.get_body_file]]进行读取.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is exactly the same as the previous example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032510Z" changeid="xf">
        <seg>结果与上一个例子完全一样.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned file is read only and is usually cleaned up by Nginx's memory pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023710Z" changeid="xf">
        <seg>返回的文件是只读的，通常由Nginx的内存池来清理.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The right way of doing this is as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074753Z" changeid="xf">
        <seg>正确的作法是这样的:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same applies to assigning an empty table:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T090339Z" changeid="xf">
        <seg>设置成一个空table的效果是一样的:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The socket object returned by this method is usually used to read the current request's body in a streaming fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031946Z" changeid="xf">
        <seg>此方法返回的socket对象通常用来以流的方式读取当前请求的体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The total latency is the longest latency of the individual subrequests rather than the sum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083402Z" changeid="xf">
        <seg>总的延迟是各个子请求延时的最大值，而不是它们的和.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The usage of this function is often like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030641Z" changeid="xf">
        <seg>这个函数的用法通常是这样的:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;GET /orig&lt;/code&gt; will give</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035529Z" changeid="xf">
        <seg>&lt;code&gt;GET /orig&lt;/code&gt; 的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;GET /t&lt;/code&gt; will just return the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T095045Z" changeid="xf">
        <seg>请求 &lt;code&gt;GET /t&lt;/code&gt; 将产生以下输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;GET /test&lt;/code&gt; will yield the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034603Z" changeid="xf">
        <seg>&lt;code&gt;GET /test&lt;/code&gt; 的输出如下</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;GET /test?foo=bar&amp;bar=baz&amp;bar=blah&lt;/code&gt; will yield the response body</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102627Z" changeid="xf">
        <seg>&lt;code&gt;GET /test?foo=bar&amp;bar=baz&amp;bar=blah&lt;/code&gt; 的结果是响应体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;res.header[&quot;Set-Cookie&quot;]&lt;/code&gt; will be evaluated to the table value
&lt;code&gt;{&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;}&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041130Z" changeid="xf">
        <seg>那么 &lt;code&gt;res.header[&quot;Set-Cookie&quot;]&lt;/code&gt; 的值是table
&lt;code&gt;{&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;}&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a hard coded &lt;code&gt;2048&lt;/code&gt; byte limitation on error message lengths in the Nginx core.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034124Z" changeid="xf">
        <seg>Nginx 内核中硬编码限制了错误信息长度为 &lt;code&gt;2048&lt;/code&gt; 字节.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082432Z" changeid="xf">
        <seg>对每个主请求，对同时并发的子请求的数量有一个硬编码的上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
variables are set after the sharing or copying of variables has been
evaluated, and provides a more efficient method of passing specific
values to a subrequest over encoding them as URL arguments and 
unescaping them in the Nginx config file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T080709Z" changeid="xf">
        <seg>这些变量的设置发生在共享或拷贝的变量被求值以后， 这样提供了一种比将参数编码成URL参数并在Nginx配置文件中对它们进行反转义更高效的传递参数的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are usually used by the [[#ngx.log|ngx.log]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033708Z" changeid="xf">
        <seg>这些常量通常被用在 [[#ngx.log|ngx.log]] 方法中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are usually used in [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] method calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033519Z" changeid="xf">
        <seg>这些常量多用于 [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] 调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023617Z" changeid="xf">
        <seg>这两个包在ngx_lua模块的默认全局作用域中， 在ngx_lua命令里总是可以访问到.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API was first introduced in ngx_lua v0.3.1rc6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040807Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc6&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also applies to [[#access_by_lua|access_by_lua]] and [[#access_by_lua_file|access_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102318Z" changeid="xf">
        <seg>这也适用于 [[#access_by_lua|access_by_lua]] 和 [[#access_by_lua_file|access_by_lua_file]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This argument can be set to zero to remove the limit and to process all request arguments received:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103315Z" changeid="xf">
        <seg>这个参数设成0表示无上限，会处理接收到的所有的请求参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This argument can be set to zero to remove the limit and to process all request headers received:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015711Z" changeid="xf">
        <seg>这个参数设成0表示无上限，会处理接收到的所有的请求头：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103245Z" changeid="xf">
        <seg>这个缓冲区不需要大于能够一次装下所有的东西，因为 cosocket 支持 100% 无缓冲读取和解析.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This buffering mechanism is mainly used for HTTP 1.0 keep-alive which replies on a proper &lt;code&gt;Content-Length&lt;/code&gt; response header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020002Z" changeid="xf">
        <seg>这个缓冲机制主要用于HTTP 1.0 keep-alive，基于正确的 &lt;code&gt;Content-Length&lt;/code&gt; 响应头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be particularly useful for streaming output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041327Z" changeid="xf">
        <seg>这在做流式输出时特别有用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constant was first introduced in the &lt;code&gt;v0.5.0rc5&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033120Z" changeid="xf">
        <seg>此常量在 &lt;code&gt;v0.5.0rc5&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This depends on</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022301Z" changeid="xf">
        <seg>这取决于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive can be freely mixed with all directives of the [[HttpRewriteModule]], [[HttpSetMiscModule]], and [[HttpArrayVarModule]] modules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073130Z" changeid="xf">
        <seg>这条命令可以随意与 [[HttpRewriteModule]], [[HttpSetMiscModule]], 和[[HttpArrayVarModule]] 模块中的命令混合使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015637Z" changeid="xf">
        <seg>本命令可以用来打开/关闭TCP或UDP cosocket出错时的错误日志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104426Z" changeid="xf">
        <seg>本命令控制cosocket内置连接池中连接的默认最大空闲时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:connect|connect]] method and can be overridden by the [[#tcpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102621Z" changeid="xf">
        <seg>本命令控制 TCP/unix-domain socket 对象[[#tcpsock:connect|connect]] 方法中使用的默认超时时间， 可以用 [[#tcpsock:settimeout|settimeout]] 方法进行修改.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:receive|receive]] method and iterator functions returned by the [[#tcpsock:receiveuntil|receiveuntil]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103048Z" changeid="xf">
        <seg>本命令控制 TCP/unix-domain socket 对象[[#tcpsock:receive|receive]] 方法中使用的默认超时时间， 可以用 [[#tcpsock:settimeout|settimeout]] 方法进行修改.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive controls whether to check for premature client connection abortion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021207Z" changeid="xf">
        <seg>本命令控制是否检测客户端连接过早中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072341Z" changeid="xf">
        <seg>这条命令是被设计用来执行短的，能很快结束的代码块，在它执行时Nginx事件循环是被阻塞的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive is turned &lt;code&gt;on&lt;/code&gt; by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020446Z" changeid="xf">
        <seg>本命令默认值为 &lt;code&gt;on&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073335Z" changeid="xf">
        <seg>这条命令需要 [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] 模块.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.2.1rc20&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094634Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.2.1rc20&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.3.1rc22&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102526Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc22&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.0rc19&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020454Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc19&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.0rc1&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102745Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc1&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020716Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.0rc31&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101428Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc31&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091605Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.13&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015801Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.13&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.5&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064451Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.5&lt;/code&gt; 版本中引入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.7.4&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022456Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.7.4&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.8.0&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022653Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.8.0&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.8.5&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061011Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.8.5&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes ngx_lua [https://github.com/chaoslawful/lua-nginx-module/tags v0.8.5] released on 18 July 2013.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035049Z" changeid="xf">
        <seg>本文对应的是 ngx_lua [https://github.com/chaoslawful/lua-nginx-module/tags v0.8.5]版本，发布于2013年7月8日.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This does not replace the current access logs, but runs after.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091507Z" changeid="xf">
        <seg>它不会覆盖当前的访问日志，而是在记录访问日志之后运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function can be used with [[#ngx.req.append_body|ngx.req.append_body]], [[#ngx.req.finish_body|ngx.req.finish_body]], and [[#ngx.req.socket|ngx.req.socket]] to implement efficient input filters in pure Lua (in the context of [[#rewrite_by_lua|rewrite_by_lua]]* or [[#access_by_lua|access_by_lua]]*), which can be used with other Nginx content handler or upstream modules like [[HttpProxyModule]] and [[HttpFastcgiModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030858Z" changeid="xf">
        <seg>此函数与 [[#ngx.req.append_body|ngx.req.append_body]], [[#ngx.req.finish_body|ngx.req.finish_body]], 和 [[#ngx.req.socket|ngx.req.socket]]一起使用，可以实现高效的纯Lua输入过滤器 (在[[#rewrite_by_lua|rewrite_by_lua]]* 或 [[#access_by_lua|access_by_lua]]* 中), 过滤器可与其它 Nginx 内容处理器或上游模块 [[HttpProxyModule]] 和 [[HttpFastcgiModule]]一起使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function can be used with [[#ngx.req.init_body|ngx.req.init_body]], [[#ngx.req.append_body|ngx.req.append_body]], and [[#ngx.req.socket|ngx.req.socket]] to implement efficient input filters in pure Lua (in the context of [[#rewrite_by_lua|rewrite_by_lua]]* or [[#access_by_lua|access_by_lua]]*), which can be used with other Nginx content handler or upstream modules like [[HttpProxyModule]] and [[HttpFastcgiModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031219Z" changeid="xf">
        <seg>此函数与 [[#ngx.req.init_body|ngx.req.iit_body]], [[#ngx.req.append_body|ngx.req.append_body]], 和 [[#ngx.req.socket|ngx.req.socket]]一起使用，可以实现高效的纯Lua输入过滤器 (在[[#rewrite_by_lua|rewrite_by_lua]]* 或 [[#access_by_lua|access_by_lua]]* 中), 过滤器可与其它 Nginx 内容处理器或上游模块 [[HttpProxyModule]] 和 [[HttpFastcgiModule]]一起使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function can be used with [[#ngx.req.init_body|ngx.req.init_body]], [[#ngx.req.finish_body|ngx.req.finish_body]], and [[#ngx.req.socket|ngx.req.socket]] to implement efficient input filters in pure Lua (in the context of [[#rewrite_by_lua|rewrite_by_lua]]* or [[#access_by_lua|access_by_lua]]*), which can be used with other Nginx content handler or upstream modules like [[HttpProxyModule]] and [[HttpFastcgiModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031031Z" changeid="xf">
        <seg>此函数与 [[#ngx.req.init_body|ngx.req.iit_body]], [[#ngx.req.finish_body|ngx.req.finish_body]], 和 [[#ngx.req.socket|ngx.req.socket]]一起使用，可以实现高效的纯Lua输入过滤器 (在[[#rewrite_by_lua|rewrite_by_lua]]* 或 [[#access_by_lua|access_by_lua]]* 中), 过滤器可与其它 Nginx 内容处理器或上游模块 [[HttpProxyModule]] 和 [[HttpFastcgiModule]]一起使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function is an asynchronous call and returns immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022931Z" changeid="xf">
        <seg>本函数是异步调用，会立即返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function issues several parallel subrequests specified by the input table and returns their results in the same order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082915Z" changeid="xf">
        <seg>这个函数发起在输入table中指定的若干并行子请求，并以指定的顺序返回其结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function returns &lt;code&gt;nil&lt;/code&gt; if
# the request body has not been read,
# the request body has been read into disk temporary files,
# or the request body has zero size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023149Z" changeid="xf">
        <seg>在以下情况下此函数返回 &lt;code&gt;nil&lt;/code&gt; 
# 请求体尚未被读取,
# 请求体已经被读进磁盘临时文件,
# 请求体长度为0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.3.1rc17&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022550Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc17&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.3.1rc18&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024035Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc18&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.5.0rc1&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032239Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc1&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.5.11&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030910Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.11&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.7.7&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094353Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.7.7&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function will not return until all the subrequests terminate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082941Z" changeid="xf">
        <seg>这个函数只有在所有子请求都结束后才会返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function will return but with no returned values when the &lt;code&gt;jump&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt; or absent altogether.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101914Z" changeid="xf">
        <seg>&lt;code&gt;jump&lt;/code&gt;参数为&lt;code&gt;false&lt;/code&gt;或不提供时，这个函数会返回，但没有返回值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This however carries some risks and is not ordinarily recommended.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074328Z" changeid="xf">
        <seg>但这种做法会带来风险，通常并不推荐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interface was first introduced in the &lt;code&gt;v0.3.1rc13&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102518Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc13&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interface was first introduced in the &lt;code&gt;v0.3.1rc14&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102234Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc14&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041241Z" changeid="xf">
        <seg>这是一个异常调用，立即返回 ，不需要等待所有数据被写进系统发送缓冲区.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because they have two separate versions of &lt;code&gt;ngx.ctx.blah&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035434Z" changeid="xf">
        <seg>这是因为它们是两个不同的版本.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is functionally identical to the previous examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053619Z" changeid="xf">
        <seg>这段代码与前面的代码在功能上完全一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not recommended however).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023246Z" changeid="xf">
        <seg>虽然我们并不推荐这样做).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful in the context of [[#header_filter_by_lua|header_filter_by_lua]] and [[#header_filter_by_lua_file|header_filter_by_lua_file]], for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091141Z" changeid="xf">
        <seg>这在 [[#header_filter_by_lua|header_filter_by_lua]] 和 [[#header_filter_by_lua_file|header_filter_by_lua_file]]的上下文中特别有用, 例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This limit can be manually modified by editing the &lt;code&gt;NGX_MAX_ERROR_STR&lt;/code&gt; macro definition in the &lt;code&gt;src/core/ngx_log.h&lt;/code&gt; file in the Nginx source tree.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034356Z" changeid="xf">
        <seg>可以手工修改Nginx代码树中的&lt;code&gt;src/core/ngx_log.h&lt;/code&gt;文件中的 &lt;code&gt;NGX_MAX_ERROR_STR&lt;/code&gt; 宏定义来修改这个上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This limit includes trailing newlines and leading time stamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034151Z" changeid="xf">
        <seg>这个限制包括了最后的换行和头部的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method ''must'' be called before [[#ngx.send_headers|ngx.send_headers]] or explicit response body
outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032715Z" changeid="xf">
        <seg>这个方法 ''必须'' 在 [[#ngx.send_headers|ngx.send_headers]] 或使用[[#ngx.printngx.print]] or [[#ngx.sayngx.say]]进行显式的响应体输出之前调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method ''must'' be called before [[#ngx.send_headers|ngx.send_headers]] or explicit response body outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034739Z" changeid="xf">
        <seg>这个方法 ''必须'' 在 [[#ngx.send_headers|ngx.send_headers]] 或使用[[#ngx.printngx.print]] or [[#ngx.sayngx.say]]进行显式的响应体输出之前调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method call terminates the current request's processing and never returns.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040107Z" changeid="xf">
        <seg>这个方法将终止当前请求的处理，永不返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is similar to the [[HttpEchoModule#echo_exec|echo_exec]] directive of the [[HttpEchoModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034223Z" changeid="xf">
        <seg>此方法类似于 [[HttpEchoModule]] 的 [[HttpEchoModule#echo_exec|echo_exec]] 命令.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is very much like the [[HttpRewriteModule#rewrite|rewrite]] directive with the &lt;code&gt;redirect&lt;/code&gt; modifier in the standard
[[HttpRewriteModule]], for example, this &lt;code&gt;nginx.conf&lt;/code&gt; snippet</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034849Z" changeid="xf">
        <seg>此方法很象标准[[HttpRewriteModule]]中带有&lt;code&gt;redirect&lt;/code&gt;选项的 [[HttpRewriteModule#rewrite|rewrite]] 命令, 例如这段 &lt;code&gt;nginx.conf&lt;/code&gt; 配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method never returns.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032605Z" changeid="xf">
        <seg>这个方法永不返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method was first introduced in the &lt;code&gt;v0.5.6&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095522Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.6&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method was first introduced in the &lt;code&gt;v0.7.17&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095144Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.7.17&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This module embeds Lua, via the standard Lua 5.1 interpreter or [http://luajit.org/luajit.html LuaJIT 2.0], into Nginx and by leveraging Nginx's subrequests, allows the integration of the powerful Lua threads (Lua coroutines) into the Nginx event model.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040750Z" changeid="xf">
        <seg>此模块将Lua（标准的Lua 5.1或 [http://luajit.org/luajit.html LuaJIT 2.0]）嵌入Nginx, 利用了Nginx的subrequest，把强大的Lua线程（Lua coroutines）集成进Nginx的事件模型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This module is under active development and is production ready.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034954Z" changeid="xf">
        <seg>模块持续更新中，可用于生产环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option is set to &lt;code&gt;false&lt;/code&gt; by default</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053909Z" changeid="xf">
        <seg>此选项默认设为 &lt;code&gt;false&lt;/code&gt; </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option was first introduced in the &lt;code&gt;v0.3.1rc25&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041804Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc25&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option was first introduced in the &lt;code&gt;v0.3.1rc31&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041909Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc31&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This setting can be overridden by cosocket objects' [[#tcpsock:setkeepalive|setkeepalive]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104518Z" changeid="xf">
        <seg>可以用 cosocket 对象的' [[#tcpsock:setkeepalive|setkeepalive]] 方法来修改.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This setting can be overridden by the [[#tcpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103137Z" changeid="xf">
        <seg>可以用 [[#tcpsock:settimeout|settimeout]] 方法进行修改.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should be called
before sending out the response headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083630Z" changeid="xf">
        <seg>对它的调用应在发送响应头之前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034514Z" changeid="xf">
        <seg>这个table可用于存储每个请求的Lua上下文数据，其生命周期与当前请求一致 (和 Nginx 变量一样).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This transformation can be turned off via the [[#lua_transform_underscores_in_response_headers|lua_transform_underscores_in_response_headers]] directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084048Z" changeid="xf">
        <seg>这个转换可以通过 [[#lua_transform_underscores_in_response_headers|lua_transform_underscores_in_response_headers]] 命令来关闭.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will be the case if &lt;code&gt;rewrite ^ /bar last&lt;/code&gt; is used as this will similarly initiate an internal redirection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080429Z" changeid="xf">
        <seg>如果写成 &lt;code&gt;rewrite ^ /bar last&lt;/code&gt; 也是同样结果，因为这也会类似地引发内部重定向</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will truncate the response body and usually result in incomplete and also invalid responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T095128Z" changeid="xf">
        <seg>这将会截断响应体，通常会造成不完整并且是无效的响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091814Z" changeid="xf">
        <seg>所以，在单个请求的生命周期中本命令中的代码也可能运行多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time consuming code sequences should therefore be avoided.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T093152Z" changeid="xf">
        <seg>所以应避免在这里编写耗时较长的代码序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ensure code caching, you can either use the [[#init_by_lua|init_by_lua]]
or [[#init-by_lua_file|init_by_lua_file]] directives to load all such files or just make these Lua files true Lua modules
and load them via &lt;code&gt;require&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T043004Z" changeid="xf">
        <seg>为了保证代码被缓存，你要么用 [[#init_by_lua|init_by_lua]]
或 [[#init-by_lua_file|init_by_lua_file]] 命令来加载文件或将这些Lua文件写成真正的Lua模块，并使用 &lt;code&gt;require&lt;/code&gt; 来加载.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To force in-file request bodies, try turning on [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023805Z" changeid="xf">
        <seg>要强制使用文件请求体, 打开 [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To force in-memory request bodies, try setting [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] to the same size value in [[HttpCoreModule#client_max_body_size|client_max_body_size]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023610Z" changeid="xf">
        <seg>要强制使用内存请求体，将 [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] 设置成与 [[HttpCoreModule#client_max_body_size|client_max_body_size]] 同样的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To output very large response data in a streaming fashion (via the [[#ngx.flush|ngx.flush]] call, for example), this directive MUST be turned off to minimize memory usage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020427Z" changeid="xf">
        <seg>如果要以流的方式输出大的响应数据 (例如通过 [[#ngx.flush|ngx.flush]] 调用), 本命令必须关闭来使内存的使用最小化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To quote the PCRE manpage, &quot;the limit ... has the effect of limiting the amount of backtracking that can take place.&quot;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060826Z" changeid="xf">
        <seg>引自 PCRE manpage： &quot;这个上限... 是用来限制正则表达式中允许的backtracking的最大数目&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To read an individual header:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015343Z" changeid="xf">
        <seg>要读取某一个头:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To read the request body data within the [[HttpCoreModule#$request_body|$request_body]] variable, 
[[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] must have the same value as [[HttpCoreModule#client_max_body_size|client_max_body_size]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101851Z" changeid="xf">
        <seg>要在 [[HttpCoreModule#$request_body|$request_body]] 变量中读取请求体数据, 
[[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] 必须与 [[HttpCoreModule#client_max_body_size|client_max_body_size]] 的值相同.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run in synchronous mode, call &lt;code&gt;ngx.flush(true)&lt;/code&gt; after calling &lt;code&gt;ngx.print&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041314Z" changeid="xf">
        <seg>要在同步模式中运行，在&lt;code&gt;ngx.print&lt;/code&gt; 之后调用 &lt;code&gt;ngx.flush(true)&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To terminate the current request from within a [[#access_by_lua|access_by_lua]] handler, calling [[#ngx.exit|ngx.exit]] with status &gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;) and status &lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) for successful quits and &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (or its friends) for failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094309Z" changeid="xf">
        <seg>To terminate the current request from within a 要在 [[#access_by_luaaccess_by_lua]] handler中终止请求处理, 如果是成功退出，要调用 [[#ngx.exit|ngx.exit]]将状态码设置为 &gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;)  &lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) 的值，如果是失败退出调用 &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (或类似的值).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To terminate the current request from within a [[#rewrite_by_lua|rewrite_by_lua]] handler, calling [[#ngx.exit|ngx.exit]] with status &gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;) and status &lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) for successful quits and &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (or its friends) for failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T075938Z" changeid="xf">
        <seg>To terminate the current request from within a 要在 [[#rewrite_by_lua|rewrite_by_lua]] handler中终止请求处理, 如果是成功退出，要调用 [[#ngx.exit|ngx.exit]]将状态码设置为 &gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;)  &lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) 的值，如果是失败退出调用 &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (或类似的值).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI arguments can be specified as well, for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040041Z" changeid="xf">
        <seg>也可以指定URI参数URI, 例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI query strings can be concatenated to URI itself, for instance,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041236Z" changeid="xf">
        <seg>URI query string可以被添加到URI本身 如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscores (&lt;code&gt;_&lt;/code&gt;) in the header names will also be replaced by dashes (&lt;code&gt;-&lt;/code&gt;) and the header names will be matched case-insensitively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091034Z" changeid="xf">
        <seg>同样，头名称中的下划线 (&lt;code&gt;_&lt;/code&gt;) 将被替换成减号 (&lt;code&gt;-&lt;/code&gt;) ，头名称的匹配是大小写无关的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscores (&lt;code&gt;_&lt;/code&gt;) in the header names will be replaced by hyphens (&lt;code&gt;-&lt;/code&gt;) by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084030Z" changeid="xf">
        <seg>默认会将头名称中的下划线(&lt;code&gt;_&lt;/code&gt;) 换成减号 (&lt;code&gt;-&lt;/code&gt;) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike [http://httpd.apache.org/docs/2.3/mod/mod_lua.html Apache's mod_lua] and [http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet Lighttpd's mod_magnet], Lua code executed using this module can be ''100% non-blocking'' on network traffic as long as the [[#Nginx API for Lua|Nginx API for Lua]] provided by this module is used to handle
requests to upstream services such as MySQL, PostgreSQL, Memcached, Redis, or upstream HTTP web services.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041129Z" changeid="xf">
        <seg>与[http://httpd.apache.org/docs/2.3/mod/mod_lua.html Apache's mod_lua] 和 [http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet Lighttpd's mod_magnet] 不同, 只要使用[[#Nginx API for LuaNginx API for Lua]]来处理到upstream服务如MySQL，PostgreSQL，Memcached, Redis或upstream web service的请求 使用本模块运行的Lua代码在处理网络请求时可以是 ''100% 非阻塞的''。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating query arguments via the nginx variable &lt;code&gt;$args&lt;/code&gt; (or &lt;code&gt;ngx.var.args&lt;/code&gt; in Lua) at runtime is also supported:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103027Z" changeid="xf">
        <seg>还支持在运行时用ngxin变量 &lt;code&gt;$args&lt;/code&gt; (或Lua &lt;code&gt;ngx.var.args&lt;/code&gt; )来更新请求参数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use normal locations combined with the &lt;code&gt;internal&lt;/code&gt; directive to
prepare internal-only locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041432Z" changeid="xf">
        <seg>对普通的location使用 &lt;code&gt;internal&lt;/code&gt; 命令来准备只作内部使用的location.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of jump in other contexts is prohibited and will throw out a Lua exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102102Z" changeid="xf">
        <seg>在其它的上下文中使用jump是被禁止的，会抛出Lua异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the [http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall package.seeall] flag is strongly discouraged due to its various bad side-effects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023835Z" changeid="xf">
        <seg>由于其所带来的各种不好的负作用，强烈不推荐使用 [http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall package.seeall] 标记。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the [[#ngx.req.get_post_args|ngx.req.get_post_args]] function instead if a Lua table is required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023105Z" changeid="xf">
        <seg>如果需要Lua table请使用[[#ngx.req.get_post_args|ngx.req.get_post_args]] 函数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uses Lua code specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; to define an output body filter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094824Z" changeid="xf">
        <seg>用 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; 中的代码来定义一个输出体过滤器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uses Lua code specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; to define an output header filter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094508Z" changeid="xf">
        <seg>用 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; 中的代码来定义一个输出头过滤器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually you can register (true) Lua global variables or pre-load Lua modules at server start-up by means of this hook.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063000Z" changeid="xf">
        <seg>通常你可以使用这个hook在服务器启动时来注册（真正的）Lua全局变量 或预加载Lua模块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can also use the numerical code directly as the second &lt;code&gt;status&lt;/code&gt; argument:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034651Z" changeid="xf">
        <seg>我们也可以直接在 &lt;code&gt;status&lt;/code&gt; 参数中使用数字状态码:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;code&gt;ngx.flush(true)&lt;/code&gt; is called immediately after [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]], it causes the latter functions to run in synchronous mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042340Z" changeid="xf">
        <seg>如果在[[#ngx.printngx.print]] 或 [[#ngx.sayngx.say]]之后立即调用 &lt;code&gt;ngx.flush(true)&lt;/code&gt; , 将导致前者运行于同步模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Nginx receives the &lt;code&gt;HUP&lt;/code&gt; signal and starts reloading the config file, the Lua VM will also be re-created and &lt;code&gt;init_by_lua&lt;/code&gt; will run again on the new Lua VM.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062921Z" changeid="xf">
        <seg>如果 Nginx 收到&lt;code&gt;HUP&lt;/code&gt; 信号，开始重新加载配置文件, Lua虚拟机将被重新创建， &lt;code&gt;init_by_lua&lt;/code&gt;会在新的Lua虚拟机中被重新运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a &lt;code&gt;FIN&lt;/code&gt; packet or something like that).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021900Z" changeid="xf">
        <seg>如果TCP keepalive被禁止, 需要依赖客户端来完美地关闭socket (发送 &lt;code&gt;FIN&lt;/code&gt; 或类似的包).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a relative path like &lt;code&gt;foo/bar.lua&lt;/code&gt; is given, they will be turned into the absolute path relative to the &lt;code&gt;server prefix&lt;/code&gt; path determined by the &lt;code&gt;-p PATH&lt;/code&gt; command-line option while starting the Nginx server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072132Z" changeid="xf">
        <seg>如果指定的是相对路径如 &lt;code&gt;foo/bar.lua&lt;/code&gt; , 它们将被加上 &lt;code&gt;server prefix&lt;/code&gt; 转换成绝对路径。&lt;code&gt;server prefix&lt;/code&gt;可由在Nginx服务器启动时使用&lt;code&gt;-p PATH&lt;/code&gt; 命令行参数来得到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042016Z" changeid="xf">
        <seg>当用默认参数调用时, 会发起一个异步调用 (立即返回， 不需要等待所有数据被写进系统发送缓冲区).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message &quot;N lua_max_running_timers are not enough&quot; where &quot;N&quot; is the current value of this directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022944Z" changeid="xf">
        <seg>当数量超限时，, Nginx将停止运行最新过期的定时器并记录错误日志消息 &quot;N lua_max_running_timers are not enough&quot; ，其中 &quot;N&quot; 是本命令当前所设置的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When exceeding this limit, the [[#ngx.timer.at|ngx.timer.at]] call will immediately return &lt;code&gt;nil&lt;/code&gt; and the error string &quot;too many pending timers&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022644Z" changeid="xf">
        <seg>当定时器数量超限时, [[#ngx.timer.at|ngx.timer.at]] 调用将立即返回 &lt;code&gt;nil&lt;/code&gt; 和错误信息 &quot;too many pending timers&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When setting &lt;code&gt;nil&lt;/code&gt; or an empty Lua string value to &lt;code&gt;ngx.arg[1]&lt;/code&gt;, no data chunk will be passed to the downstream Nginx output filters at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094846Z" changeid="xf">
        <seg>如果将&lt;code&gt;ngx.arg[1]&lt;/code&gt;设置成 &lt;code&gt;nil&lt;/code&gt; 或空的Lua string , 将不会有数据发往下游 Nginx输出过滤器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When setting the limit to 0, the default &quot;match limit&quot; when compiling the PCRE library is used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060942Z" changeid="xf">
        <seg>如果此值设为0, 将使用编译 PCRE 库时的默认“match limit”值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the &lt;code&gt;body&lt;/code&gt; option is not specified, the &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;PUT&lt;/code&gt; subrequests will inherit the request bodies of the parent request (if any).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082353Z" changeid="xf">
        <seg>如果没有指定 &lt;code&gt;body&lt;/code&gt; 选项， &lt;code&gt;POST&lt;/code&gt; 和 &lt;code&gt;PUT&lt;/code&gt; 子请求将从父请求中继承请求体(如果有的话).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the &lt;code&gt;header_value&lt;/code&gt; argument is &lt;code&gt;nil&lt;/code&gt;, the request header will be removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021220Z" changeid="xf">
        <seg>如果 &lt;code&gt;header_value&lt;/code&gt; 参数是&lt;code&gt;nil&lt;/code&gt;, 这个请求头将被删除.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
and the Nginx config must be reloaded each time the Lua source file is modified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073711Z" changeid="xf">
        <seg>如果Lua代码缓存被打开 (这是默认行为), 用户代码在第一个请求中被加载并缓存，每次Lua代码文件被修改后，需要重新加载Nginx配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080754Z" changeid="xf">
        <seg>如果Lua代码缓存被打开 (这是默认行为), 用户代码在第一个请求中被加载并缓存，每次Lua代码文件被修改后，需要重新加载Nginx配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the Lua code may change the length of the response body, then it is required to always clear out the &lt;code&gt;Content-Length&lt;/code&gt; response header (if any) in a header filter to enforce streaming output, as in</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T095500Z" changeid="xf">
        <seg>如果Lua 代码可能改变响应体的长度, 就总是需要用头过滤器来清除 &lt;code&gt;Content-Length&lt;/code&gt; 响应头 (如果有的话)来保证流输出的正确性, 例如</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104240Z" changeid="xf">
        <seg>当连接池使用超限时, 池中最不经常使用的 (空闲) 连接将被关闭，为当前连接腾出空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024023Z" changeid="xf">
        <seg>如果当前请求的请求体已经被读入内存，则旧的请求体内存将被释放；如果已经被读入磁盘文件，则此文件将被立即删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030341Z" changeid="xf">
        <seg>当请求体数据不再能保留在内存中时，数据将被写到一个临时文件里，就象Nginx核心中的标准请求体读取器一样.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the limit is hit, the error string &quot;pcre_exec() failed: -8&quot; will be returned by the [[#ngx.re.match|ngx.re API]] functions on the Lua land.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060911Z" changeid="xf">
        <seg>当达到这个上限时, 在Lua一方，[[#ngx.re.matchngx.re API]]会返回 &quot;pcre_exec() failed: -8&quot; 错误信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this directive is turned on, the ngx_lua module will monitor the premature connection close event on the downstream connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021251Z" changeid="xf">
        <seg>如果本命令被打开， ngx_lua 模块将监视下游连接的过早连接关闭事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this is used in the context of the [[#set_by_lua|set_by_lua]] or [[#set_by_lua_file|set_by_lua_file]] directives, this table is read-only and holds the input arguments to the config directives:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024553Z" changeid="xf">
        <seg>如果被用于 [[#set_by_lua|set_by_lua]] 或 [[#set_by_lua_file|set_by_lua_file]] 命令的上下文中, 这个table是只读的，装有配置命令的输入参数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this limit is exceeded, the following error message is added to the &lt;code&gt;error.log&lt;/code&gt; file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082536Z" changeid="xf">
        <seg>如果超限， &lt;code&gt;error.log&lt;/code&gt; 文件中将记录以下错误日志:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this table is used in the context of [[#body_filter_by_lua|body_filter_by_lua]] or [[#body_filter_by_lua_file|body_filter_by_lua_file]], the first element holds the input data chunk to the output filter code and the second element holds the boolean flag for the &quot;eof&quot; flag indicating the end of the whole output data stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T031853Z" changeid="xf">
        <seg>如果在 [[#body_filter_by_lua|body_filter_by_lua]] 或 [[#body_filter_by_lua_file|body_filter_by_lua_file]]中使用这个table, 第一个元素保存的是发给输出过滤器的数据块，第二个元素保存的是标记整个输出数据流&quot;eof&quot;的boolean值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this timeout reaches, idle connections will be closed and removed from the pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104454Z" changeid="xf">
        <seg>如果超时, 空闲的连接将被关闭并从池中删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this in place, developers can adopt an edit-and-refresh approach.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T042537Z" changeid="xf">
        <seg>有了它，开发者可以采用象开发php那样修改-刷新即可 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writes argument values into the nginx &lt;code&gt;error.log&lt;/code&gt; file with the &lt;code&gt;ngx.NOTICE&lt;/code&gt; log level.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033822Z" changeid="xf">
        <seg>将参数值以&lt;code&gt;ngx.NOTICE&lt;/code&gt;级别写入nginx &lt;code&gt;error.log&lt;/code&gt; 文件.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You always need to check the &lt;code&gt;res.truncated&lt;/code&gt; boolean flag to see if &lt;code&gt;res.body&lt;/code&gt; contains truncated data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041215Z" changeid="xf">
        <seg>你总是需要检查 &lt;code&gt;res.truncated&lt;/code&gt; boolean 标记来确认 &lt;code&gt;res.body&lt;/code&gt; 是否包含截断数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also initialize the [[#lua_shared_dict|lua_shared_dict]] shm storage at this phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063111Z" changeid="xf">
        <seg>也可以在这个阶段对 [[#lua_shared_dict|lua_shared_dict]] 共享存储进行初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify the optional
&lt;code&gt;no_request_line&lt;/code&gt; argument as a &lt;code&gt;true&lt;/code&gt; value to exclude the request line from the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095331Z" changeid="xf">
        <seg>要从结果中去掉请求行，可以将可选的
&lt;code&gt;no_request_line&lt;/code&gt; 参数设为 &lt;code&gt;true&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the &lt;code&gt;root&lt;/code&gt; account.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064438Z" changeid="xf">
        <seg>要非常小心避免Lua代码中潜在的安全漏洞，因为Nginx主进程经常用 &lt;code&gt;root&lt;/code&gt; 帐号来运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and old &lt;code&gt;Foo&lt;/code&gt; headers will be overridden if there is any.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021146Z" changeid="xf">
        <seg>如果之前设置了 &lt;code&gt;Foo&lt;/code&gt; 头，旧的值将被覆盖.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because &lt;code&gt;if&lt;/code&gt; runs ''before'' [[#rewrite_by_lua|rewrite_by_lua]] even if it is placed after [[#rewrite_by_lua|rewrite_by_lua]] in the config.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074742Z" changeid="xf">
        <seg>因为 &lt;code&gt;if&lt;/code&gt; 虽然写在[[#rewrite_by_luarewrite_by_lua]]之后，但还是在  [[#rewrite_by_lua|rewrite_by_lua]] ''之前''执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because &lt;code&gt;set $a 12&lt;/code&gt; and &lt;code&gt;set $b &quot;&quot;&lt;/code&gt; run ''before'' [[#rewrite_by_lua|rewrite_by_lua]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074615Z" changeid="xf">
        <seg>因为&lt;code&gt;set $a 12&lt;/code&gt; 和 &lt;code&gt;set $b &quot;&quot;&lt;/code&gt; 在[[#rewrite_by_luarewrite_by_lua]] ''之前'' 执行 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can be coded as</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102216Z" changeid="xf">
        <seg>可以写成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can be coded in Lua as</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101956Z" changeid="xf">
        <seg>可以用Lua写成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can be coded in Lua like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101939Z" changeid="xf">
        <seg>可以用Lua这样写:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the response headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084218Z" changeid="xf">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T042134Z" changeid="xf">
        <seg>等价于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to the following Lua code</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040006Z" changeid="xf">
        <seg>等价于以下Lua代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>modifications of the Nginx variables in the subrequest will affect the current (parent) request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T042105Z" changeid="xf">
        <seg>在子请求中修改nginx变量将影响到当前（父）请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>modifications of the nginx variables in the subrequest will not affect the current (parent) request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T042009Z" changeid="xf">
        <seg>在子请求中修改nginx变量不会影响当前（父）请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_COPY      (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033219Z" changeid="xf">
        <seg>ngx.HTTP_COPY      ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_LOCK      (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033254Z" changeid="xf">
        <seg>ngx.HTTP_LOCK      ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_MKCOL     (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033209Z" changeid="xf">
        <seg>ngx.HTTP_MKCOL     ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_MOVE      (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033233Z" changeid="xf">
        <seg>ngx.HTTP_MOVE      ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033202Z" changeid="xf">
        <seg>ngx.HTTP_OPTIONS   ( v0.5.0rc24 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_PATCH     (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033303Z" changeid="xf">
        <seg>ngx.HTTP_PATCH     ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_PROPFIND  (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033239Z" changeid="xf">
        <seg>ngx.HTTP_PROPFIND  ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_PROPPATCH (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033250Z" changeid="xf">
        <seg>ngx.HTTP_PROPPATCH ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_TRACE     (added in the v0.8.2 release)
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033307Z" changeid="xf">
        <seg>ngx.HTTP_TRACE     ( v0.8.2 版本引入)&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_UNLOCK    (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033259Z" changeid="xf">
        <seg>ngx.HTTP_UNLOCK    ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.req.append_body(chunk) -- each chunk can be 4KB</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030711Z" changeid="xf">
        <seg>ngx.req.append_body(chunk) -- 每一块可以是 4KB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.req.init_body(128 * 1024)  -- buffer is 128KB</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030656Z" changeid="xf">
        <seg>ngx.req.init_body(128 * 1024)  -- 缓冲区大小128KB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.var.diff = a - b;  -- write to $diff directly</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073042Z" changeid="xf">
        <seg>ngx.var.diff = a - b;  -- 直接写入 $diff </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx_lua - Embed the power of Lua into Nginx</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034801Z" changeid="xf">
        <seg>ngx_lua - 在Nging中嵌入强大的Lua</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102220Z" changeid="xf">
        <seg>或</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or a Lua table holding the query arguments' key-value pairs, as in</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102350Z" changeid="xf">
        <seg>或存有请求参数名－值对的 Lua table, 如</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102003Z" changeid="xf">
        <seg>或等价的,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rather than the original &lt;code&gt;&quot;hello&quot;&lt;/code&gt; value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035540Z" changeid="xf">
        <seg>而不是原始的 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>regardless of the actual request query string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103101Z" changeid="xf">
        <seg>，与实际的请求query string无关.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return a + b;          -- return the $sum value normally</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073056Z" changeid="xf">
        <seg>return a + b;          -- 照常返回 $sum 值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set $a 12; # create and initialize $a</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015451Z" changeid="xf">
        <seg>set $a 12; # 创建并初始化 $a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set $b ''; # create and initialize $b</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015501Z" changeid="xf">
        <seg>set $b ''; # 创建并初始化 $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set $diff ''; # we have to predefine the $diff variable here</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073026Z" changeid="xf">
        <seg>set $diff ''; # 必须先定义 $diff 变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set $my_var ''; # this line is required to create $my_var at config time</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032145Z" changeid="xf">
        <seg>set $my_var ''; # 这一行是必需的，在config期间创建 $my_var </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, this method will escape argument keys and values according to URI rules and
concatenate them together into a complete query string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053512Z" changeid="xf">
        <seg>也就是说, 这个方法会根据 URI 规范对参数的key和value进行转义并将其拼接成一个完整的 query string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that writes out &lt;code&gt;88&lt;/code&gt;, the sum of &lt;code&gt;32&lt;/code&gt; and &lt;code&gt;56&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024807Z" changeid="xf">
        <seg>输出 &lt;code&gt;88&lt;/code&gt;,  &lt;code&gt;32&lt;/code&gt; 和 &lt;code&gt;56&lt;/code&gt;的和.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the value of &lt;code&gt;ngx.req.get_headers()[&quot;Foo&quot;]&lt;/code&gt; will be a Lua (array) table such as:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015528Z" changeid="xf">
        <seg>&lt;code&gt;ngx.req.get_headers()[&quot;Foo&quot;]&lt;/code&gt; 的值是这样的 Lua (数组) table:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to be returned when reading &lt;code&gt;ngx.header.Foo&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091256Z" changeid="xf">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to prevent (temporary) memory leaking within the current request's lifetime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032806Z" changeid="xf">
        <seg>以避免在当前请求生命周期中出现（临时的）内存泄漏.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where in the latter case, this method will escape argument keys and values according to the URI escaping rule.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102442Z" changeid="xf">
        <seg>对后一种情况, 本方法会用URI转义规则对key和value进行转义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is equivalent to</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034602Z" changeid="xf">
        <seg>等价于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is functionally equivalent to</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102134Z" changeid="xf">
        <seg>在功能上等价于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which will result in a query string like &lt;code&gt;a=3&amp;b=5&amp;b=6&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102510Z" changeid="xf">
        <seg>生成的query string是 &lt;code&gt;a=3&amp;b=5&amp;b=6&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040024Z" changeid="xf">
        <seg>而</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will produce two new request headers:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021120Z" changeid="xf">
        <seg>将生成两个请求头:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will result in</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091252Z" changeid="xf">
        <seg>的结果是在读取&lt;code&gt;ngx.header.Foo&lt;/code&gt;时返回</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will yield</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084214Z" changeid="xf">
        <seg>将会在响应头中生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will yield the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041110Z" changeid="xf">
        <seg>将输出</seg>
      </tuv>
    </tu>
  </body>
</tmx>
