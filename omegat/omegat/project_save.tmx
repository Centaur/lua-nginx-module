<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.3.0_1"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Light threads&quot; are just a special kind of Lua coroutines that are scheduled by the ngx_lua module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013913Z" changeid="xf">
        <seg>&quot;轻量线程&quot; 其实是一种特殊的由ngx_lua调度的Lua coroutine.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&quot;Light threads&quot; are mostly useful for doing concurrent upstream requests in a single Nginx request handler, kinda like a generalized version of [[#ngx.location.capture_multi|ngx.location.capture_multi]] that can work with all the [[#Nginx API for Lua|Nginx API for Lua]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020355Z" changeid="xf">
        <seg>&quot;轻量线程&quot; 对于在一个Nginx请求处理器中实现并发的上游请求最有用, 有些象一个更一般化的可以与所有 [[#Nginx API for Lua|Nginx API for Lua]]一起使用的 [[#ngx.location.capture_multi|ngx.location.capture_multi]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>#    return ngx.arg[1]..ngx.arg[2]</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035710Z" changeid="xf">
        <seg>#    返回 ngx.arg[1]..ngx.arg[2]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># $ngx_prefix/conf/concat.lua contents:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035659Z" changeid="xf">
        <seg># $ngx_prefix/conf/concat.lua 的内容:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Download the latest version of Nginx [http://nginx.org/ HERE] (See [[#Nginx Compatibility|Nginx Compatibility]])</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033157Z" changeid="xf">
        <seg># 从 [http://nginx.org/ 这里]下载Nginx的最新版本 (见[[#Nginx Compatibility|Nginx兼容性]])</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Download the latest version of ngx_lua [http://github.com/chaoslawful/lua-nginx-module/tags HERE].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033131Z" changeid="xf">
        <seg># 从 [http://github.com/chaoslawful/lua-nginx-module/tags 这里]下载ngx_lua的最新版本.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Download the latest version of the ngx_devel_kit (NDK) module [http://github.com/simpl/ngx_devel_kit/tags HERE].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033110Z" changeid="xf">
        <seg># 从 [http://github.com/simpl/ngx_devel_kit/tags 这里] 下载ngx_devel_kit (NDK) 模块的最新版本.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Here we assume Nginx is to be installed under /opt/nginx/.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033306Z" changeid="xf">
        <seg># 这里我们假设Nginx安装到 /opt/nginx/.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Install LuaJIT 2.0 (recommended) or Lua 5.1 (Lua 5.2 is ''not'' supported yet).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032941Z" changeid="xf">
        <seg># 安装 LuaJIT 2.0 (推荐) 或 Lua 5.1 (Lua 5.2 ''尚'' 不支持).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># MIME type determined by default_type:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035405Z" changeid="xf">
        <seg># 使用默认的 MIME 类型:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># POST request with body 'a%20b=1%61+2'</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013305Z" changeid="xf">
        <seg># POST 体为 'a%20b=1%61+2'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Post request with the body 'foo=bar&amp;bar=baz&amp;bar=blah'</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013110Z" changeid="xf">
        <seg># Post请求体为 'foo=bar&amp;bar=baz&amp;bar=blah'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Use data storage mechanisms such as &lt;code&gt;memcached&lt;/code&gt;, &lt;code&gt;redis&lt;/code&gt;, &lt;code&gt;MySQL&lt;/code&gt; or &lt;code&gt;PostgreSQL&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041529Z" changeid="xf">
        <seg># 使用 &lt;code&gt;memcached&lt;/code&gt;, &lt;code&gt;redis&lt;/code&gt;, &lt;code&gt;MySQL&lt;/code&gt; 或r &lt;code&gt;PostgreSQL&lt;/code&gt; 之类的存储机制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Use only a single nginx worker and a single server (this is however not recommended when there is a multi core CPU or multiple CPUs in a single machine).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041509Z" changeid="xf">
        <seg># 仅使用一个nginx worker和一个 server (在多核或多CPU的机器上不推荐这么做).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># WARN: contents in nginx var must be carefully filtered,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040343Z" changeid="xf">
        <seg># 注意：nginx 变量中的内容必须被小心过滤</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># absolute script path not modified</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035746Z" changeid="xf">
        <seg># 直接使用绝对路径 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># creating a ticket on the [http://github.com/chaoslawful/lua-nginx-module/issues GitHub Issue Tracker],
# or posting to the [[#Community|OpenResty community]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T054135Z" changeid="xf">
        <seg># 提交bug到 [http://github.com/chaoslawful/lua-nginx-module/issues GitHub Issue Tracker],
# 或发邮件到 [[#Community|OpenResty community]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># evaluates to &quot;1234&quot;
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031405Z" changeid="xf">
        <seg># 值为 &quot;1234&quot;
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># force reading request body (default off)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035859Z" changeid="xf">
        <seg># 强制读取 request body (默认关闭)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># inline Lua script</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035430Z" changeid="xf">
        <seg># 内嵌Lua脚本</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># or tell where to find Lua if using Lua instead:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033256Z" changeid="xf">
        <seg># 如果使用Lua就告诉它在哪里找到Lua:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># otherwise there'll be great security risk!</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040125Z" changeid="xf">
        <seg># 否则会产生巨大的安全漏洞!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># script path relative to nginx prefix</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035650Z" changeid="xf">
        <seg># 使用相对于$ngx_prefix的脚本路径</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># set search paths for Lua external libraries written in C (can also use ';;'):</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035333Z" changeid="xf">
        <seg># 设置用C编写的外部库的查找路径 (也可以使用 ';;'):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># set search paths for pure Lua external libraries (';;' is the default path):</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035307Z" changeid="xf">
        <seg># 设置纯Lua编写的外部库的查找路径 (';;' 是默认查找路径):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># tell nginx's build system where to find LuaJIT:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033240Z" changeid="xf">
        <seg># 告诉Nginx编译系统在哪里找到 LuaJIT:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># transparent non-blocking I/O in Lua via subrequests</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035937Z" changeid="xf">
        <seg># 在Lua中使用subrequests进行透明的非阻塞I/O</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># try access /nginx_var?a=hello,world</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035832Z" changeid="xf">
        <seg># 试试访问 /nginx_var?a=hello,world</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># use nginx var in code path</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040349Z" changeid="xf">
        <seg># 在代码路径中使用 nginx 变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># whether the current request body is already larger than the [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]],
# and whether [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]] has been switched on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022403Z" changeid="xf">
        <seg># 当前请求体是否已经超过了 [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] 的大小,
# 是否打开了 [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''WARNING''' Be careful when calling this method on dictionaries with a really huge number of keys.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060916Z" changeid="xf">
        <seg>'''警告''' 对键真的很多的字典要小心使用本方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''WARNING''' When reading from an Nginx variable, Nginx will allocate memory in the per-request memory pool which is freed only at request termination.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032621Z" changeid="xf">
        <seg>'''警告''' 在读取Nginx变量时, Nginx将在每个请求的内存池中分配内存，只有当请求结束时，这个内存池才被释放。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''http''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T054114Z" changeid="xf">
        <seg>'''可包含于:''' ''http''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''http, server, location''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102537Z" changeid="xf">
        <seg>'''可包含于:''' ''http, server, location''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''http, server, location, location if''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074340Z" changeid="xf">
        <seg>'''可包含于:''' ''http, server, location, location if''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''http, server, location, location-if''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015813Z" changeid="xf">
        <seg>'''可包含于:''' ''http, server, location, location-if''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041548Z" changeid="xf">
        <seg>'''可包含于:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033738Z" changeid="xf">
        <seg>'''可包含于:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''location, location if''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073845Z" changeid="xf">
        <seg>'''可包含于:''' ''location, location if''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''main | server | location''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101517Z" changeid="xf">
        <seg>'''可包含于:''' ''main | server | location''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''main''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061028Z" changeid="xf">
        <seg>'''可包含于:''' ''main''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''main, server, location, location if''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061103Z" changeid="xf">
        <seg>'''可包含于:''' ''main, server, location, location if''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035834Z" changeid="xf">
        <seg>'''可包含于:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083803Z" changeid="xf">
        <seg>'''可包含于:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015807Z" changeid="xf">
        <seg>'''可包含于:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''server, server if, location, location if''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073402Z" changeid="xf">
        <seg>'''可包含于:''' ''server, server if, location, location if''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, body_filter_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024456Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, body_filter_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024337Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094408Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020726Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095706Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032030Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015950Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua*, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102531Z" changeid="xf">
        <seg>'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''The content of LUA_CPATH environment variable or Lua's compiled-in defaults.''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062249Z" changeid="xf">
        <seg>'''默认值:''' ''环境变量LUA_CPATH的内容或 Lua编译时指定的默认值.''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''The content of LUA_PATH environ variable or Lua's compiled-in defaults.''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061022Z" changeid="xf">
        <seg>'''默认值:''' ''The content of LUA_PATH environ variable or Lua's compiled-in defaults.''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_check_client_abort off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020949Z" changeid="xf">
        <seg>'''默认值:''' ''lua_check_client_abort off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_code_cache on''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041953Z" changeid="xf">
        <seg>'''默认值:''' ''lua_code_cache on''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_http10_buffering on''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015809Z" changeid="xf">
        <seg>'''默认值:''' ''lua_http10_buffering on''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_max_pending_timers 1024''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022509Z" changeid="xf">
        <seg>'''默认值:''' ''lua_max_pending_timers 1024''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_max_running_timers 256''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022702Z" changeid="xf">
        <seg>'''默认值:''' ''lua_max_running_timers 256''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_regex_cache_max_entries 1024''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T054048Z" changeid="xf">
        <seg>'''默认值:''' ''lua_regex_cache_max_entries 1024''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_regex_match_limit 0''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060242Z" changeid="xf">
        <seg>'''默认值:''' ''lua_regex_match_limit 0''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_buffer_size 4k/8k''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103146Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_buffer_size 4k/8k''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_connect_timeout 60s''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102533Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_connect_timeout 60s''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_keepalive_timeout 60s''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104352Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_keepalive_timeout 60s''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_log_errors on''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104530Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_log_errors on''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_pool_size 30''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103328Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_pool_size 30''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_read_timeout 60s''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103030Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_read_timeout 60s''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_send_lowat 0''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102852Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_send_lowat 0''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_socket_send_timeout 60s''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102754Z" changeid="xf">
        <seg>'''默认值:''' ''lua_socket_send_timeout 60s''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''lua_transform_underscores_in_response_headers on''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020724Z" changeid="xf">
        <seg>'''默认值:''' ''lua_transform_underscores_in_response_headers on''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''no''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102327Z" changeid="xf">
        <seg>'''默认值:''' ''no''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101513Z" changeid="xf">
        <seg>'''默认值:''' ''off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''default:''' ''rewrite_by_lua_no_postpone off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020501Z" changeid="xf">
        <seg>'''默认值:''' ''rewrite_by_lua_no_postpone off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''access tail''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080904Z" changeid="xf">
        <seg>'''执行阶段:''' ''access tail''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''content''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073850Z" changeid="xf">
        <seg>'''执行阶段:''' ''content''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''depends on usage''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101521Z" changeid="xf">
        <seg>'''执行阶段:''' ''depends on usage''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''loading-config''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062457Z" changeid="xf">
        <seg>'''执行阶段:''' ''loading-config''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''log''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T090904Z" changeid="xf">
        <seg>'''执行阶段:''' ''log''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''output-body-filter''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094804Z" changeid="xf">
        <seg>'''执行阶段:''' ''output-body-filter''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''output-header-filter''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094438Z" changeid="xf">
        <seg>'''执行阶段:''' ''output-header-filter''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''rewrite tail''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074343Z" changeid="xf">
        <seg>'''执行阶段:''' ''rewrite tail''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''phase:''' ''server-rewrite, rewrite''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072152Z" changeid="xf">
        <seg>'''执行阶段:''' ''server-rewrite, rewrite''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''access_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080857Z" changeid="xf">
        <seg>'''语法:''' ''access_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''access_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094315Z" changeid="xf">
        <seg>'''语法:''' ''access_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''body_filter_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094758Z" changeid="xf">
        <seg>'''语法:''' ''body_filter_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''body_filter_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091649Z" changeid="xf">
        <seg>'''语法:''' ''body_filter_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''content_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073841Z" changeid="xf">
        <seg>'''语法:''' ''content_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''content_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074154Z" changeid="xf">
        <seg>'''语法:''' ''content_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''data, err, partial = tcpsock:receive(pattern?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T083131Z" changeid="xf">
        <seg>'''语法:''' ''data, err, partial = tcpsock:receive(pattern?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''dict = ngx.shared[name_var]''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T033012Z" changeid="xf">
        <seg>'''语法:''' ''dict = ngx.shared[name_var]''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''header_filter_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094434Z" changeid="xf">
        <seg>'''语法:''' ''header_filter_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''header_filter_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094727Z" changeid="xf">
        <seg>'''语法:''' ''header_filter_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''init_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062431Z" changeid="xf">
        <seg>'''语法:''' ''init_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''init_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064458Z" changeid="xf">
        <seg>'''语法:''' ''init_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''log_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T090847Z" changeid="xf">
        <seg>'''语法:''' ''log_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''log_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101432Z" changeid="xf">
        <seg>'''语法:''' ''log_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_check_client_abort on|off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020945Z" changeid="xf">
        <seg>'''语法:''' ''lua_check_client_abort on|off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_http10_buffering on|off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015805Z" changeid="xf">
        <seg>'''语法:''' ''lua_http10_buffering on|off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_max_pending_timers &lt;count&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022505Z" changeid="xf">
        <seg>'''语法:''' ''lua_max_pending_timers &lt;count&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_max_running_timers &lt;count&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022657Z" changeid="xf">
        <seg>'''语法:''' ''lua_max_running_timers &lt;count&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_need_request_body &lt;on|off&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101507Z" changeid="xf">
        <seg>'''语法:''' ''lua_need_request_body &lt;on|off&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_package_cpath &lt;lua-style-cpath-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062204Z" changeid="xf">
        <seg>'''语法:''' ''lua_package_cpath &lt;lua-style-cpath-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_package_path &lt;lua-style-path-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061017Z" changeid="xf">
        <seg>'''语法:''' ''lua_package_path &lt;lua-style-path-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_shared_dict &lt;name&gt; &lt;size&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102322Z" changeid="xf">
        <seg>'''语法:''' ''lua_shared_dict &lt;name&gt; &lt;size&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_buffer_size &lt;size&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103143Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_buffer_size &lt;size&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_connect_timeout &lt;time&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102529Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_connect_timeout &lt;time&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_keepalive_timeout &lt;time&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104349Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_keepalive_timeout &lt;time&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_log_errors on|off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104528Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_log_errors on|off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_pool_size &lt;size&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103325Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_pool_size &lt;size&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_read_timeout &lt;time&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103026Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_read_timeout &lt;time&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_send_lowat &lt;size&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102849Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_send_lowat &lt;size&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_socket_send_timeout &lt;time&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102751Z" changeid="xf">
        <seg>'''语法:''' ''lua_socket_send_timeout &lt;time&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''lua_transform_underscores_in_response_headers on|off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020720Z" changeid="xf">
        <seg>'''语法:''' ''lua_transform_underscores_in_response_headers on|off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''ok, err = tcpsock:connect(&quot;unix:/path/to/unix-domain.socket&quot;, options_table?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074315Z" changeid="xf">
        <seg>'''语法:''' ''ok, err = tcpsock:connect(&quot;unix:/path/to/unix-domain.socket&quot;, options_table?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''ok, err = udpsock:setpeername(&quot;unix:/path/to/unix-domain.socket&quot;)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065043Z" changeid="xf">
        <seg>'''语法:''' ''ok, err = udpsock:setpeername(&quot;unix:/path/to/unix-domain.socket&quot;)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''rewrite_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074335Z" changeid="xf">
        <seg>'''语法:''' ''rewrite_by_lua &lt;lua-script-str&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''rewrite_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080626Z" changeid="xf">
        <seg>'''语法:''' ''rewrite_by_lua_file &lt;path-to-lua-script-file&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''rewrite_by_lua_no_postpone on|off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020457Z" changeid="xf">
        <seg>'''语法:''' ''rewrite_by_lua_no_postpone on|off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''set_by_lua $res &lt;lua-script-str&gt; [$arg1 $arg2 ...]''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072141Z" changeid="xf">
        <seg>'''语法:''' ''set_by_lua $res &lt;lua-script-str&gt; [$arg1 $arg2 ...]''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''tcpsock, err = ngx.socket.connect(&quot;unix:/path/to/unix-domain.socket&quot;)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102444Z" changeid="xf">
        <seg>'''语法:''' ''tcpsock, err = ngx.socket.connect(&quot;unix:/path/to/unix-domain.socket&quot;)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>'''syntax:''' ''value = ngx.header.HEADER''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083756Z" changeid="xf">
        <seg>'''语法:''' ''value = ngx.header.HEADER''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>''This module is not distributed with the Nginx source.'' See [[#Installation|the installation instructions]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034900Z" changeid="xf">
        <seg>''此模块属于第三方扩展，不包含在Nginx源码发布包中。 参阅 [[#Installation|安装]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Before the &lt;code&gt;v0.7.14&lt;/code&gt; release, the &quot;eof&quot; flag does not work at all in subrequests.)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094408Z" changeid="xf">
        <seg>(在&lt;code&gt;v0.7.14&lt;/code&gt;之前的版本中, &quot;eof&quot; 标记对子请求无效.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(This usually just means OpenSSL should be installed while building Nginx).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021746Z" changeid="xf">
        <seg>(通常这意味着在编译Nginx时安装OpenSSL).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>([[#Special PCRE Sequences|Known Issue With Special PCRE Sequences]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025421Z" changeid="xf">
        <seg>([[#Special PCRE Sequences|PCRE特殊序列的已知问题]]).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* 1.4.x (last tested: 1.4.1)
* 1.3.x (last tested: 1.3.11)
* 1.2.x (last tested: 1.2.9)
* 1.1.x (last tested: 1.1.5)
* 1.0.x (last tested: 1.0.15)
* 0.9.x (last tested: 0.9.4)
* 0.8.x &gt;= 0.8.54 (last tested: 0.8.54)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032701Z" changeid="xf">
        <seg>* 1.4.x (已测试: 1.4.1)
* 1.3.x (已测试 : 1.3.11)
* 1.2.x (已测试: 1.2.9)
* 1.1.x (已测试: 1.1.5)
* 1.0.x (已测试: 1.0.15)
* 0.9.x (已测试: 0.9.4)
* 0.8.x &gt;= 0.8.54 (已测试: 0.8.54)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;'*a'&lt;/code&gt;: reads from the socket until the connection is closed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T084823Z" changeid="xf">
        <seg>* &lt;code&gt;'*a'&lt;/code&gt;: 从socket中读取，直到连接被关闭.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;access&lt;/code&gt;
: for the context of [[#access_by_lua|access_by_lua]] or [[#access_by_lua_file|access_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102742Z" changeid="xf">
        <seg>* &lt;code&gt;access&lt;/code&gt;
: 可能是 [[#access_by_lua|access_by_lua]] or [[#access_by_lua_file|access_by_lua_file]] 上下文.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;args&lt;/code&gt;
: specify the subrequest's URI query arguments (both string value and Lua tables are accepted)
* &lt;code&gt;ctx&lt;/code&gt;
: specify a Lua table to be the [[#ngx.ctx|ngx.ctx]] table for the subrequest.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041707Z" changeid="xf">
        <seg>* &lt;code&gt;args&lt;/code&gt;
: 指定子请求的URI请求参数 (接受字符串值和Lua table)
* &lt;code&gt;ctx&lt;/code&gt;
: 为子请求指定 [[#ngx.ctx|ngx.ctx]] table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;body&lt;/code&gt;
: specify the subrequest's request body (string value only).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041558Z" changeid="xf">
        <seg>* &lt;code&gt;body&lt;/code&gt;
: 指定子请求的请求体 (只允许字符串值).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;body_filter&lt;/code&gt;
: for the context of [[#body_filter_by_lua|body_filter_by_lua]] or [[#body_filter_by_lua_file|body_filter_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102807Z" changeid="xf">
        <seg>* &lt;code&gt;body_filter&lt;/code&gt;
: 可能是 [[#body_filter_by_lua|body_filter_by_lua]] or [[#body_filter_by_lua_file|body_filter_by_lua_file]] 上下文.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;content&lt;/code&gt;
: for the context of [[#content_by_lua|content_by_lua]] or [[#content_by_lua_file|content_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102750Z" changeid="xf">
        <seg>* &lt;code&gt;content&lt;/code&gt;
: 可能是 [[#content_by_lua|content_by_lua]] or [[#content_by_lua_file|content_by_lua_file]] 上下文.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;copy_all_vars&lt;/code&gt;
: specify whether to copy over all the Nginx variable values of the current request to the subrequest in question.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041951Z" changeid="xf">
        <seg>* &lt;code&gt;copy_all_vars&lt;/code&gt;
: 指定是否将当前请求中的所有Ngin变量复制到子请求中</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;err&lt;/code&gt;: textual error message, can be &lt;code&gt;&quot;no memory&quot;&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T035020Z" changeid="xf">
        <seg>* &lt;code&gt;err&lt;/code&gt;: 文本错误信息, 可以是 &lt;code&gt;&quot;no memory&quot;&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;forcible&lt;/code&gt;: a boolean value to indicate whether other valid items have been removed forcibly when out of storage in the shared memory zone.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T035114Z" changeid="xf">
        <seg>* &lt;code&gt;forcible&lt;/code&gt;: 布尔值，标明是否由于共享内存区的空间不够而导致其它有效项被删除.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;header_filter&lt;/code&gt;
: for the context of [[#header_filter_by_lua|header_filter_by_lua]] or [[#header_filter_by_lua_file|header_filter_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102759Z" changeid="xf">
        <seg>* &lt;code&gt;header_filter&lt;/code&gt;
: 可能是 [[#header_filter_by_lua|header_filter_by_lua]] or [[#header_filter_by_lua_file|header_filter_by_lua_file]] 上下文.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;init&lt;/code&gt;
: for the context of [[#init_by_lua|init_by_lua]] or [[#init_by_lua_file|init_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102726Z" changeid="xf">
        <seg>* &lt;code&gt;init&lt;/code&gt;
: 可能是 [[#init_by_lua|init_by_lua]] 或 [[#init_by_lua_file|init_by_lua_file]] 上下文.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;log&lt;/code&gt;
: for the context of [[#log_by_lua|log_by_lua]] or [[#log_by_lua_file|log_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102832Z" changeid="xf">
        <seg>* &lt;code&gt;log&lt;/code&gt;
: 可能是 [[#log_by_lua|log_by_lua]] or [[#log_by_lua_file|log_by_lua_file]] 上下文.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;method&lt;/code&gt;
: specify the subrequest's request method, which only accepts constants like &lt;code&gt;ngx.HTTP_POST&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041533Z" changeid="xf">
        <seg>* &lt;code&gt;method&lt;/code&gt;
: 指定子请求的请求方法，只接受 &lt;code&gt;ngx.HTTP_POST&lt;/code&gt; 这样的常量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;pool&lt;/code&gt;
: specify a custom name for the connection pool being used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074817Z" changeid="xf">
        <seg>* &lt;code&gt;pool&lt;/code&gt;
: 自定义要使用的连接池的名称.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;rewrite&lt;/code&gt;
: for the context of [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102733Z" changeid="xf">
        <seg>* &lt;code&gt;rewrite&lt;/code&gt;
: 可能是 [[#rewrite_by_lua|rewrite_by_lua]] 或 [[#rewrite_by_lua_file|rewrite_by_lua_file]] 上下文.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;set&lt;/code&gt;
: for the context of [[#set_by_lua|set_by_lua]] or [[#set_by_lua_file|set_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102721Z" changeid="xf">
        <seg>* &lt;code&gt;set&lt;/code&gt;
: 可能是 [[#set_by_lua|set_by_lua]] 或 [[#set_by_lua_file|set_by_lua_file]] 上下文.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;share_all_vars&lt;/code&gt;
: specify whether to share all the Nginx variables of the subrequest with the current (parent) request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T042045Z" changeid="xf">
        <seg>* &lt;code&gt;share_all_vars&lt;/code&gt;
: 指定是否将本（父）请求中的Nginx变量值与子请求共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;success&lt;/code&gt;: boolean value to indicate whether the key-value pair is stored or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T035007Z" changeid="xf">
        <seg>* &lt;code&gt;success&lt;/code&gt;: 布尔值，标明是否成功写入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;timer&lt;/code&gt;
: for the context of user callback functions for [[#ngx.timer.at|ngx.timer.*]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102856Z" changeid="xf">
        <seg>* &lt;code&gt;timer&lt;/code&gt;
: 可能是 [[#ngx.timer.at|ngx.timer.*]] 的用户回调函数上下文.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* &lt;code&gt;vars&lt;/code&gt;
: take a Lua table which holds the values to set the specified Nginx variables in the subrequest as this option's value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041902Z" changeid="xf">
        <seg>* &lt;code&gt;vars&lt;/code&gt;
: Lua table，其内部的值将作为子请求的Nginx 变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Applications:
** mysql: create database 'ngx_test', grant all privileges to user 'ngx_test', password is 'ngx_test'
** memcached</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032037Z" changeid="xf">
        <seg>* 应用程序:
** mysql: create database 'ngx_test', grant all privileges to user 'ngx_test', password is 'ngx_test'
** memcached</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* As the standard Lua 5.1 interpreter's VM is not fully resumable, the methods [[#ngx.location.capture|ngx.location.capture]], [[#ngx.location.capture_multi|ngx.location.capture_multi]], [[#ngx.redirect|ngx.redirect]], [[#ngx.exec|ngx.exec]], and [[#ngx.exit|ngx.exit]] cannot be used within the context of a Lua [http://www.lua.org/manual/5.1/manual.html#pdf-pcall pcall()] or [http://www.lua.org/manual/5.1/manual.html#pdf-xpcall xpcall()] or even the first line of the &lt;code&gt;for ... in ...&lt;/code&gt; statement when the standard Lua 5.1 interpreter is used and the &lt;code&gt;attempt to yield across metamethod/C-call boundary&lt;/code&gt; error will be produced.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T025555Z" changeid="xf">
        <seg>* 由于标准的Lua 5.1 解释器虚拟机不是完全可恢复的, 如果使用标准的Lua 5.1 解释器， [[#ngx.location.capture|ngx.location.capture]], [[#ngx.location.capture_multi|ngx.location.capture_multi]], [[#ngx.redirect|ngx.redirect]], [[#ngx.exec|ngx.exec]], 和 [[#ngx.exit|ngx.exit]] 不能用于 Lua [http://www.lua.org/manual/5.1/manual.html#pdf-pcall pcall()] 或 [http://www.lua.org/manual/5.1/manual.html#pdf-xpcall xpcall()] 的上下文甚至是 &lt;code&gt;for ... in ...&lt;/code&gt; 语句的第一行，会产生 &lt;code&gt;attempt to yield across metamethod/C-call boundary&lt;/code&gt; 错误.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* C libraries:
** yajl: https://github.com/lloyd/yajl</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032029Z" changeid="xf">
        <seg>* C 库:
** yajl: https://github.com/lloyd/yajl</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Lua modules:
** lua-yajl: https://github.com/brimworks/lua-yajl 
*** Note: the compiled module has to be placed in '/usr/local/lib/lua/5.1/'</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032033Z" changeid="xf">
        <seg>* Lua 模块:
** lua-yajl: https://github.com/brimworks/lua-yajl 
*** Note: the compiled module has to be placed in '/usr/local/lib/lua/5.1/'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Mashup'ing and processing outputs of various nginx upstream outputs (proxy, drizzle, postgres, redis, memcached, and etc) in Lua,
* doing arbitrarily complex access control and security checks in Lua before requests actually reach the upstream backends,
* manipulating response headers in an arbitrary way (by Lua)
* fetching backend information from external storage backends (like redis, memcached, mysql, postgresql) and use that information to choose which upstream backend to access on-the-fly,
* coding up arbitrarily complex web applications in a content handler using synchronous but still non-blocking access to the database backends and other storage,
* doing very complex URL dispatch in Lua at rewrite phase,
* using Lua to implement advanced caching mechanism for Nginx's subrequests and arbitrary locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033817Z" changeid="xf">
        <seg>* 在Lua中对各个nginx上游(proxy, drizzle, postgres, redis, memcached等)输出进行混合和处理,
* 在请求真正到达上游后端前用Lua进行复杂的访问控制和安全检测,
* (使用Lua)对响应头进行任意操作
* 从后端外部存储(象 redis, memcached, mysql, postgresql)获取数据，用这些数据来实时选择访问哪个上游后端,
* 在内容处理器中用同步但仍是非阻塞的方式访问后端数据库或其它存储来实现任意复杂的web应用,
* 在rewrite阶段用Lua完成非常复杂的URL派发,
* 使用Lua为Nginx子请求和任何location实现高级缓存机制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Nginx modules:
** echo-nginx-module: http://github.com/agentzh/echo-nginx-module 
** drizzle-nginx-module: http://github.com/chaoslawful/drizzle-nginx-module 
** rds-json-nginx-module: http://github.com/agentzh/rds-json-nginx-module 
** set-misc-nginx-module: http://github.com/agentzh/set-misc-nginx-module 
** headers-more-nginx-module: http://github.com/agentzh/headers-more-nginx-module 
** memc-nginx-module: http://github.com/agentzh/memc-nginx-module 
** srcache-nginx-module: http://github.com/agentzh/srcache-nginx-module 
** ngx_auth_request: http://mdounin.ru/hg/ngx_http_auth_request_module/</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T054151Z" changeid="xf">
        <seg>* Nginx 模块:
** echo-nginx-module: http://github.com/agentzh/echo-nginx-module 
** drizzle-nginx-module: http://github.com/chaoslawful/drizzle-nginx-module 
** rds-json-nginx-module: http://github.com/agentzh/rds-json-nginx-module 
** set-misc-nginx-module: http://github.com/agentzh/set-misc-nginx-module 
** headers-more-nginx-module: http://github.com/agentzh/headers-more-nginx-module 
** memc-nginx-module: http://github.com/agentzh/memc-nginx-module 
** srcache-nginx-module: http://github.com/agentzh/srcache-nginx-module 
** ngx_auth_request: http://mdounin.ru/hg/ngx_http_auth_request_module/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Nginx version &gt;= 0.8.54</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032019Z" changeid="xf">
        <seg>* Nginx 版本&gt;= 0.8.54</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Output API functions (e.g., [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
* Control API functions (e.g., [[#ngx.exit|ngx.exit]] and [[#ngx.exec|ngx.exec]])
* Subrequest API functions (e.g., [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
* Cosocket API functions (e.g., [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094539Z" changeid="xf">
        <seg>* Output API 函数(例如, [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
* Control API 函数(例如, [[#ngx.exit|ngx.exit]]) 
* Subrequest API 函数(例如, [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
* Cosocket API 函数(例如, [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Output API functions (e.g., [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
* Control API functions (e.g., [[#ngx.exit|ngx.exit]]) 
* Subrequest API functions (e.g., [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
* Cosocket API functions (e.g., [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072625Z" changeid="xf">
        <seg>* Output API 函数(例如, [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
* Control API 函数(例如, [[#ngx.exit|ngx.exit]]) 
* Subrequest API 函数(例如, [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])
* Cosocket API 函数(例如, [[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.req.socket|ngx.req.socket]]).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Perl modules:
** test-nginx: http://github.com/agentzh/test-nginx</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032016Z" changeid="xf">
        <seg>* Perl 模块:
** test-nginx: http://github.com/agentzh/test-nginx</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- (one may want to buffer the data in Lua a bit to</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T023157Z" changeid="xf">
        <seg>-- (你可能需要在Lua里对数据进行缓冲以</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- access MySQL, PostgreSQL, Redis, Memcached, and etc here...</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015452Z" changeid="xf">
        <seg>-- 此处访问 MySQL, PostgreSQL, Redis, Memcached等...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- actually return the results.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020618Z" changeid="xf">
        <seg>-- .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- check if the request body contains bad words</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040239Z" changeid="xf">
        <seg>-- 检查request body中是否包含恶意词或敏感词</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- check the client IP address is in our black list</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040205Z" changeid="xf">
        <seg>-- 检查客户端IP是否在黑名单里</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- construct the requests table</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053009Z" changeid="xf">
        <seg>-- 构造请求table</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- custom cleanup work goes here, like cancelling a pending DB transaction</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021741Z" changeid="xf">
        <seg>-- 这里写自定义的清理工作，如取消一个等待中的数据库事务</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- do some routine job in Lua just like a cron job</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053913Z" changeid="xf">
        <seg>-- 用Lua做一些日常任务，就象cron一样</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- equivalent to ngx.header[&quot;Content-Type&quot;] = 'text/plain'</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084117Z" changeid="xf">
        <seg>-- 等价于 ngx.header[&quot;Content-Type&quot;] = 'text/plain'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- issue all the requests at once and wait until they all return</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053033Z" changeid="xf">
        <seg>-- 一次性发起所有请求，等待所有请求都返回</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- just throw away any remaining chunk data</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T095022Z" changeid="xf">
        <seg>-- 丢弃剩下的块数据</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- loop over the responses table</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053048Z" changeid="xf">
        <seg>-- 对响应 table进行遍历</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- now abort all the &quot;light threads&quot; running in the current request handler</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021801Z" changeid="xf">
        <seg>-- 现在中断当前请求处理器中运行的所有&quot;轻量线程&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- now res == 'a%2fb'
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042056Z" changeid="xf">
        <seg>-- 现在 res == 'a%2fb'
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- output the results in the order that they</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020616Z" changeid="xf">
        <seg>-- 结果按实际返回的次序输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- process the response table &quot;resp&quot;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053102Z" changeid="xf">
        <seg>-- 对响应table &quot;resp&quot;进行处理</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- push the data uri, args, and status to the remote</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T023134Z" changeid="xf">
        <seg>-- 使用ngx.socket.tcp 或 ngx.socket.udp将数据uri, 参数和状态推送给远程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- query mysql, memcached, and a remote http service at the same time,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020604Z" changeid="xf">
        <seg>-- 同时请求mysql, memcached, 和一个远程http服务,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- save I/O operations)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T023213Z" changeid="xf">
        <seg>-- 减少I/O操作)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- stop the &quot;world&quot;, aborting other running threads</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021237Z" changeid="xf">
        <seg>-- 停止所有，中断当前运行的线程</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- tests passed</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040253Z" changeid="xf">
        <seg>-- 测试通过</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- to cause quit the whole request rather than the current phase handler</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015034Z" changeid="xf">
        <seg>-- 导致退出整个请求而不是当前阶段处理器</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- to prevent use of casual module global variables</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T030429Z" changeid="xf">
        <seg>-- 防止随意使用模块全局变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- via ngx.socket.tcp or ngx.socket.udp</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T023137Z" changeid="xf">
        <seg>--  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- yields &quot;Thu, 18 Nov 2010 11:27:35 GMT&quot;
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022748Z" changeid="xf">
        <seg>-- 输出 &quot;Thu, 18 Nov 2010 11:27:35 GMT&quot;
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-- yields &quot;Thu, 18-Nov-10 11:27:35 GMT&quot;
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022646Z" changeid="xf">
        <seg>-- 输出 &quot;Thu, 18-Nov-10 11:27:35 GMT&quot;
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>--- use the val repeatedly later
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032734Z" changeid="xf">
        <seg>--- 后续重复使用val
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-agentzh'&lt;/code&gt; will be returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T094524Z" changeid="xf">
        <seg>-agentzh'&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-agentzh\r\n--abcedhb blah blah'&lt;/code&gt;, then the string &lt;code&gt;'hello, world!</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T094520Z" changeid="xf">
        <seg>-agentzh\r\n--abcedhb blah blah'&lt;/code&gt;, 则将返回 &lt;code&gt;'hello, world!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-agentzh\r\n--abcedhb blah blah'&lt;/code&gt;, we shall get the following output from the sample code above:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T095351Z" changeid="xf">
        <seg>-agentzh\r\n--abcedhb blah blah'&lt;/code&gt;, 我们将得到这样的输出:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>: instead of the old deprecated form:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T025726Z" changeid="xf">
        <seg>: 而不是已经不推荐的形式:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;0&lt;/code&gt; delay can also be specified, in which case the
timer will immediately expire when the current handler yields
execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T022248Z" changeid="xf">
        <seg>也可以指定&lt;code&gt;0&lt;/code&gt;延迟，这样当前处理器挂起时定时器将立即过期.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;GET /test?=hello&amp;=world&lt;/code&gt; will yield an empty output for instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102942Z" changeid="xf">
        <seg>例如，&lt;code&gt;GET /test?=hello&amp;=world&lt;/code&gt; 的结果为空.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;GET /test?foo&amp;bar&lt;/code&gt; will yield:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102830Z" changeid="xf">
        <seg>&lt;code&gt;GET /test?foo&amp;bar&lt;/code&gt; 的结果:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;POST /test&lt;/code&gt; with body &lt;code&gt;=hello&amp;=world&lt;/code&gt; will yield empty outputs for instance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013431Z" changeid="xf">
        <seg>例如，以请求体&lt;code&gt;=hello&amp;=world&lt;/code&gt;发送&lt;code&gt;POST /test&lt;/code&gt; 将获得空白输出.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;POST /test&lt;/code&gt; with request body &lt;code&gt;foo=&amp;bar=&lt;/code&gt; will return something like</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013352Z" changeid="xf">
        <seg>以请求体&lt;code&gt;foo=&amp;bar=&lt;/code&gt;发送 &lt;code&gt;POST /test&lt;/code&gt;请求将返回</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;ngx.flush&lt;/code&gt; accepts an optional boolean &lt;code&gt;wait&lt;/code&gt; argument (Default: &lt;code&gt;false&lt;/code&gt;) first introduced in the &lt;code&gt;v0.3.1rc34&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041932Z" changeid="xf">
        <seg>&lt;code&gt;ngx.flush&lt;/code&gt; 接受可选的 boolean &lt;code&gt;wait&lt;/code&gt; 参数(默认值: &lt;code&gt;false&lt;/code&gt;)，从 &lt;code&gt;v0.3.1rc34&lt;/code&gt; 版本开始引入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;res.body&lt;/code&gt; holds the subrequest's response body data, which might be truncated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041151Z" changeid="xf">
        <seg>&lt;code&gt;res.body&lt;/code&gt; 保存子请求响应体数据，有可能被截断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;res.header&lt;/code&gt; holds all the response headers of the
subrequest and it is a normal Lua table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041006Z" changeid="xf">
        <seg>&lt;code&gt;res.header&lt;/code&gt; 的值是子请求的所有响应头，这是一个正常的Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>&lt;code&gt;res.status&lt;/code&gt; holds the response status code for the subrequest response.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040946Z" changeid="xf">
        <seg>&lt;code&gt;res.status&lt;/code&gt; 的值是子请求响应的响应状态码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Bugs and Patches =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T054054Z" changeid="xf">
        <seg>= Bug与补丁 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Changes =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031918Z" changeid="xf">
        <seg>= 变动 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Code Repository =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032708Z" changeid="xf">
        <seg>= 代码仓库 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Community =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032234Z" changeid="xf">
        <seg>= 社区 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Data Sharing within an Nginx Worker =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040706Z" changeid="xf">
        <seg>= 在一个Nginx Worker进程内部共享数据 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Description =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T040559Z" changeid="xf">
        <seg>= 说明 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Directives =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041653Z" changeid="xf">
        <seg>= 命令 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= HTTP 1.0 support =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040118Z" changeid="xf">
        <seg>= HTTP 1.0 支持 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Installation =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032537Z" changeid="xf">
        <seg>= 安装 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Known Issues =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T023626Z" changeid="xf">
        <seg>= 已知问题 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Lua/LuaJIT bytecode support =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035436Z" changeid="xf">
        <seg>= Lua/LuaJIT 字节码支持 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Name =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T071838Z" changeid="xf">
        <seg>= 名称 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Nginx API for Lua =
== Introduction ==
The various &lt;code&gt;*_by_lua&lt;/code&gt; and &lt;code&gt;*_by_lua_file&lt;/code&gt; configuration directives serve as gateways to the Lua API within the &lt;code&gt;nginx.conf&lt;/code&gt; file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023520Z" changeid="xf">
        <seg>= 可供Lua调用的Nginx API =
== 简介 ==
各种 &lt;code&gt;*_by_lua&lt;/code&gt; and &lt;code&gt;*_by_lua_file&lt;/code&gt; 配置命令的作用是在&lt;code&gt;nginx.conf&lt;/code&gt;文件内部提供访问Lua API的入口.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Nginx Compatibility =
The latest module is compatible with the following versions of Nginx:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032610Z" changeid="xf">
        <seg>= Nginx 兼容性 =
最新的模块版本兼容以下Nginx版本:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= See Also =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T054210Z" changeid="xf">
        <seg>= 参阅 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Status =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034913Z" changeid="xf">
        <seg>= 状态 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Synopsis =
&lt;geshi lang=&quot;nginx&quot;&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035107Z" changeid="xf">
        <seg>= 示例 =
&lt;geshi lang=&quot;nginx&quot;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Test Suite =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031957Z" changeid="xf">
        <seg>= 测试包 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Typical Uses =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031821Z" changeid="xf">
        <seg>= 典型用法 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>= Version =</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034958Z" changeid="xf">
        <seg>= 版本 =</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== Chinese Mailing List ==</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032223Z" changeid="xf">
        <seg>== 中文邮件列表 ==</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== Core constants ==
'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, *log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032827Z" changeid="xf">
        <seg>== 核心常量 ==
'''可包含于:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, *log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== English Mailing List ==</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032202Z" changeid="xf">
        <seg>== 英文邮件列表 ==</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== HTTP method constants ==
'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033148Z" changeid="xf">
        <seg>== HTTP 请求方法常量 ==
'''可包含于:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== HTTP status constants ==
'''context:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033525Z" changeid="xf">
        <seg>== HTTP status constants ==
'''可包含于:''' ''init_by_lua*, set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== Installation on Ubuntu 11.10 ==</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032256Z" changeid="xf">
        <seg>== 在 Ubuntu 11.10 上安装 ==</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== Locations Configured by Subrequest Directives of Other Modules ==
The [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] directives cannot capture locations that include the [[HttpEchoModule#echo_location|echo_location]], [[HttpEchoModule#echo_location_async|echo_location_async]], [[HttpEchoModule#echo_subrequest|echo_subrequest]], or [[HttpEchoModule#echo_subrequest_async|echo_subrequest_async]] directives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T030805Z" changeid="xf">
        <seg>== 由子请求命令或其它模块配置的Location ==
[[#ngx.location.capture|ngx.location.capture]] 和 [[#ngx.location.capture_multi|ngx.location.capture_multi]] 命令不能获取包含 [[HttpEchoModule#echo_location|echo_location]], [[HttpEchoModule#echo_location_async|echo_location_async]], [[HttpEchoModule#echo_subrequest|echo_subrequest]], 或 [[HttpEchoModule#echo_subrequest_async|echo_subrequest_async]] 命令的location.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== Lua Coroutine Yielding/Resuming ==
* Lua's &lt;code&gt;dofile&lt;/code&gt; builtin is implemented as a C function in both Lua 5.1 and LuaJIT 2.0 and when [[#ngx.location.capture|ngx.location.capture]] is called, [[#ngx.exec|ngx.exec]], [[#ngx.exit|ngx.exit]] or [[#ngx.req.read_body|ngx.req.read_body]] or similar in the file to be loaded by &lt;code&gt;dofile&lt;/code&gt;, a coroutine yield across the C function boundary will be initiated.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T025303Z" changeid="xf">
        <seg>== Lua Coroutine 的挂起/恢复 ==
* Lua内置的 &lt;code&gt;dofile&lt;/code&gt; 在Lua 5.1和LuaJIT2.0中都是用 C 函数实现的， 如果在将被&lt;code&gt;dofile&lt;/code&gt;加载的文件中调用了[[#ngx.location.capture|ngx.location.capture]], [[#ngx.exec|ngx.exec]], [[#ngx.exit|ngx.exit]] or [[#ngx.req.read_body|ngx.req.read_body]] , 将导致跨越C函数边界的coroutine挂起.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== Lua Variable Scope ==
Care must be taken when importing modules and this form should be used:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T025650Z" changeid="xf">
        <seg>== Lua 变量作用域 ==
在导入模块时需要小心，应该使用这种形式:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== Nginx log level constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033551Z" changeid="xf">
        <seg>== Nginx 日志级别常量 ==
'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== Special PCRE Sequences ==
PCRE sequences such as &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, or &lt;code&gt;\w&lt;/code&gt;, require special attention because in string literals, the backslash character, &lt;code&gt;\&lt;/code&gt;, is stripped out by both the Lua language parser and by the Nginx config file parser before processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031011Z" changeid="xf">
        <seg>== 特殊PCRE序列 ==
PCRE sequences such as &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, or &lt;code&gt;\w&lt;/code&gt;这样的PCRE序列需要引起特别的重视，因为在字符串写法里， &lt;code&gt;\&lt;/code&gt;会被Lua语言解析器和Nginx配置文件解析器在开始处理前删掉.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== TCP socket connect operation issues ==
The [[#tcpsock:connect|tcpsock:connect]] method may indicate &lt;code&gt;success&lt;/code&gt; despite connection failures such as with &lt;code&gt;Connection Refused&lt;/code&gt; errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T024356Z" changeid="xf">
        <seg>== TCP socket 连接操作问题 ==
[[#tcpsock:connect|tcpsock:connect]] 方法可能在连接失败如&lt;code&gt;Connection Refused&lt;/code&gt;时返回 &lt;code&gt;success&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== coroutine.create ==
'''syntax:''' ''co = coroutine.create(f)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035009Z" changeid="xf">
        <seg>== coroutine.create ==
'''语法:''' ''co = coroutine.create(f)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== coroutine.resume ==
'''syntax:''' ''ok, ... = coroutine.resume(co, ...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035114Z" changeid="xf">
        <seg>== coroutine.resume ==
'''语法:''' ''ok, ... = coroutine.resume(co, ...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== coroutine.running ==
'''syntax:''' ''co = coroutine.running()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035343Z" changeid="xf">
        <seg>== coroutine.running ==
'''语法:''' ''co = coroutine.running()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== coroutine.status ==
'''syntax:''' ''status = coroutine.status(co)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035411Z" changeid="xf">
        <seg>== coroutine.status ==
'''语法:''' ''status = coroutine.status(co)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== coroutine.wrap ==
'''syntax:''' ''co = coroutine.wrap(f)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035316Z" changeid="xf">
        <seg>== coroutine.wrap ==
'''语法:''' ''co = coroutine.wrap(f)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== coroutine.yield ==
'''syntax:''' ''... = coroutine.yield(co, ...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035232Z" changeid="xf">
        <seg>== coroutine.yield ==
'''语法:''' ''... = coroutine.yield(co, ...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== lua_code_cache ==
'''syntax:''' ''lua_code_cache on | off''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041947Z" changeid="xf">
        <seg>== lua_code_cache ==
'''语法:''' ''lua_code_cache on | off''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== lua_regex_cache_max_entries ==
'''syntax:''' ''lua_regex_cache_max_entries &lt;num&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T053917Z" changeid="xf">
        <seg>== lua_regex_cache_max_entries ==
'''语法:''' ''lua_regex_cache_max_entries &lt;num&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== lua_regex_match_limit ==
'''syntax:''' ''lua_regex_match_limit &lt;num&gt;''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060238Z" changeid="xf">
        <seg>== lua_regex_match_limit ==
'''语法:''' ''lua_regex_match_limit &lt;num&gt;''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ndk.set_var.DIRECTIVE ==
'''syntax:''' ''res = ndk.set_var.DIRECTIVE_NAME''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041951Z" changeid="xf">
        <seg>== ndk.set_var.DIRECTIVE ==
'''语法:''' ''res = ndk.set_var.DIRECTIVE_NAME''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.arg ==
'''syntax:''' ''val = ngx.arg[index]''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024446Z" changeid="xf">
        <seg>== ngx.arg ==
'''语法:''' ''val = ngx.arg[index]''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.cookie_time ==
'''syntax:''' ''str = ngx.cookie_time(sec)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022431Z" changeid="xf">
        <seg>== ngx.cookie_time ==
'''语法:''' ''str = ngx.cookie_time(sec)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.crc32_long ==
'''syntax:''' ''intval = ngx.crc32_long(str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020947Z" changeid="xf">
        <seg>== ngx.crc32_long ==
'''语法:''' ''intval = ngx.crc32_long(str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.crc32_short ==
'''syntax:''' ''intval = ngx.crc32_short(str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020702Z" changeid="xf">
        <seg>== ngx.crc32_short ==
'''语法:''' ''intval = ngx.crc32_short(str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.ctx ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034410Z" changeid="xf">
        <seg>== ngx.ctx ==
'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*, ngx.timer.*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.decode_args ==
'''syntax:''' ''table = ngx.decode_args(str, max_args?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020348Z" changeid="xf">
        <seg>== ngx.decode_args ==
'''语法:''' ''table = ngx.decode_args(str, max_args?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.decode_base64 ==
'''syntax:''' ''newstr = ngx.decode_base64(str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020620Z" changeid="xf">
        <seg>== ngx.decode_base64 ==
'''语法:''' ''newstr = ngx.decode_base64(str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.encode_args ==
'''syntax:''' ''str = ngx.encode_args(table)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020038Z" changeid="xf">
        <seg>== ngx.encode_args ==
'''语法:''' ''str = ngx.encode_args(table)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.encode_base64 ==
'''syntax:''' ''newstr = ngx.encode_base64(str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020557Z" changeid="xf">
        <seg>== ngx.encode_base64 ==
'''语法:''' ''newstr = ngx.encode_base64(str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.eof ==
'''syntax:''' ''ok, err = ngx.eof()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015234Z" changeid="xf">
        <seg>== ngx.eof ==
'''语法:''' ''ok, err = ngx.eof()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.escape_uri ==
'''syntax:''' ''newstr = ngx.escape_uri(str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015947Z" changeid="xf">
        <seg>== ngx.escape_uri ==
'''语法:''' ''newstr = ngx.escape_uri(str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.exec ==
'''syntax:''' ''ngx.exec(uri, args?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032243Z" changeid="xf">
        <seg>== ngx.exec ==
'''语法:''' ''ngx.exec(uri, args?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.exit ==
'''syntax:''' ''ngx.exit(status)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042435Z" changeid="xf">
        <seg>== ngx.exit ==
'''语法:''' ''ngx.exit(status)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.flush ==
'''syntax:''' ''ok, err = ngx.flush(wait?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041750Z" changeid="xf">
        <seg>== ngx.flush ==
'''语法:''' ''ok, err = ngx.flush(wait?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.get_phase ==
'''syntax:''' ''str = ngx.get_phase()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102623Z" changeid="xf">
        <seg>== ngx.get_phase ==
'''语法:''' ''str = ngx.get_phase()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.header.HEADER ==
'''syntax:''' ''ngx.header.HEADER = VALUE''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083750Z" changeid="xf">
        <seg>== ngx.header.HEADER ==
'''语法:''' ''ngx.header.HEADER = VALUE''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.headers_sent ==
'''syntax:''' ''value = ngx.headers_sent''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040439Z" changeid="xf">
        <seg>== ngx.headers_sent ==
'''语法:''' ''value = ngx.headers_sent''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.hmac_sha1 ==
'''syntax:''' ''digest = ngx.hmac_sha1(secret_key, str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021058Z" changeid="xf">
        <seg>== ngx.hmac_sha1 ==
'''语法:''' ''digest = ngx.hmac_sha1(secret_key, str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.http_time ==
'''syntax:''' ''str = ngx.http_time(sec)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022650Z" changeid="xf">
        <seg>== ngx.http_time ==
'''语法:''' ''str = ngx.http_time(sec)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.is_subrequest ==
'''syntax:''' ''value = ngx.is_subrequest''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022855Z" changeid="xf">
        <seg>== ngx.is_subrequest ==
'''语法:''' ''value = ngx.is_subrequest''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.localtime ==
'''syntax:''' ''str = ngx.localtime()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022316Z" changeid="xf">
        <seg>== ngx.localtime ==
'''语法:''' ''str = ngx.localtime()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.location.capture ==
'''syntax:''' ''res = ngx.location.capture(uri, options?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035830Z" changeid="xf">
        <seg>== ngx.location.capture ==
'''语法:''' ''res = ngx.location.capture(uri, options?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.location.capture_multi ==
'''syntax:''' ''res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082750Z" changeid="xf">
        <seg>== ngx.location.capture_multi ==
'''语法:''' ''res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.log ==
'''syntax:''' ''ngx.log(log_level, ...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041545Z" changeid="xf">
        <seg>== ngx.log ==
'''语法:''' ''ngx.log(log_level, ...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.md5 ==
'''syntax:''' ''digest = ngx.md5(str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021448Z" changeid="xf">
        <seg>== ngx.md5 ==
'''语法:''' ''digest = ngx.md5(str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.md5_bin ==
'''syntax:''' ''digest = ngx.md5_bin(str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021601Z" changeid="xf">
        <seg>== ngx.md5_bin ==
'''语法:''' ''digest = ngx.md5_bin(str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.now ==
'''syntax:''' ''secs = ngx.now()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022133Z" changeid="xf">
        <seg>== ngx.now ==
'''语法:''' ''secs = ngx.now()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.on_abort ==
'''syntax:''' ''ok, err = ngx.on_abort(callback)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021248Z" changeid="xf">
        <seg>== ngx.on_abort ==
'''语法:''' ''ok, err = ngx.on_abort(callback)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.parse_http_time ==
'''syntax:''' ''sec = ngx.parse_http_time(str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022753Z" changeid="xf">
        <seg>== ngx.parse_http_time ==
'''语法:''' ''sec = ngx.parse_http_time(str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.print ==
'''syntax:''' ''ok, err = ngx.print(...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040810Z" changeid="xf">
        <seg>== ngx.print ==
'''语法:''' ''ok, err = ngx.print(...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.quote_sql_str ==
'''syntax:''' ''quoted_value = ngx.quote_sql_str(raw_value)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021805Z" changeid="xf">
        <seg>== ngx.quote_sql_str ==
'''语法:''' ''quoted_value = ngx.quote_sql_str(raw_value)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.re.gmatch ==
'''syntax:''' ''iterator, err = ngx.re.gmatch(subject, regex, options?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025700Z" changeid="xf">
        <seg>== ngx.re.gmatch ==
'''语法:''' ''iterator, err = ngx.re.gmatch(subject, regex, options?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.re.gsub ==
'''syntax:''' ''newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032904Z" changeid="xf">
        <seg>== ngx.re.gsub ==
'''语法:''' ''newstr, n, err = ngx.re.gsub(subject, regex, replace, options?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.re.match ==
'''syntax:''' ''captures, err = ngx.re.match(subject, regex, options?, ctx?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022921Z" changeid="xf">
        <seg>== ngx.re.match ==
'''语法:''' ''captures, err = ngx.re.match(subject, regex, options?, ctx?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.re.sub ==
'''syntax:''' ''newstr, n, err = ngx.re.sub(subject, regex, replace, options?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T030154Z" changeid="xf">
        <seg>== ngx.re.sub ==
'''语法:''' ''newstr, n, err = ngx.re.sub(subject, regex, replace, options?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.redirect ==
'''syntax:''' ''ngx.redirect(uri, status?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034226Z" changeid="xf">
        <seg>== ngx.redirect ==
'''语法:''' ''ngx.redirect(uri, status?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.append_body ==
'''syntax:''' ''ngx.req.append_body(data_chunk)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030913Z" changeid="xf">
        <seg>== ngx.req.append_body ==
'''语法:''' ''ngx.req.append_body(data_chunk)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.clear_header ==
'''syntax:''' ''ngx.req.clear_header(header_name)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021231Z" changeid="xf">
        <seg>== ngx.req.clear_header ==
'''语法:''' ''ngx.req.clear_header(header_name)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.discard_body ==
'''syntax:''' ''ngx.req.discard_body()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022555Z" changeid="xf">
        <seg>== ngx.req.discard_body ==
'''语法:''' ''ngx.req.discard_body()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.finish_body ==
'''syntax:''' ''ngx.req.finish_body()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031045Z" changeid="xf">
        <seg>== ngx.req.finish_body ==
'''语法:''' ''ngx.req.finish_body()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.get_body_data ==
'''syntax:''' ''data = ngx.req.get_body_data()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023007Z" changeid="xf">
        <seg>== ngx.req.get_body_data ==
'''语法:''' ''data = ngx.req.get_body_data()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.get_body_file ==
'''syntax:''' ''file_name = ngx.req.get_body_file()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023531Z" changeid="xf">
        <seg>== ngx.req.get_body_file ==
'''语法:''' ''file_name = ngx.req.get_body_file()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.get_method ==
'''syntax:''' ''method_name = ngx.req.get_method()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095342Z" changeid="xf">
        <seg>== ngx.req.get_method ==
'''语法:''' ''method_name = ngx.req.get_method()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.get_post_args ==
'''syntax:''' ''args, err = ngx.req.get_post_args(max_args?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103351Z" changeid="xf">
        <seg>== ngx.req.get_post_args ==
'''语法:''' ''args, err = ngx.req.get_post_args(max_args?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.get_uri_args ==
'''syntax:''' ''args = ngx.req.get_uri_args(max_args?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102527Z" changeid="xf">
        <seg>== ngx.req.get_uri_args ==
'''语法:''' ''args = ngx.req.get_uri_args(max_args?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.http_version ==
'''syntax:''' ''num = ngx.req.http_version()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094405Z" changeid="xf">
        <seg>== ngx.req.http_version ==
'''语法:''' ''num = ngx.req.http_version()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.init_body ==
'''syntax:''' ''ngx.req.init_body(buffer_size?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024333Z" changeid="xf">
        <seg>== ngx.req.init_body ==
'''语法:''' ''ngx.req.init_body(buffer_size?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.raw_header ==
'''syntax:''' ''str = ngx.req.raw_header(no_request_line?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095149Z" changeid="xf">
        <seg>== ngx.req.raw_header ==
'''语法:''' ''str = ngx.req.raw_header(no_request_line?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.read_body ==
'''syntax:''' ''ngx.req.read_body()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021301Z" changeid="xf">
        <seg>== ngx.req.read_body ==
'''语法:''' ''ngx.req.read_body()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_body_data ==
'''syntax:''' ''ngx.req.set_body_data(data)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023813Z" changeid="xf">
        <seg>== ngx.req.set_body_data ==
'''语法:''' ''ngx.req.set_body_data(data)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_body_file ==
'''syntax:''' ''ngx.req.set_body_file(file_name, auto_clean?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024046Z" changeid="xf">
        <seg>== ngx.req.set_body_file ==
'''语法:''' ''ngx.req.set_body_file(file_name, auto_clean?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_header ==
'''syntax:''' ''ngx.req.set_header(header_name, header_value)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020723Z" changeid="xf">
        <seg>== ngx.req.set_header ==
'''语法:''' ''ngx.req.set_header(header_name, header_value)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_method ==
'''syntax:''' ''ngx.req.set_method(method_id)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095529Z" changeid="xf">
        <seg>== ngx.req.set_method ==
'''语法:''' ''ngx.req.set_method(method_id)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_uri ==
'''syntax:''' ''ngx.req.set_uri(uri, jump?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095703Z" changeid="xf">
        <seg>== ngx.req.set_uri ==
'''语法:''' ''ngx.req.set_uri(uri, jump?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.set_uri_args ==
'''syntax:''' ''ngx.req.set_uri_args(args)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102238Z" changeid="xf">
        <seg>== ngx.req.set_uri_args ==
'''语法:''' ''ngx.req.set_uri_args(args)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.socket ==
'''syntax:''' ''tcpsock, err = ngx.req.socket()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031229Z" changeid="xf">
        <seg>== ngx.req.socket ==
'''语法:''' ''tcpsock, err = ngx.req.socket()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.req.start_time ==
'''syntax:''' ''secs = ngx.req.start_time()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091413Z" changeid="xf">
        <seg>== ngx.req.start_time ==
'''语法:''' ''secs = ngx.req.start_time()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.say ==
'''syntax:''' ''ok, err = ngx.say(...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041515Z" changeid="xf">
        <seg>== ngx.say ==
'''语法:''' ''ok, err = ngx.say(...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.send_headers ==
'''syntax:''' ''ok, err = ngx.send_headers()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040144Z" changeid="xf">
        <seg>== ngx.send_headers ==
'''语法:''' ''ok, err = ngx.send_headers()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.sha1_bin ==
'''syntax:''' ''digest = ngx.sha1_bin(str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021651Z" changeid="xf">
        <seg>== ngx.sha1_bin ==
'''语法:''' ''digest = ngx.sha1_bin(str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT ==
'''syntax:''' ''dict = ngx.shared.DICT''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T033010Z" changeid="xf">
        <seg>== ngx.shared.DICT ==
'''语法:''' ''dict = ngx.shared.DICT''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.add ==
'''syntax:''' ''success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054618Z" changeid="xf">
        <seg>== ngx.shared.DICT.add ==
'''语法:''' ''success, err, forcible = ngx.shared.DICT:add(key, value, exptime?, flags?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.delete ==
'''syntax:''' ''ngx.shared.DICT:delete(key)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T055217Z" changeid="xf">
        <seg>== ngx.shared.DICT.delete ==
'''语法:''' ''ngx.shared.DICT:delete(key)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.flush_all ==
'''syntax:''' ''ngx.shared.DICT:flush_all()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060331Z" changeid="xf">
        <seg>== ngx.shared.DICT.flush_all ==
'''语法:''' ''ngx.shared.DICT:flush_all()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.flush_expired ==
'''syntax:''' ''flushed = ngx.shared.DICT:flush_expired(max_count?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060511Z" changeid="xf">
        <seg>== ngx.shared.DICT.flush_expired ==
'''语法:''' ''flushed = ngx.shared.DICT:flush_expired(max_count?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.get ==
'''syntax:''' ''value, flags = ngx.shared.DICT:get(key)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034239Z" changeid="xf">
        <seg>== ngx.shared.DICT.get ==
'''语法:''' ''value, flags = ngx.shared.DICT:get(key)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.get_keys ==
'''syntax:''' ''keys = ngx.shared.DICT:get_keys(max_count?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060713Z" changeid="xf">
        <seg>== ngx.shared.DICT.get_keys ==
'''语法:''' ''keys = ngx.shared.DICT:get_keys(max_count?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.get_stale ==
'''syntax:''' ''value, flags, stale = ngx.shared.DICT:get_stale(key)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034613Z" changeid="xf">
        <seg>== ngx.shared.DICT.get_stale ==
'''语法:''' ''value, flags, stale = ngx.shared.DICT:get_stale(key)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.incr ==
'''syntax:''' ''newval, err = ngx.shared.DICT:incr(key, value)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T055304Z" changeid="xf">
        <seg>== ngx.shared.DICT.incr ==
'''语法:''' ''newval, err = ngx.shared.DICT:incr(key, value)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.replace ==
'''syntax:''' ''success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054931Z" changeid="xf">
        <seg>== ngx.shared.DICT.replace ==
'''语法:''' ''success, err, forcible = ngx.shared.DICT:replace(key, value, exptime?, flags?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.safe_add ==
'''syntax:''' ''ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054758Z" changeid="xf">
        <seg>== ngx.shared.DICT.safe_add ==
'''语法:''' ''ok, err = ngx.shared.DICT:safe_add(key, value, exptime?, flags?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.safe_set ==
'''syntax:''' ''ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054408Z" changeid="xf">
        <seg>== ngx.shared.DICT.safe_set ==
'''语法:''' ''ok, err = ngx.shared.DICT:safe_set(key, value, exptime?, flags?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.shared.DICT.set ==
'''syntax:''' ''success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034904Z" changeid="xf">
        <seg>== ngx.shared.DICT.set ==
'''语法:''' ''success, err, forcible = ngx.shared.DICT:set(key, value, exptime?, flags?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.sleep ==
'''syntax:''' ''ngx.sleep(seconds)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015804Z" changeid="xf">
        <seg>== ngx.sleep ==
'''语法:''' ''ngx.sleep(seconds)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.socket.connect ==
'''syntax:''' ''tcpsock, err = ngx.socket.connect(host, port)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102442Z" changeid="xf">
        <seg>== ngx.socket.connect ==
'''语法:''' ''tcpsock, err = ngx.socket.connect(host, port)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.socket.tcp ==
'''syntax:''' ''tcpsock = ngx.socket.tcp()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074136Z" changeid="xf">
        <seg>== ngx.socket.tcp ==
'''语法:''' ''tcpsock = ngx.socket.tcp()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.socket.udp ==
'''syntax:''' ''udpsock = ngx.socket.udp()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T061006Z" changeid="xf">
        <seg>== ngx.socket.udp ==
'''语法:''' ''udpsock = ngx.socket.udp()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.status ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083555Z" changeid="xf">
        <seg>== ngx.status ==
'''可包含于:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*, body_filter_by_lua, log_by_lua*''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.thread.spawn ==
'''syntax:''' ''co = ngx.thread.spawn(func, arg1, arg2, ...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102907Z" changeid="xf">
        <seg>== ngx.thread.spawn ==
'''语法:''' ''co = ngx.thread.spawn(func, arg1, arg2, ...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.thread.wait ==
'''syntax:''' ''ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020636Z" changeid="xf">
        <seg>== ngx.thread.wait ==
'''语法:''' ''ok, res1, res2, ... = ngx.thread.wait(thread1, thread2, ...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.time ==
'''syntax:''' ''secs = ngx.time()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021957Z" changeid="xf">
        <seg>== ngx.time ==
'''语法:''' ''secs = ngx.time()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.timer.at ==
'''syntax:''' ''ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021941Z" changeid="xf">
        <seg>== ngx.timer.at ==
'''语法:''' ''ok, err = ngx.timer.at(delay, callback, user_arg1, user_arg2, ...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.today ==
'''syntax:''' ''str = ngx.today()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021857Z" changeid="xf">
        <seg>== ngx.today ==
'''语法:''' ''str = ngx.today()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.unescape_uri ==
'''syntax:''' ''newstr = ngx.unescape_uri(str)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020012Z" changeid="xf">
        <seg>== ngx.unescape_uri ==
'''语法:''' ''newstr = ngx.unescape_uri(str)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.update_time ==
'''syntax:''' ''ngx.update_time()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022239Z" changeid="xf">
        <seg>== ngx.update_time ==
'''语法:''' ''ngx.update_time()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.utctime ==
'''syntax:''' ''str = ngx.utctime()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022415Z" changeid="xf">
        <seg>== ngx.utctime ==
'''语法:''' ''str = ngx.utctime()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== ngx.var.VARIABLE ==
'''syntax:''' ''ngx.var.VAR_NAME''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032025Z" changeid="xf">
        <seg>== ngx.var.VARIABLE ==
'''语法:''' ''ngx.var.VAR_NAME''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== print ==
'''syntax:''' ''print(...)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033734Z" changeid="xf">
        <seg>== print ==
'''语法:''' ''print(...)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== set_by_lua_file ==
'''syntax:''' ''set_by_lua_file $res &lt;path-to-lua-script-file&gt; [$arg1 $arg2 ...]''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073346Z" changeid="xf">
        <seg>== set_by_lua_file ==
'''语法:''' ''set_by_lua_file $res &lt;path-to-lua-script-file&gt; [$arg1 $arg2 ...]''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== tcpsock:close ==
'''syntax:''' ''ok, err = tcpsock:close()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T100625Z" changeid="xf">
        <seg>== tcpsock:close ==
'''语法:''' ''ok, err = tcpsock:close()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== tcpsock:connect ==
'''syntax:''' ''ok, err = tcpsock:connect(host, port, options_table?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074313Z" changeid="xf">
        <seg>== tcpsock:connect ==
'''语法:''' ''ok, err = tcpsock:connect(host, port, options_table?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== tcpsock:getreusedtimes ==
'''syntax:''' ''count, err = tcpsock:getreusedtimes()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102218Z" changeid="xf">
        <seg>== tcpsock:getreusedtimes ==
'''语法:''' ''count, err = tcpsock:getreusedtimes()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== tcpsock:receive ==
'''syntax:''' ''data, err, partial = tcpsock:receive(size)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T083129Z" changeid="xf">
        <seg>== tcpsock:receive ==
'''语法:''' ''data, err, partial = tcpsock:receive(size)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== tcpsock:receiveuntil ==
'''syntax:''' ''iterator = tcpsock:receiveuntil(pattern, options?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T090208Z" changeid="xf">
        <seg>== tcpsock:receiveuntil ==
'''语法:''' ''iterator = tcpsock:receiveuntil(pattern, options?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== tcpsock:send ==
'''syntax:''' ''bytes, err = tcpsock:send(data)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T075029Z" changeid="xf">
        <seg>== tcpsock:send ==
'''语法:''' ''bytes, err = tcpsock:send(data)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== tcpsock:setkeepalive ==
'''syntax:''' ''ok, err = tcpsock:setkeepalive(timeout?, size?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101312Z" changeid="xf">
        <seg>== tcpsock:setkeepalive ==
'''语法:''' ''ok, err = tcpsock:setkeepalive(timeout?, size?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== tcpsock:setoption ==
'''syntax:''' ''tcpsock:setoption(option, value?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101228Z" changeid="xf">
        <seg>== tcpsock:setoption ==
'''语法:''' ''tcpsock:setoption(option, value?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== tcpsock:settimeout ==
'''syntax:''' ''tcpsock:settimeout(time)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T100819Z" changeid="xf">
        <seg>== tcpsock:settimeout ==
'''语法:''' ''tcpsock:settimeout(time)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== udpsock:close ==
'''syntax:''' ''ok, err = udpsock:close()''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073728Z" changeid="xf">
        <seg>== udpsock:close ==
'''语法:''' ''ok, err = udpsock:close()''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== udpsock:receive ==
'''syntax:''' ''data, err = udpsock:receive(size?)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T071927Z" changeid="xf">
        <seg>== udpsock:receive ==
'''语法:''' ''data, err = udpsock:receive(size?)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== udpsock:send ==
'''syntax:''' ''ok, err = udpsock:send(data)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T070134Z" changeid="xf">
        <seg>== udpsock:send ==
'''语法:''' ''ok, err = udpsock:send(data)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== udpsock:setpeername ==
'''syntax:''' ''ok, err = udpsock:setpeername(host, port)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065040Z" changeid="xf">
        <seg>== udpsock:setpeername ==
'''语法:''' ''ok, err = udpsock:setpeername(host, port)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>== udpsock:settimeout ==
'''syntax:''' ''udpsock:settimeout(time)''</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074012Z" changeid="xf">
        <seg>== udpsock:settimeout ==
'''语法:''' ''udpsock:settimeout(time)''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A &quot;light thread&quot; will keep running exclusively on the CPU until
# a (nonblocking) I/O operation cannot be completed in a single run,
# it calls [[#coroutine.yield|coroutine.yield]] to actively give up execution, or
# it is aborted by a Lua error or an invocation of [[#ngx.exit|ngx.exit]], [[#ngx.exec|ngx.exec]], [[#ngx.redirect|ngx.redirect]], or [[#ngx.req.set_uri|ngx.req.set_uri(uri, true)]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T015446Z" changeid="xf">
        <seg>一个 &quot;轻量线程&quot; 将独占cpu运行，直到
# 无法在单独一次运行中完成一个 (非阻塞的) I/O 操作,
# 它调用 [[#coroutine.yield|coroutine.yield]] 主动放弃执行, 或
# 由于Lua错误或调用 [[#ngx.exit|ngx.exit]], [[#ngx.exec|ngx.exec]], [[#ngx.redirect|ngx.redirect]], 或 [[#ngx.req.set_uri|ngx.req.set_uri(uri, true)]]而中断.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A lot of the Lua APIs for Nginx are enabled in the context of the timer
callbacks, like stream/datagram cosockets ([[#ngx.socket.tcp|ngx.socket.tcp]] and [[#ngx.socket.udp|ngx.socket.udp]]), shared
memory dictionaries ([[#ngx.shared.DICT|ngx.shared.DICT]]), user coroutines ([[#coroutine.create|coroutine.*]]),
user &quot;light threads&quot; ([[#ngx.thread.spawn|ngx.thread.*]]), [[#ngx.exit|ngx.exit]], [[#ngx.now|ngx.now]]/[[#ngx.time|ngx.time]],
[[#ngx.md5|ngx.md5]]/[[#ngx.sha1_bin|ngx.sha1_bin]], are all allowed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T043135Z" changeid="xf">
        <seg>在定时器回调函数中可以使用很多供Nginx使用的Lua API, 如流/数据报 cosocket ([[#ngx.socket.tcp|ngx.socket.tcp]] 和 [[#ngx.socket.udp|ngx.socket.udp]]), 共享内存字典 ([[#ngx.shared.DICT|ngx.shared.DICT]]), 用户coroutine ([[#coroutine.create|coroutine.*]]),
用户 &quot;轻量线程&quot; ([[#ngx.thread.spawn|ngx.thread.*]]), [[#ngx.exit|ngx.exit]], [[#ngx.now|ngx.now]]/[[#ngx.time|ngx.time]],
[[#ngx.md5|ngx.md5]]/[[#ngx.sha1_bin|ngx.sha1_bin]], 都可以使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A more sophisticated example involving regex substitutions is as follows</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102121Z" changeid="xf">
        <seg>下面是一个更复杂的包含正则替换的例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A notable exception here is that you can abort pending subrequests by calling [[#ngx.exit|ngx.exit]] with and only with the status code &lt;code&gt;ngx.ERROR&lt;/code&gt; (-1), &lt;code&gt;408&lt;/code&gt;, &lt;code&gt;444&lt;/code&gt;, or &lt;code&gt;499&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T015046Z" changeid="xf">
        <seg>这里有个例外是你可以使用状态码&lt;code&gt;ngx.ERROR&lt;/code&gt; (-1)，&lt;code&gt;408&lt;/code&gt;, &lt;code&gt;444&lt;/code&gt;, or &lt;code&gt;499&lt;/code&gt;来调用[[#ngx.exitngx.exit]]从而中断某个子请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Accessing &lt;code&gt;/lua&lt;/code&gt; will yield the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T080725Z" changeid="xf">
        <seg>访问 &lt;code&gt;/lua&lt;/code&gt; 的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to the current implementation, each &quot;running timer&quot; will
take one (fake) connection record from the global connection record
list configured by the standard [[EventsModule#worker_connections|worker_connections]] directive in
&lt;code&gt;nginx.conf&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042828Z" changeid="xf">
        <seg>按照当前的实现，每个 &quot;运行中定时器&quot; 将在&lt;code&gt;nginx.conf&lt;/code&gt;中用标准[[EventsModule#worker_connectionsworker_connections]]配置的连接记录列表中占据一条（假的）连接记录.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via [[#ngx.req.socket|ngx.req.socket]], then ngx_lua will neither stop all the running &quot;light threads&quot; nor call the user callback (if [[#ngx.on_abort|ngx.on_abort]] has been called).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021649Z" changeid="xf">
        <seg>但是，根据当前的实现，如果客户端在Lua代码使用[[#ngx.req.socketngx.req.socket]]读取请求体数据之前就关闭的连接, ngx_lua模块既不会停止所有运行中的 &quot;轻量线程&quot; 也不会调用用户回调 (如果 [[#ngx.on_abort|ngx.on_abort]] 曾经被调用的话).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>According to the current implementation, this function can only be called once in a single request handler; subsequent calls will return the error message &quot;duplicate call&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021924Z" changeid="xf">
        <seg>按当前的实现，此函数只会在一个请求处理器中被调用一次; 再调则返回错误信息 &quot;duplicate call&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acts as a &quot;content handler&quot; and executes Lua code string specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; for every request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073936Z" changeid="xf">
        <seg>作为一个 &quot;content handler&quot;，为每个请求执行 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt;中的代码.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acts as a rewrite phase handler and executes Lua code string specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; for every request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074441Z" changeid="xf">
        <seg>作为一个 rewrite phase handler，为每个请求执行 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; 中的代码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Acts as an access phase handler and executes Lua code string specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; for every request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T081031Z" changeid="xf">
        <seg>作为一个 access phase handler运行，为每个请求执行 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; 中的代码.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After &lt;code&gt;ngx.thread.spawn&lt;/code&gt; returns, the newly-created &quot;light thread&quot; will keep running asynchronously usually at various I/O events.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T014142Z" changeid="xf">
        <seg>&lt;code&gt;ngx.thread.spawn&lt;/code&gt; 返回之后，新创建的 &quot;轻量线程&quot; 将继续异步地执行，通常会响应不同的I/O事件.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All of these directives will run in the same order as they appear in the config file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073153Z" changeid="xf">
        <seg>所有的命令按照它们在配置文件中出现的次序执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the Lua code chunks running by [[#rewrite_by_lua|rewrite_by_lua]], [[#access_by_lua|access_by_lua]], and [[#content_by_lua|content_by_lua]] are in a boilerplate &quot;light thread&quot; created automatically by ngx_lua.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T014259Z" changeid="xf">
        <seg>All the Lua code chunks running by [[#rewrite_by_lua|rewrite_by_lua]], [[#access_by_lua|access_by_lua]], and [[#content_by_lua|content_by_lua]] 运行的所有Lua代码块都运行在一个由ngx_lua自动创建的标准&quot;轻量线程&quot;中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>All the [[#Nginx API for Lua|Nginx API for Lua]] can be used in the callback function because the function is run in a special &quot;light thread&quot;, just as those &quot;light threads&quot; created by [[#ngx.thread.spawn|ngx.thread.spawn]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021539Z" changeid="xf">
        <seg>回调函数中可以使用所有的 [[#Nginx API for Lua|Nginx API for Lua]]，这是因为函数运行于一个特殊的&quot;轻量线程&quot;中，与[[#ngx.thread.spawnngx.thread.spawn]]生成的其它&quot;轻量线程&quot;一样.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Almost all the Nginx modules can be used with this ngx_lua module by means of [[#ngx.location.capture|ngx.location.capture]] or [[#ngx.location.capture_multi|ngx.location.capture_multi]] but it is recommended to use those &lt;code&gt;lua-resty-*&lt;/code&gt; libraries instead of creating subrequests to access the Nginx upstream modules because the former is usually much more flexible and memory-efficient.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T081707Z" changeid="xf">
        <seg>几乎所有的Nginx模块都可以通过 [[#ngx.location.capture|ngx.location.capture]] 或 [[#ngx.location.capture_multi|ngx.location.capture_multi]]来使用ngx_lua模块。但推荐使用 &lt;code&gt;lua-resty-*&lt;/code&gt; 库而不是创建子请求来访问Nginx upstream模块，因为前者通常有高得多的灵活性和内存效率。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that subrequests just mimic the HTTP interface but there is ''no'' extra HTTP/TCP traffic ''nor'' IPC involved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040616Z" changeid="xf">
        <seg>请注意子请求只是模拟了 HTTP 接口，但事实上 ''并没有'' 额外的 HTTP/TCP 流量 ''也没有'' IPC 调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, Lua files which are loaded by &lt;code&gt;dofile&lt;/code&gt; or &lt;code&gt;loadfile&lt;/code&gt;
in *_by_lua_file will never be cached.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T042851Z" changeid="xf">
        <seg>还有，*_by_lua_file中使用 &lt;code&gt;dofile&lt;/code&gt; 或 &lt;code&gt;loadfile&lt;/code&gt;加载的Lua文件决不会被缓存.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, by default, an &lt;code&gt;__index&lt;/code&gt; metamethod is added to the resulting Lua table and will normalize the keys to a pure lowercase form with all underscores converted to dashes in case of a lookup miss.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020546Z" changeid="xf">
        <seg>同样, 默认会为结果Lua table添加一个 &lt;code&gt;__index&lt;/code&gt; 元方法，它会将所有的key都转换成纯小写形式，并且将所有的下划线转换成减号，以防止查找失败。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, we introduce some new APIs to provide more functionalities.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074258Z" changeid="xf">
        <seg>我们还引入了一些新的API来提供更多的功能.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, when this function is used together with [[#ngx.req.socket|ngx.req.socket]], it is required to call [[#ngx.req.socket|ngx.req.socket]] ''before'' this function, or you will get the &quot;request body already exists&quot; error message.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030628Z" changeid="xf">
        <seg>还有，如果此函数与 [[#ngx.req.socket|ngx.req.socket]] 一起使用, 必须在调用此函数之前 ''先'' 调用 [[#ngx.req.socket|ngx.req.socket]] , 否则将出现 &quot;request body already exists&quot; 错误.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, a Lua table can be passed for the &lt;code&gt;args&lt;/code&gt; argument for ngx_lua to carry out URI escaping and string concatenation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032459Z" changeid="xf">
        <seg>或者可以传一个Lua table给 &lt;code&gt;args&lt;/code&gt; 参数，让ngx_lua去完成URI转义和字符串拼接.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, ngx_lua can be manually compiled into Nginx:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032916Z" changeid="xf">
        <seg>也可以手动将ngx_lua编译进Nginx:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatively, the regex pattern can be presented as a long-bracketed Lua string literal by encasing it in &quot;long brackets&quot;, &lt;code&gt;&amp;#91;[...]]&lt;/code&gt;, in which case backslashes have to only be escaped once for the Nginx config file parser.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031342Z" changeid="xf">
        <seg>或者可以将正则表达式写在双方括号里, &lt;code&gt;&amp;#91;[...]]&lt;/code&gt;, 这样反斜线只会被Nginx配置文件处理器转义一次.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An alternative approach to escaping PCRE sequences is to ensure that Lua code is placed in external script files and executed using the various &lt;code&gt;*_by_lua_file&lt;/code&gt; directives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031645Z" changeid="xf">
        <seg>另外一种对PCRE序列进行转义的方法是确保Lua代码放在外部脚本文件里，通过各种 &lt;code&gt;*_by_lua_file&lt;/code&gt; 命令来调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional Lua table can be specified as the last argument to this method to specify various connect options:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074801Z" changeid="xf">
        <seg>可以指定一个可选的Lua table作为最后一个参数来提供各种连接选项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An optional option table can be fed as the second
argument, which supports the options:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041510Z" changeid="xf">
        <seg>可以为第2个可选参数提供一个选项table, 支持如下选项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And below is an example demonstrating the &quot;wait any&quot; model:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021214Z" changeid="xf">
        <seg>下面演示 &quot;wait any&quot; 模式:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And it will generate the following output:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021242Z" changeid="xf">
        <seg>输出:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And the &lt;code&gt;ngx.null&lt;/code&gt; constant will yield the &lt;code&gt;&quot;null&quot;&lt;/code&gt; string output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034047Z" changeid="xf">
        <seg>&lt;code&gt;ngx.null&lt;/code&gt; 常量也写入为 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And the callback function can also decide to terminate everything by calling [[#ngx.exit|ngx.exit]], for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021711Z" changeid="xf">
        <seg>回调函数也可以决定用 [[#ngx.exit|ngx.exit]] 来停止一切, 例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And the latter takes priority.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073538Z" changeid="xf">
        <seg>后者具有更高的优先级.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And this is the default value of this directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060955Z" changeid="xf">
        <seg>0也是这个命令的默认值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And when there is such an event, it will call the user Lua function callback (registered by [[#ngx.on_abort|ngx.on_abort]]) or just stop and clean up all the Lua &quot;light threads&quot; running in the current request's request handler when there is no user callback function registered.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021457Z" changeid="xf">
        <seg>当这种事件发生时，模块将调用用户提供的回调函数 (使用[[#ngx.on_abort|ngx.on_abort]]注册) ，如果用户没有提供回调函数，模块会简单地停止和清除所有在当前请求处理器中的Lua &quot;轻量线程&quot; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Append new data chunk specified by the &lt;code&gt;data_chunk&lt;/code&gt; argument onto the existing request body created by the [[#ngx.req.init_body|ngx.req.init_body]] call.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030947Z" changeid="xf">
        <seg>将 &lt;code&gt;data_chunk&lt;/code&gt; 参数指定的数据块加到用[[#ngx.req.init_bodyngx.req.init_body]]创建的请求体中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arbitrary data values, including Lua closures and nested tables, can be inserted into this &quot;magic&quot; table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035719Z" changeid="xf">
        <seg>任何数据，包括Lua closure和嵌套的table，都可以被放入这个“神奇的”table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Arguments without the &lt;code&gt;=&lt;value&gt;&lt;/code&gt; parts are treated as boolean arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102825Z" changeid="xf">
        <seg>没有 &lt;code&gt;=&lt;value&gt;&lt;/code&gt; 的部分将被视为 boolean 参数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As from the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release, Nginx variable interpolation is disabled in the &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; argument of this directive and therefore, the dollar sign character (&lt;code&gt;$&lt;/code&gt;) can be used directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073321Z" changeid="xf">
        <seg>从 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 起, 本命令中的&lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt;中禁止使用Nginx 变量 interpolation ，因此,(&lt;code&gt;$&lt;/code&gt;)可以直接使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As from the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release, the special notation &lt;code&gt;$prefix&lt;/code&gt; or &lt;code&gt;${prefix}&lt;/code&gt; can be used in the search path string to indicate the path of the &lt;code&gt;server prefix&lt;/code&gt; usually determined by the &lt;code&gt;-p PATH&lt;/code&gt; command-line option while starting the Nginx server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062200Z" changeid="xf">
        <seg>从&lt;code&gt;v0.5.0rc29&lt;/code&gt;版本开始, 特殊标记 &lt;code&gt;$prefix&lt;/code&gt; 或 &lt;code&gt;${prefix}&lt;/code&gt; 可以在路径字符串中用来表示 &lt;code&gt;server prefix&lt;/code&gt; 的路径，它通常可由在Nginx服务器启动时使用 &lt;code&gt;-p PATH&lt;/code&gt; 命令行参数来得到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, all &lt;code&gt;*_by_lua_file&lt;/code&gt; configure directives (such as [[#content_by_lua_file|content_by_lua_file]]) support loading Lua 5.1 and LuaJIT 2.0 raw bytecode files directly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035524Z" changeid="xf">
        <seg>从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 所有 &lt;code&gt;*_by_lua_file&lt;/code&gt; 配置命令(如 [[#content_by_lua_file|content_by_lua_file]]) 支持直接加载Lua 5.1 和 LuaJIT 2.0 原始字节码文件.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As from the &lt;code&gt;v0.5.1&lt;/code&gt; release, this method also takes an optional &lt;code&gt;options&lt;/code&gt; table argument to control the behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T100429Z" changeid="xf">
        <seg>从&lt;code&gt;v0.5.1&lt;/code&gt; 版本起, 本方法还接受可选的 &lt;code&gt;options&lt;/code&gt; table参数来控制行为.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As with other access phase handlers, [[#access_by_lua|access_by_lua]] will ''not'' run in subrequests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094223Z" changeid="xf">
        <seg>与其它的 rewrite phase handlers一样, [[#access_by_luaaccess_by_lua]]也''不会''运行在 subrequests 中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At least the following Lua libraries and Nginx modules can be used with this ngx_lua module:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041203Z" changeid="xf">
        <seg>至少下列Lua库和Nginx模块可以与ngx_lua模块一同使用:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At that time ngx_lua can calculate the total length of the body and construct a proper &lt;code&gt;Content-Length&lt;/code&gt; header to return to the HTTP 1.0 client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040420Z" changeid="xf">
        <seg>这时 ngx_lua 就可以计算出体的总长度从而创建正确的 &lt;code&gt;Content-Length&lt;/code&gt; 头返回给 HTTP 1.0 客户端.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to connect a TCP socket object to a remote server or to a stream unix domain socket file without blocking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074352Z" changeid="xf">
        <seg>尝试将一个TCP socket对象与远程服务器或流unix domain socket文件进行不阻塞连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to connect a UDP socket object to a remote server or to a datagram unix domain socket file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065256Z" changeid="xf">
        <seg>尝试将一个 UDP socket 对象连接到一个远程服务器或者数据报的unix domain socket文件.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attempts to load standard Lua 5.1 bytecode files into ngx_lua instances linked to LuaJIT 2.0 or vice versa, will result in an error message, such as that below, being logged into the Nginx &lt;code&gt;error.log&lt;/code&gt; file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040013Z" changeid="xf">
        <seg>试图在连接了LuaJIT2.0的ngx_lua实例中加载标准Lua5.1的字节码文件，或相反，都将导致以下错误信息被记入nginx &lt;code&gt;error.log&lt;/code&gt; 文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064250Z" changeid="xf">
        <seg>基本上你可以在这个上下文中安全地使用进行阻塞I/O的Lua库，因为在启动阶段阻塞主进程是完全ok的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the [http://en.wikipedia.org/wiki/Copy-on-write Copy-on-write (COW)] feature provided by many operating systems among all the worker processes, thus saving a lot of memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064038Z" changeid="xf">
        <seg>由于在这个上下文中的Lua代码是在Nginx fork它的worker进程（如果有的话）之前运行的，所以这里加载和数据或代码会在work进程之间享受很多操作系统都提供的 [http://en.wikipedia.org/wiki/Copy-on-write Copy-on-write (COW)]特性，能够节省大量内存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the datagram protocol is actually connection-less, this method does not really establish a &quot;connection&quot;, but only just set the name of the remote peer for subsequent read/write operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065443Z" changeid="xf">
        <seg>由于数据报协议事实上是无连接的，本方法并不实际创建 &quot;连接&quot;, 只是设置远程对象的名字，以备后续的 读/写 操作使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because timer callbacks run in the background and their running time
will not add to any client request's response time, they can easily
accumulate in the server and exhaust system resources due to either
Lua programming mistakes or just too much client traffic.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042344Z" changeid="xf">
        <seg>由于定时器回调运行在后台，它们的运行时间并不会增加客户端请求的响应时间，所以它们很容易由于Lua程序错误或太多客户端流量而在服务器上积累，耗尽系统资源.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because when the content length exceeds [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] but less than [[HttpCoreModule#client_max_body_size|client_max_body_size]], Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the [[HttpCoreModule#$request_body|$request_body]] variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102004Z" changeid="xf">
        <seg>因为如果内容长度超过了[[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] 但小于 [[HttpCoreModule#client_max_body_size|client_max_body_size]], Nginx 将会把数据缓存到存盘上的临时文件中， [[HttpCoreModule#$request_body|$request_body]]变量中将是空值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before &lt;code&gt;ngx.thread.spawn&lt;/code&gt; returns, the &lt;code&gt;func&lt;/code&gt; will be called with those optional arguments until it returns, aborts with an error, or gets yielded due to I/O operations via the [[#Nginx API for Lua|Nginx API for Lua]] (like [[#tcpsock:receive|tcpsock:receive]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T014059Z" changeid="xf">
        <seg>在 &lt;code&gt;ngx.thread.spawn&lt;/code&gt; 返回之前, &lt;code&gt;func&lt;/code&gt; 将对那些可选的参数进行调用，直到此函数返回，或因出错而终止，或由于[[#Nginx API for Lua|Nginx API for Lua]] (例如[[#tcpsock:receivetcpsock:receive]])的I/O操作而挂起.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Before actually resolving the host name and connecting to the remote backend, this method will always look up the connection pool for matched idle connections created by previous calls of this method (or the [[#ngx.socket.connect|ngx.socket.connect]] function).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074521Z" changeid="xf">
        <seg>在实际解析域名和连接到远程实体之前, 本方法总会查找连接池中之前用本方法(或[[#ngx.socket.connect|ngx.socket.connect]] 函数)创建的空闲连接.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scene, it is just a thin wrapper around the &lt;code&gt;ngx_crc32_long&lt;/code&gt; function defined in the Nginx core.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021053Z" changeid="xf">
        <seg>其内部实现其实是对Nginx核心&lt;code&gt;ngx_crc32_long&lt;/code&gt;函数的小小封装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scene, it is just a thin wrapper around the &lt;code&gt;ngx_crc32_short&lt;/code&gt; function defined in the Nginx core.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020934Z" changeid="xf">
        <seg>其内部实现其实是对Nginx核心&lt;code&gt;ngx_crc32_short&lt;/code&gt;函数的小小封装。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scene, the &quot;eof&quot; flag is just the &lt;code&gt;last_buf&lt;/code&gt; (for main requests) or &lt;code&gt;last_in_chain&lt;/code&gt; (for subrequests) flag of the Nginx chain link buffers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094337Z" changeid="xf">
        <seg>在内部实现里， &quot;eof&quot; 标记其实是Nginx缓冲区链中的 &lt;code&gt;last_buf&lt;/code&gt; (主请求) 或 &lt;code&gt;last_in_chain&lt;/code&gt; (子请求) 标记</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Behind the scene, this method makes use of the Nginx timers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015901Z" changeid="xf">
        <seg>其内部实现使用Nginx定时器.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Boolean argument values are also supported, for instance,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020301Z" changeid="xf">
        <seg>支持布尔值作为参数，例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Both IP addresses and domain names can be specified as the &lt;code&gt;host&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065458Z" changeid="xf">
        <seg> &lt;code&gt;host&lt;/code&gt; 参数可以是IP地址或域名.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Build the source with this module:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033219Z" changeid="xf">
        <seg>将本模块编译进Nginx:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But if you create subrequests to access other locations configured by Nginx upstream modules, then you should configure those upstream modules to ignore client connection abortions if they are not by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015639Z" changeid="xf">
        <seg>但是如果你创建了子请求来访问由Nginx上游模块 配置的其它 location，你需要配置此上游模块忽略掉客户端发起的连接断开.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But note that, the [[#lua_shared_dict|lua_shared_dict]]'s shm storage will not be cleared through a config reload (via the &lt;code&gt;HUP&lt;/code&gt; signal, for example).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063337Z" changeid="xf">
        <seg>但请注意， [[#lua_shared_dict|lua_shared_dict]]的共享存储在重新加载配置文件（如通过&lt;code&gt;HUP&lt;/code&gt;信号）时不会被清空。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But special care must be taken for injection attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073556Z" changeid="xf">
        <seg>但是要特别小心防止注入攻击。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But the subrequest API (like
[[#ngx.location.capture|ngx.location.capture]]), the [[#ngx.req.start_time|ngx.req.*]] API, the downstream output API
(like [[#ngx.say|ngx.say]], [[#ngx.print|ngx.print]], and [[#ngx.flush|ngx.flush]]) are explicitly disabled in
this context.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T043225Z" changeid="xf">
        <seg>但是子请求API (如[[#ngx.location.capture|ngx.location.capture]]), [[#ngx.req.start_time|ngx.req.*]] API, 下游输出 API
(如 [[#ngx.say|ngx.say]], [[#ngx.print|ngx.print]], 和[[#ngx.flush|ngx.flush]]) 在这个上下文中都是明确禁止使用的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But this global variable will be cleared at the end of the request handler,  and every subsequent request handler all has its own (clean) global environment.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T030117Z" changeid="xf">
        <seg>但是这个全局变量会在请求处理器结束时被清除，每个后续的请求处理器都有自己的（干净的）全局环境.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But when this size is greater than &lt;code&gt;8192&lt;/code&gt;, then &lt;code&gt;8192&lt;/code&gt; will be used instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073440Z" changeid="xf">
        <seg>但如果这个值超过了 &lt;code&gt;8192&lt;/code&gt;, 缓冲区大小为 &lt;code&gt;8192&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By contrast, Nginx + php-fpm 5.2.8 + Unix Domain Socket yields 6k req/sec and [http://nodejs.org/ Node.js] v0.6.1 yields 10.2k req/sec for their Hello World equivalents.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T034407Z" changeid="xf">
        <seg>相比之下, Nginx + php-fpm 5.2.8 + Unix Domain Socket 的hello work结果为 6k req/sec ， [http://nodejs.org/ Node.js] v0.6.1 的hello world结果为 10.2k req/sec .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, a maximum of 100 request arguments are parsed (including those with the same name) and that additional URI arguments are silently discarded to guard against potential denial of service attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020544Z" changeid="xf">
        <seg>默认最多只解析100个请求参数 (包括名称一样的) ，多出来的请求参数将被简单丢弃，以防止DOS攻击.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, all the subrequests subsequently initiated by [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] will inherit the new header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021014Z" changeid="xf">
        <seg>所有用[[#ngx.location.capturengx.location.capture]] and [[#ngx.location.capture_multingx.location.capture_multi]]发起的子请求都默认继承新设置的头。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, only the first 1024 keys (if any) are returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060808Z" changeid="xf">
        <seg>默认只返回前1024个值 (如果有的话.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the corresponding Nginx handler (e.g., [[#rewrite_by_lua|rewrite_by_lua]] handler) will not terminate until
# both the &quot;entry thread&quot; and all the user &quot;light threads&quot; terminates,
# a &quot;light thread&quot; (either the &quot;entry thread&quot; or a user &quot;light thread&quot; aborts by calling [[#ngx.exit|ngx.exit]], [[#ngx.exec|ngx.exec]], [[#ngx.redirect|ngx.redirect]], or [[#ngx.req.set_uri|ngx.req.set_uri(uri, true)]], or
# the &quot;entry thread&quot; terminates with a Lua error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T014609Z" changeid="xf">
        <seg>默认情况下, 只有出现下列情况之一时相应的Nginx处理器 (例如, [[#rewrite_by_lua|rewrite_by_lua]] 处理器)才会终止
# &quot;入口线程&quot; 和所有用户 &quot;轻量线程&quot; 都结束了,
# 某个 &quot;轻量线程&quot; (可能是&quot;入口线程&quot; 或某个用户 &quot;轻量线程&quot; 调用了 [[#ngx.exit|ngx.exit]], [[#ngx.exec|ngx.exec]], [[#ngx.redirect|ngx.redirect]],  [[#ngx.req.set_uri|ngx.req.set_uri(uri, true)]]而终止 
# &quot;入口线程&quot;由于Lua错误而终止.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, the request line and trailing &lt;code&gt;CR LF&lt;/code&gt; terminator will also be included.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095249Z" changeid="xf">
        <seg>默认情况下，包含请求行及结尾的 &lt;code&gt;CR LF&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, this directive is turned off and the Lua code is postponed to run at the end of the &lt;code&gt;rewrite&lt;/code&gt; phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020707Z" changeid="xf">
        <seg>默认情况下，本命令处于关闭状态，  Lua 代码在 &lt;code&gt;rewrite&lt;/code&gt; 阶段的最后运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calculates the CRC-32 (Cyclic Redundancy Code) digest for the &lt;code&gt;str&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020805Z" changeid="xf">
        <seg>计算&lt;code&gt;str&lt;/code&gt;参数的 CRC-32 校验值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Call [[#ngx.req.read_body|ngx.req.read_body]] to read the request body first or turn on the [[#lua_need_request_body|lua_need_request_body]] directive to avoid errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013055Z" changeid="xf">
        <seg>为避免出错，先调用 [[#ngx.req.read_body|ngx.req.read_body]] 读取请求体或打开 [[#lua_need_request_body|lua_need_request_body]] 命令.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling the function with the &lt;code&gt;wait&lt;/code&gt; argument set to &lt;code&gt;true&lt;/code&gt; switches to synchronous mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042037Z" changeid="xf">
        <seg>如果 &lt;code&gt;wait&lt;/code&gt; 参数设为 &lt;code&gt;true&lt;/code&gt; 则切换到同步模式.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Calling this method on an already connected socket object will cause the original connection to be closed first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T070122Z" changeid="xf">
        <seg>对已经连接的socket对象调用此方法将导致之前的连接先被关闭.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Care should be taken in using this option as variable scope sharing can have unexpected side effects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053834Z" changeid="xf">
        <seg>要谨慎使用这个选项，因为变量域的共享可能会带来预料之外的副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Changes made to these variables by such subrequests will not affect the parent request or any other subrequests sharing the parent request's variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T054908Z" changeid="xf">
        <seg>子请求对这些变量的修改不会影响到父请求和那些分享父请求变量的子请求。.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Check out [[#Nginx log level constants|Nginx log level constants]] for details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041743Z" changeid="xf">
        <seg>详情见 [[#Nginx log level constants|Nginx日志级别常量]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Clear the current request's request header named &lt;code&gt;header_name&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021246Z" changeid="xf">
        <seg>清除当前请求中名为 &lt;code&gt;header_name&lt;/code&gt; 的头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes the current TCP or stream unix domain socket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T100638Z" changeid="xf">
        <seg>关闭当前 TCP 或流 unix domain socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Closes the current UDP or datagram unix domain socket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073740Z" changeid="xf">
        <seg>关闭当前的UDP或数据报unix domain socket.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Completes the construction process of the new request body created by the [[#ngx.req.init_body|ngx.req.init_body]] and [[#ngx.req.append_body|ngx.req.append_body]] calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031141Z" changeid="xf">
        <seg>完成由[[#ngx.req.init_bodyngx.req.init_body]] and [[#ngx.req.append_bodyngx.req.append_body]]实现的请求体创建过程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Computes the [http://en.wikipedia.org/wiki/HMAC HMAC-SHA1] digest of the argument &lt;code&gt;str&lt;/code&gt; and turns the result using the secret key &lt;code&gt;&lt;secret_key&gt;&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021241Z" changeid="xf">
        <seg>使用密钥&lt;code&gt;&lt;secret_key&gt;&lt;/code&gt;计算&lt;code&gt;str&lt;/code&gt;参数的 [http://en.wikipedia.org/wiki/HMAC HMAC-SHA1]文摘.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Connecting to a Unix Domain Socket file is also possible:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074602Z" changeid="xf">
        <seg>也可以连接到Unix domain socket文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034523Z" changeid="xf">
        <seg>考虑以下示例,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Consider the following example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T095239Z" changeid="xf">
        <seg>考虑下面的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls the &lt;code&gt;lowat&lt;/code&gt; (low water) value for the cosocket send buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103021Z" changeid="xf">
        <seg>控制cosocket发送缓冲区的 &lt;code&gt;lowat&lt;/code&gt; 值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:send|send]] method and can be overridden by the [[#tcpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102834Z" changeid="xf">
        <seg>本命令控制 TCP/unix-domain socket 对象[[#tcpsock:send|send]] 方法中使用的默认超时时间， 可以用 [[#tcpsock:settimeout|settimeout]] 方法进行修改.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls the maximum number of &quot;running timers&quot; allowed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022803Z" changeid="xf">
        <seg>控制“正在运行的定时器“数量的上限.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls the maximum number of pending timers allowed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022739Z" changeid="xf">
        <seg>控制未过期定时器数量的上限.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls whether or not to disable postponing [[#rewrite_by_lua|rewrite_by_lua]] and [[#rewrite_by_lua_file|rewrite_by_lua_file]] directives to run at the end of the &lt;code&gt;rewrite&lt;/code&gt; request-processing phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020629Z" changeid="xf">
        <seg>控制是否禁止延后 [[#rewrite_by_lua|rewrite_by_lua]] 和[[#rewrite_by_lua_file|rewrite_by_lua_file]] 命令，使其在 &lt;code&gt;rewrite&lt;/code&gt; 请求处理阶段的最后运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Controls whether to transform underscores (&lt;code&gt;_&lt;/code&gt;) in the response header names specified in the [[#ngx.header.HEADER|ngx.header.HEADER]] API to hypens (&lt;code&gt;-&lt;/code&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020937Z" changeid="xf">
        <seg>控制是否将 [[#ngx.header.HEADER|ngx.header.HEADER]] API中指定的响应头名称里的下划线 (&lt;code&gt;_&lt;/code&gt;) 转换成减号 (&lt;code&gt;-&lt;/code&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a new blank request body for the current request and inializes the buffer for later request body data writing via the [[#ngx.req.append_body|ngx.req.append_body]] and [[#ngx.req.finish_body|ngx.req.finish_body]] APIs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T025041Z" changeid="xf">
        <seg>为当前请求创建一个新的空请求体，初始化其缓冲区供后续的 [[#ngx.req.append_body|ngx.req.append_body]] 和 [[#ngx.req.finish_body|ngx.req.finish_body]] 写入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates a user Lua coroutines with a Lua function, and returns a coroutine object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035033Z" changeid="xf">
        <seg>用Lua函数创建一个用户Lua coroutine，返回coroutine对象.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates an Nginx timer with a user callback function as well as optional user arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T022105Z" changeid="xf">
        <seg>使用用户回调函数及可选参数创建Nginx定时器.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates and returns a TCP or stream-oriented unix domain socket object (also known as one type of the &quot;cosocket&quot; objects).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074211Z" changeid="xf">
        <seg>创建并返回一个TCP或流unix domain socket对象 (也是 &quot;cosocket&quot; 的一种).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Creates and returns a UDP or datagram-oriented unix domain socket object (also known as one type of the &quot;cosocket&quot; objects).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T064926Z" changeid="xf">
        <seg>创建并返回一个UDP或基于数据报的 unix domain socket 对象(也是 &quot;cosocket&quot; 的一种).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Curly braces can also be used to disambiguate variable names from the background string literals:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032402Z" changeid="xf">
        <seg>可以用大括号来消除变量名与后台字符量的歧义:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Current possible values are 1.0, 1.1, and 0.9.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094445Z" changeid="xf">
        <seg>目前可能的值有 1.0, 1.1, 和 0.9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Currently only numerical [[#HTTP method constants|method constants]] are supported, like &lt;code&gt;ngx.HTTP_POST&lt;/code&gt; and &lt;code&gt;ngx.HTTP_GET&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095619Z" changeid="xf">
        <seg>当前仅支持数字 [[#HTTP method constants|方法常量]], 如&lt;code&gt;ngx.HTTP_POST&lt;/code&gt; 和 &lt;code&gt;ngx.HTTP_GET&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>D             enable duplicate named pattern support.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024058Z" changeid="xf">
        <seg>D             打开重复具名模板支持.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Declares a shared memory zone, &lt;code&gt;&lt;name&gt;&lt;/code&gt;, to serve as storage for the shm based Lua dictionary &lt;code&gt;ngx.shared.&lt;name&gt;&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102432Z" changeid="xf">
        <seg>声明一个共享内存区， &lt;code&gt;&lt;name&gt;&lt;/code&gt;, 作为基于共享内存的 Lua 字典 &lt;code&gt;ngx.shared.&lt;name&gt;&lt;/code&gt;的存储区.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decodes a URI encoded query-string into a Lua table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020432Z" changeid="xf">
        <seg>将 URI编码的 query-string 解析为Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Decodes the &lt;code&gt;str&lt;/code&gt; argument as a base64 digest to the raw form.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020639Z" changeid="xf">
        <seg>对&lt;code&gt;str&lt;/code&gt; 进行base64解码.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default to 30 connections for every pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104147Z" changeid="xf">
        <seg>默认每个连接池最多30个连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Default to &lt;code&gt;false&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T100538Z" changeid="xf">
        <seg>默认为&lt;code&gt;false&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Defaults to &lt;code&gt;0&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T041116Z" changeid="xf">
        <seg>默认值是 &lt;code&gt;0&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Delegating all network and disk I/O operations to Nginx's subrequests (via the [[#ngx.location.capture|ngx.location.capture]] method and similar) is strongly recommended for maximum performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024440Z" changeid="xf">
        <seg>为获得最好的性能，强烈推荐将网络和磁盘I/O委托给 Nginx's 子请求 (通过 [[#ngx.location.capture|ngx.location.capture]] 或类似的方法)。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101613Z" changeid="xf">
        <seg>决定在运行 rewrite/access/access_by_lua* 之前是否强制读取请求体数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disabling the Lua code cache is strongly
discouraged for production use and should only be used during 
development as it has a significant negative impact on overall performance.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T052540Z" changeid="xf">
        <seg>禁止代码缓存在生产环境中是非常不推荐的，对整体的性能有很大的负面影响，只应用于开发阶段。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Disk operations with relatively small amount of data can be done using the standard Lua &lt;code&gt;io&lt;/code&gt; library but huge file reading and writing should be avoided wherever possible as they may block the Nginx process significantly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024349Z" changeid="xf">
        <seg>对少量数据的磁盘操作可以用标准Lua &lt;code&gt;io&lt;/code&gt; 库来完成，但是应尽可能避免对大文件的读取和写入，因为这会严重阻塞Nginx进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not activate the &lt;code&gt;o&lt;/code&gt; option for regular expressions (and/or &lt;code&gt;replace&lt;/code&gt; string arguments for [[#ngx.re.sub|ngx.re.sub]] and [[#ngx.re.gsub|ngx.re.gsub]]) that are generated ''on the fly'' and give rise to infinite variations to avoid hitting the specified limit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060232Z" changeid="xf">
        <seg>不要为运行时动态生成的正则表达式设置&lt;code&gt;o&lt;/code&gt;模式，（或是为 [[#ngx.re.sub|ngx.re.sub]] 和 [[#ngx.re.gsub|ngx.re.gsub]] 提供&lt;code&gt;replace&lt;/code&gt; 字符串参数) 以避免超限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not turn on the [[#lua_need_request_body|lua_need_request_body]] directive, and do not mix this call with [[#ngx.req.read_body|ngx.req.read_body]] and [[#ngx.req.discard_body|ngx.req.discard_body]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032030Z" changeid="xf">
        <seg>不要打开 [[#lua_need_request_body|lua_need_request_body]] 命令, 而且不要将本函数与 [[#ngx.req.read_body|ngx.req.read_body]] 和 [[#ngx.req.discard_body|ngx.req.discard_body]] 混用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not use backlashes to escape dollar signs; it will not work as expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032521Z" changeid="xf">
        <seg>还要用反斜杠对美元符进行转义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Do not use this directive and other content handler directives in the same location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074119Z" changeid="xf">
        <seg>在同一个location中不要同时使用本命令和其它content handler命令。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Does an internal redirect to &lt;code&gt;uri&lt;/code&gt; with &lt;code&gt;args&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032310Z" changeid="xf">
        <seg>使用&lt;code&gt;args&lt;/code&gt;作为参数发起到 &lt;code&gt;uri&lt;/code&gt; 的内部重定向 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Due to the limitation in the Nginx subrequest model, it is not allowed to abort a running Nginx subrequest in general.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T014800Z" changeid="xf">
        <seg>由于Nginx子请求模型的限制，通常不允许中断一个正在运行的Nginx子请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each request handler has its own set of Lua global variables and that is the idea of request isolation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T025852Z" changeid="xf">
        <seg>每个请求处理器都有它自己的Lua全局变量集，这就是请求隔离的概念.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Emits arguments concatenated to the HTTP client (as response body).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040851Z" changeid="xf">
        <seg>将参数（作为响应体）发送给客户端.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Empty key arguments are discarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102923Z" changeid="xf">
        <seg>空的key参数将被丢弃.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enables or disables automatic response buffering for HTTP 1.0 (or older) requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015900Z" changeid="xf">
        <seg>打开/关闭 HTTP 1.0(或更低版本)的请求的自动响应缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Enables or disables the Lua code cache for [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#rewrite_by_lua_file|rewrite_by_lua_file]], and
[[#access_by_lua_file|access_by_lua_file]], and also force Lua module reloading on a per-request basis.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T042233Z" changeid="xf">
        <seg>为 [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#rewrite_by_lua_file|rewrite_by_lua_file]], and
[[#access_by_lua_file|access_by_lua_file]] 打开或关闭Lua代码缓存, 同时强制为每个请求重新加载Lua模块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encode &lt;code&gt;str&lt;/code&gt; to a base64 digest.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020616Z" changeid="xf">
        <seg>将&lt;code&gt;str&lt;/code&gt; 进行 base64 编码.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encode the Lua table to a query args string according to the URI encoded rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020111Z" changeid="xf">
        <seg>根据URI编码规则将Lua table编码成一个query string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#access_by_lua|access_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094350Z" changeid="xf">
        <seg>同 [[#access_by_lua|access_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含 Lua 代码, 或者, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#body_filter_by_lua|body_filter_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091639Z" changeid="xf">
        <seg>同 [[#body_filter_by_lua|body_filter_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含 Lua 代码, 或者, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#content_by_lua|content_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074238Z" changeid="xf">
        <seg>同 [[#content_by_lua|content_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含或, 从&lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#header_filter_by_lua|header_filter_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094748Z" changeid="xf">
        <seg>同 [[#header_filter_by_luaheader_filter_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含 Lua 代码, 或者, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#init_by_lua|init_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code or [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T071952Z" changeid="xf">
        <seg>类似 [[#init_by_lua|init_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含 Lua 代码或是 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#log_by_lua|log_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101453Z" changeid="xf">
        <seg>同[[#log_by_lua|log_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含或, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含[[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#rewrite_by_lua|rewrite_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080713Z" changeid="xf">
        <seg>同[[#rewrite_by_lua|rewrite_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含或, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含[[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Equivalent to [[#set_by_lua|set_by_lua]], except that the file specified by &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; contains the Lua code, or, as from the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release, the [[#Lua/LuaJIT bytecode support|Lua/LuaJIT bytecode]] to be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073511Z" changeid="xf">
        <seg>同 [[#set_by_lua|set_by_lua]], 区别在于 &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 可以包含 Lua 代码, 或者, 从 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本开始, 可以包含 [[#Lua/LuaJIT bytecode support|Lua/LuaJIT 字节码]]。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Escape &lt;code&gt;str&lt;/code&gt; as a URI component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020007Z" changeid="xf">
        <seg>将 &lt;code&gt;str&lt;/code&gt; 转义成 URI 片段.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Even the Nginx core does blocking I/O (at least on resolving upstream's host names) at the configure-loading phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064341Z" changeid="xf">
        <seg> Nginx 内核自己在加载配置的阶段也用阻塞 I/O (至少在解析 upstream 主机名时) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Every request, including subrequests, has its own copy of the table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035150Z" changeid="xf">
        <seg>每个请求, 包括子请求, 都有对这个table的独立拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Everything should be installed correctly, except for one small tweak.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032408Z" changeid="xf">
        <seg>一切都应该顺利安装，只有一个小问题.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Everything works internally, efficiently, on the C level.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040744Z" changeid="xf">
        <seg>一切都在内部C这一层高效运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Executes code specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; with optional input arguments &lt;code&gt;$arg1 $arg2 ...&lt;/code&gt;, and returns string output to &lt;code&gt;$res&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073007Z" changeid="xf">
        <seg>执行 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; 中的代码，可选参数 &lt;code&gt;$arg1 $arg2 ...&lt;/code&gt;, 返回字符串输出到 &lt;code&gt;$res&lt;/code&gt;中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly discard the request body, i.e., read the data on the connection and throw it away immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022634Z" changeid="xf">
        <seg>显式地丢弃请求体，即, 从连接中读取数据但是马上丢掉它.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly send out the response headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040202Z" changeid="xf">
        <seg>显式地发送响应头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Explicitly specify the end of the response output stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015252Z" changeid="xf">
        <seg>显式地标出响应输出流的结尾.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fetch a list of the keys from the dictionary, up to &lt;code&gt;&lt;max_count&gt;&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060745Z" changeid="xf">
        <seg>从字典中返回键的列表, 数量最大为 &lt;code&gt;&lt;max_count&gt;&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Fetching the shm-based Lua dictionary object for the shared memory zone named &lt;code&gt;DICT&lt;/code&gt; defined by the [[#lua_shared_dict|lua_shared_dict]] directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T033835Z" changeid="xf">
        <seg>获取由 [[#lua_shared_dictlua_shared_dict]]命令定义的基于共享内存的Lua字典对象 &lt;code&gt;DICT&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flushes out all the items in the dictionary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060409Z" changeid="xf">
        <seg>清除字典中所有项目.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flushes out the expired items in the dictionary, up to the maximal number specified by the optional &lt;code&gt;max_count&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060544Z" changeid="xf">
        <seg>消除字典中过期的项, 最多清除 &lt;code&gt;max_count&lt;/code&gt; 项.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Flushes response output to the client.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041807Z" changeid="xf">
        <seg>将响应数据输出至客户端.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For (soft) real-time web applications, it is highly recommended to configure the [http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html TCP keepalive] support in your system's TCP stack implementation in order to detect &quot;half-open&quot; TCP connections in time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022251Z" changeid="xf">
        <seg>对于 (软) 实时web应用, 强烈推荐为系统的TCP栈实现配置 [http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html TCP keepalive] 支持以便随时检测 &quot;半开&quot;TCP连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074847Z" changeid="xf">
        <seg>例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, by default the standard [[HttpProxyModule]] will terminate both the subrequest and the main request as soon as the client closes the connection, so it is important to turn on the [[HttpProxyModule#proxy_ignore_client_abort|proxy_ignore_client_abort]] directive in your location block configured by [[HttpProxyModule]]:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015746Z" changeid="xf">
        <seg>例如，For example, by default the standard [[HttpProxyModule]]默认会在客户端关闭连接时同时终止子请求和父请求，所以需要在[[HttpProxyModule]]配置的location中打开 [[HttpProxyModule#proxy_ignore_client_abort|proxy_ignore_client_abort]] 命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, if a request header &lt;code&gt;My-Foo-Header&lt;/code&gt; is present, then the following invocations will all pick up the value of this header correctly:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020614Z" changeid="xf">
        <seg>例如，如果有一个请求头 &lt;code&gt;My-Foo-Header&lt;/code&gt; , 以下各种写法都能正确获得这个头的值:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, it can simply ignore the event by doing nothing and the current Lua request handler will continue executing without interruptions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021649Z" changeid="xf">
        <seg>例如，它可以简单地忽略掉些事情，不做任何事情，当前的Lua请求处理器将继续执行，不受影响.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, on Linux, you can configure the standard [[HttpCoreModule#listen|listen]] directive in your &lt;code&gt;nginx.conf&lt;/code&gt; file like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022334Z" changeid="xf">
        <seg>例如，在Linux上，你可以在&lt;code&gt;nginx.conf&lt;/code&gt;文件中这样配置标准的 [[HttpCoreModule#listen|listen]] 命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, response headers</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091221Z" changeid="xf">
        <seg>例如，响应头</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the following nginx config snippet</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101928Z" changeid="xf">
        <seg>例如，下面的nginx配置代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, this directive and the [[HttpProxyModule#proxy_pass|proxy_pass]] directive should not be used in the same location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074150Z" changeid="xf">
        <seg>例如， 这条命令和 [[HttpProxyModule#proxy_pass|proxy_pass]] 命令不允许在同一个location中使用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to transform all the lowercase letters in the response body, we can just write:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094653Z" changeid="xf">
        <seg>例如，要将转换响应体中的所有小写字母，可以写:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, when using the standard &lt;code&gt;ngx_proxy&lt;/code&gt; module to serve
subrequests, an &quot;Accept-Encoding: gzip&quot; header in the main request may result
in gzipped responses that cannot be handled properly in Lua code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082222Z" changeid="xf">
        <seg>例如，如果用标准的 &lt;code&gt;ngx_proxy&lt;/code&gt; 模块来为子请求服务, 主请求中的 &quot;Accept-Encoding: gzip&quot; 头可能会导致无法被Lua代码正常处理的被压缩的响应。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032119Z" changeid="xf">
        <seg>例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035521Z" changeid="xf">
        <seg>例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, Nginx config</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102210Z" changeid="xf">
        <seg>例如，Nginx配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For instance, if the subrequest response headers contain the following
lines:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041109Z" changeid="xf">
        <seg>例如， 如果子请求响应头包含 :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For large streaming output responses, it is important to disable the [[#lua_http10_buffering|lua_http10_buffering]] directive to minimise memory usage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040543Z" changeid="xf">
        <seg>对于大的流式输出响应，要记住禁止[[#lua_http10_bufferinglua_http10_buffering]]以减少内存占用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For multi-value headers, all of the values of header will be collected in order and returned as a Lua table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091215Z" changeid="xf">
        <seg>对于多值头，所有的值将按顺序放在一个Lua table中返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For multi-value response headers,
the value is a Lua (array) table that holds all the values in the order that
they appear.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041050Z" changeid="xf">
        <seg>对于有多值的响应头,
其值是装有按出现顺序排序的所有值的 Lua (数组) table</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For multiple instances of request headers such as:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015506Z" changeid="xf">
        <seg>对于有多个值的请求头如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For reading ''request'' headers, use the [[#ngx.req.get_headers|ngx.req.get_headers]] function instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091409Z" changeid="xf">
        <seg>要读取 ''请求'' 头, 用 [[#ngx.req.get_headers|ngx.req.get_headers]] 函数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the first two cases, the &quot;light thread&quot; will usually be resumed later by the ngx_lua scheduler unless a &quot;stop-the-world&quot; event happens.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T015546Z" changeid="xf">
        <seg>对于前两种情况, &quot;轻量线程&quot; 通常会在将来被 ngx_lua 调度器唤醒，除非发生了 &quot;停止所有&quot; 事件.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the last successful invocation of the iterator function, the &lt;code&gt;err&lt;/code&gt; return value will be &lt;code&gt;nil&lt;/code&gt; too.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T094940Z" changeid="xf">
        <seg>对iterator函数的最后一次成功的调用, &lt;code&gt;err&lt;/code&gt; 返回值为 &lt;code&gt;nil&lt;/code&gt; too.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Forcibly updates the Nginx current time cache.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022252Z" changeid="xf">
        <seg>强制刷新Nginx当前时间缓存.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hence, changes to Nginx variables made by a subrequest will affect the current request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053805Z" changeid="xf">
        <seg>这样，子请求中对Nginx变量的修改将会影响到当前请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a basic example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040824Z" changeid="xf">
        <seg>这是一个基本的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a complete small example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041122Z" changeid="xf">
        <seg>下面是一个完整的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a simple example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T023051Z" changeid="xf">
        <seg>以下是一个简单的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a small example to demonstrate its basic usage:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025916Z" changeid="xf">
        <seg>以下是对基本用法的示例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024615Z" changeid="xf">
        <seg>示例</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example assuming the current server name is &lt;code&gt;localhost&lt;/code&gt; and that it is listening on Port 1984:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034415Z" changeid="xf">
        <seg>以下的例子假设当前的服务器名为 &lt;code&gt;localhost&lt;/code&gt; 监听 1984 端口:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example for connecting to a TCP server:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074544Z" changeid="xf">
        <seg>以下 连接到 TCP 服务器的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example for connecting to a UDP (memcached) server:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065803Z" changeid="xf">
        <seg>以下是连接到 UDP (memcached) 服务器的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example for pre-loading Lua modules:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063012Z" changeid="xf">
        <seg>以下是预加载 Lua 的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example for this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063119Z" changeid="xf">
        <seg>例如：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example for using this method to read a data stream with the boundary sequence &lt;code&gt;--abcedhb&lt;/code&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T093838Z" changeid="xf">
        <seg>以下是使用本方法来用边界序列 &lt;code&gt;--abcedhb&lt;/code&gt; 读取数据:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example of gathering average data for [[HttpUpstreamModule#$upstream_response_time|$upstream_response_time]]:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101253Z" changeid="xf">
        <seg>以下是收集 [[HttpUpstreamModule#$upstream_response_time|$upstream_response_time]] 平均值的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094616Z" changeid="xf">
        <seg>下面是在Lua 头过滤器中重写（如果没有就添加）一个响应头的例子</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example of setting the &lt;code&gt;Content-Length&lt;/code&gt; header:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021031Z" changeid="xf">
        <seg>以下是设置 &lt;code&gt;Content-Length&lt;/code&gt; 头的例子:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is an example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032700Z" changeid="xf">
        <seg>以下是示例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is some examples:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032927Z" changeid="xf">
        <seg>示例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is such an example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T023352Z" changeid="xf">
        <seg>见下例,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is the reason: by design, the global environment has exactly the same lifetime as the Nginx request handler associated with it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T025814Z" changeid="xf">
        <seg>原因是: 在设计上，全局环境拥有与其关联的Nginx请求处理器完全一样的生命周期.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here it essentially implements the &quot;wait all&quot; model.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021157Z" changeid="xf">
        <seg>这里主要实现了 &quot;wait all&quot; 模式.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the &lt;code&gt;args&lt;/code&gt; table will always look like</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103042Z" changeid="xf">
        <seg>这里 &lt;code&gt;args&lt;/code&gt; table 的内容为</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here the Lua code &lt;code&gt;ngx.exit(503)&lt;/code&gt; will never run.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080226Z" changeid="xf">
        <seg>此处 &lt;code&gt;ngx.exit(503)&lt;/code&gt; 不会被执行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, &lt;code&gt;&amp;#91;[\\d+]]&lt;/code&gt; is stripped down to &lt;code&gt;&amp;#91;[\d+]]&lt;/code&gt; by the Nginx config file parser and this is processed correctly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031436Z" changeid="xf">
        <seg>这里, &lt;code&gt;&amp;#91;[\\d+]]&lt;/code&gt; 被Nginx配置文件解析器处理成 &lt;code&gt;&amp;#91;[\d+]]&lt;/code&gt; 可以正常执行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, &lt;code&gt;\\\\d+&lt;/code&gt; is stripped down to &lt;code&gt;\\d+&lt;/code&gt; by the Nginx config file parser and this is further stripped down to &lt;code&gt;\d+&lt;/code&gt; by the Lua language parser before running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031211Z" changeid="xf">
        <seg>这里, &lt;code&gt;\\\\d+&lt;/code&gt; 被Nginx配置文件解析器处理成 &lt;code&gt;\\d+&lt;/code&gt; ，然后在运行之前被Lua语言解析器处理成 &lt;code&gt;\d+&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, modification of the &lt;code&gt;ngx.ctx.blah&lt;/code&gt; entry in the subrequest does not affect the one in the parent request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035421Z" changeid="xf">
        <seg>这里，对子请求中的 &lt;code&gt;ngx.ctx.blah&lt;/code&gt; 进行修改不会影响其父请求中的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, a workaround is possible using the [[#ngx.var.VARIABLE|ngx.var.VARIABLE]] interface.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072544Z" changeid="xf">
        <seg>但是可以使用 [[#ngx.var.VARIABLE|ngx.var.VARIABLE]] 来绕过这个限制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, later attempts to manipulate the cosocket object will fail and return the actual error status message generated by the failed connect operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T024446Z" changeid="xf">
        <seg>但是，后续对cosocket对象的操作将失败，返回由连接操作失败生成的错误状态信息.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the optional &lt;code&gt;max_args&lt;/code&gt; function argument can be used to override this limit:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103242Z" changeid="xf">
        <seg>但是, 可以用可选的&lt;code&gt;max_args&lt;/code&gt; 函数参数修改这个上限:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, the optional &lt;code&gt;max_headers&lt;/code&gt; function argument can be used to override this limit:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015648Z" changeid="xf">
        <seg>但是, 可以用可选的&lt;code&gt;max_headers&lt;/code&gt; 函数参数修改这个上限:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, they are different from arguments taking empty string values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102908Z" changeid="xf">
        <seg>要注意，这与value为空字符串的参数是不一样的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identical to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running coroutine.running] API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035359Z" changeid="xf">
        <seg>与标准 Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.running coroutine.running] API相同.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Identical to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status coroutine.status] API.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035427Z" changeid="xf">
        <seg>与标准 Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.status coroutine.status] API相同.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Idle connections in the pool will be monitored for any exceptional events like connection abortion or unexpected incoming data on the line, in which cases the connection in question will be closed and removed from the pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102116Z" changeid="xf">
        <seg>池中的空闲连接上的任何异常事件都将被监视，如连接中断或意外的输入数据，这时出问题的连接将被关闭并从池中删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a non-number-like string argument is specified, then it is interpreted as a &quot;pattern&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T084759Z" changeid="xf">
        <seg>如果指定的是一个长得不象数值的字符串, 它将被理解成一种 &quot;模式&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a number-like argument is specified (including strings that look like numbers), then it is interpreted as a size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T084644Z" changeid="xf">
        <seg>如果输入参数是数值 (或是长得象数值的字符串), 它将被理解为大小.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If any request body data has been pre-read into the Nginx core request header buffer, the resulting cosocket object will take care of this to avoid potential data loss resulting from such pre-reading.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032230Z" changeid="xf">
        <seg>如果已经有请求体数据被预加载进了Nginx核心请求处理器缓冲区， 返回的cosocket对象将考虑到这一点，以避免这种预加载造成的潜在数据丢失。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it stores the item without forcibly removing other valid items, then the return value &lt;code&gt;forcible&lt;/code&gt; will be &lt;code&gt;false&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054305Z" changeid="xf">
        <seg>如果成功加入了存储项而没有删除其它的有效项,  &lt;code&gt;forcible&lt;/code&gt; 返回值为 &lt;code&gt;false&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no argument is specified, then it is assumed to be the pattern &lt;code&gt;'*l'&lt;/code&gt;, that is, the line reading pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T090130Z" changeid="xf">
        <seg>如果没有给参数，本方法默认以 &lt;code&gt;'*l'&lt;/code&gt; 即按行读取模式执行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If no argument is specified, then the maximal buffer size, &lt;code&gt;8192&lt;/code&gt; is assumed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073500Z" changeid="xf">
        <seg>如果没有参数，缓冲区大小默认为 &lt;code&gt;8192&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If omitted, the default setting in the [[#lua_socket_keepalive_timeout|lua_socket_keepalive_timeout]] config directive will be used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101723Z" changeid="xf">
        <seg>如果没有, 将使用[[#lua_socket_keepalive_timeout|lua_socket_keepalive_timeout]] 配置命令中的默认设置.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If omitted, then the connection pool name will be generated from the string template &lt;code&gt;&quot;&lt;host&gt;:&lt;port&gt;&quot;&lt;/code&gt; or &lt;code&gt;&quot;&lt;unix-socket-path&gt;&quot;&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074956Z" changeid="xf">
        <seg>如果没有提供, 连接池的名称会以 &lt;code&gt;&quot;&lt;host&gt;:&lt;port&gt;&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;&lt;unix-socket-path&gt;&quot;&lt;/code&gt;的格式自动生成.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If response headers have not been sent, this function will send headers out first and then output body data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040915Z" changeid="xf">
        <seg>如果尚未发送响应头，此函数将先发送头，再发送体数据。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If server-wide data sharing is required, then use one or more of the following approaches:
# Use the [[#ngx.shared.DICT|ngx.shared.DICT]] API provided by this module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041428Z" changeid="xf">
        <seg>如果真需要实现在整个server级别的数据共享, 使用以下方法之一:
# 使用本模块提供的 [[#ngx.shared.DICT|ngx.shared.DICT]] API.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;code&gt;0&lt;/code&gt; value is given, then the timeout interval is unlimited.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101748Z" changeid="xf">
        <seg>如果其值是 &lt;code&gt;0&lt;/code&gt; , 则没有超时时限.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;code&gt;Content-Length&lt;/code&gt; response header is set in the running Lua code, however, this buffering will be disabled even if the [[#lua_http10_buffering|lua_http10_buffering]] directive is turned &lt;code&gt;on&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040507Z" changeid="xf">
        <seg>但是如果在运行的Lua代码中设置了 &lt;code&gt;Content-Length&lt;/code&gt; 响应头, 即使[[#lua_http10_buffering|lua_http10_buffering]]命令被置为 &lt;code&gt;on&lt;/code&gt; 也不会做这个缓存.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;code&gt;break&lt;/code&gt; modifier is used instead, there will be no internal redirection and the &lt;code&gt;rewrite_by_lua&lt;/code&gt; code will be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080509Z" changeid="xf">
        <seg>相反，如果使用了 &lt;code&gt;break&lt;/code&gt; , 就不会有内部重定向， &lt;code&gt;rewrite_by_lua&lt;/code&gt; 将被执行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;code&gt;buffer_size&lt;/code&gt; argument is specified, then its value will be used for the size of the memory buffer for body writing with [[#ngx.req.append_body|ngx.req.append_body]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T025126Z" changeid="xf">
        <seg>如果指定了 &lt;code&gt;buffer_size&lt;/code&gt; 参数, 则将会用这个值作为供 [[#ngx.req.append_bodyngx.req.append_body]] 写入的内存缓冲区的大小.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;code&gt;exptime&lt;/code&gt; takes the value &lt;code&gt;0&lt;/code&gt; (which is the default), then the item will never be expired.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T040937Z" changeid="xf">
        <seg>如果 &lt;code&gt;exptime&lt;/code&gt; 值为 &lt;code&gt;0&lt;/code&gt; (默认值), 此项将永不过期.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;code&gt;key&lt;/code&gt; argument already exists in the dictionary (and not expired for sure), the &lt;code&gt;success&lt;/code&gt; return value will be &lt;code&gt;false&lt;/code&gt; and the &lt;code&gt;err&lt;/code&gt; return value will be &lt;code&gt;&quot;exists&quot;&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054754Z" changeid="xf">
        <seg>如果字典中已经存在 &lt;code&gt;key&lt;/code&gt; 键（而且尚未过期）, &lt;code&gt;success&lt;/code&gt; 将返回 &lt;code&gt;false&lt;/code&gt; ， &lt;code&gt;err&lt;/code&gt; 将返回 &lt;code&gt;&quot;exists&quot;&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;code&gt;key&lt;/code&gt; argument does ''not'' exist in the dictionary (or expired already), the &lt;code&gt;success&lt;/code&gt; return value will be &lt;code&gt;false&lt;/code&gt; and the &lt;code&gt;err&lt;/code&gt; return value will be &lt;code&gt;&quot;not found&quot;&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T055212Z" changeid="xf">
        <seg>如果字典中 ''没有'' &lt;code&gt;key&lt;/code&gt; 键 (或已过期), &lt;code&gt;success&lt;/code&gt; 将返回 &lt;code&gt;false&lt;/code&gt; &lt;code&gt;err&lt;/code&gt; 将返回 &lt;code&gt;&quot;not found&quot;&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the &lt;code&gt;size&lt;/code&gt; argument is specified, then this method will use this size as the receive buffer size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073413Z" changeid="xf">
        <seg>如果指定了 &lt;code&gt;size&lt;/code&gt; 参数, 本方法将用此数值作为接收缓冲区的大小.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the Lua code explicitly sets a &lt;code&gt;Content-Length&lt;/code&gt; response header before sending the headers (either explicitly via [[#ngx.send_headers|ngx.send_headers]] or implicitly via the first [[#ngx.say|ngx.say]] or [[#ngx.print|ngx.print]] call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020326Z" changeid="xf">
        <seg>如果Lua代码在发送头（显式地通过[[#ngx.send_headersngx.send_headers]]或者隐式地通过第一个[[#ngx.sayngx.say]] 或 [[#ngx.printngx.print]]调用）之前显式地设置了 &lt;code&gt;Content-Length&lt;/code&gt; 响应头，, 那么即使本命令被打开， 也不会进行HTTP 1.0 响应缓冲。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the [[HttpRewriteModule]]'s [[HttpRewriteModule#rewrite|rewrite]] directive is used to change the URI and initiate location re-lookups (internal redirections), then any [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] code sequences within the current location will not be executed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080159Z" changeid="xf">
        <seg>如果使用了 [[HttpRewriteModule]] 的 [[HttpRewriteModule#rewrite|rewrite]] 命令来修改 URI 和初始 location re-lookups (内部重定向), 则当前location中的任何 [[#rewrite_by_lua|rewrite_by_lua]] 或 [[#rewrite_by_lua_file|rewrite_by_lua_file]] 代码都不会被执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the argument is omitted, then the value specified by the standard [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] directive will be used instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030232Z" changeid="xf">
        <seg>如果没有这个参数, 将使用标准 [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] 命令指定的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the argument value is &lt;code&gt;false&lt;/code&gt;, then the effect is equivalent to the &lt;code&gt;nil&lt;/code&gt; value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020330Z" changeid="xf">
        <seg>如果参数值是&lt;code&gt;false&lt;/code&gt;, 结果等价于 &lt;code&gt;nil&lt;/code&gt; 值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the connection comes from the connection pool, then the return value is always non-zero.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102421Z" changeid="xf">
        <seg>如果连接是从内置连接池中取出的，则返回值总是非0的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current connection does not come from the built-in connection pool, then this method always returns &lt;code&gt;0&lt;/code&gt;, that is, the connection has never been reused (yet).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102400Z" changeid="xf">
        <seg>如果当前连接不是从内置连接池来的, 本方法总是返回 &lt;code&gt;0&lt;/code&gt;, 表示此连接（尚）未被重用过.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current location includes [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] directives,
then the request body will be read just before the [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] code is run (and also at the
&lt;code&gt;rewrite&lt;/code&gt; phase).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102108Z" changeid="xf">
        <seg>如果当前的 location 包含[[#rewrite_by_lua|rewrite_by_lua]] 或 [[#rewrite_by_lua_file|rewrite_by_lua_file]] 命令,
那么请求体将在 [[#rewrite_by_lua|rewrite_by_lua]] 或 [[#rewrite_by_lua_file|rewrite_by_lua_file]] 代码运行之前被读取 (也是在
&lt;code&gt;rewrite&lt;/code&gt; 阶段).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current request is an Nginx subrequest, then the subrequest's method name will be returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095514Z" changeid="xf">
        <seg>如果当前请求是Nginx子请求, 将返回子请求的请求方法名称.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current request is an Nginx subrequest, then the subrequest's method will be overridden.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095653Z" changeid="xf">
        <seg>如果当前请求是Nginx子请求, 则子请求的请求方法将被设置为新值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the current request's request body has not been read, then it will be properly discarded.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023937Z" changeid="xf">
        <seg>如果当前请求的请求体尚未被读取，则其将被正确地丢弃.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the key does not exist or has been expired, then &lt;code&gt;nil&lt;/code&gt; will be returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034338Z" changeid="xf">
        <seg>如果键不存在或已过期，返回 &lt;code&gt;nil&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the message size exceeds this limit, Nginx will truncate the message text accordingly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034211Z" changeid="xf">
        <seg>如果消息长度超限，Nginx 会做相应的截断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the nameserver returns multiple IP addresses for the host name, this method will pick up one randomly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065717Z" changeid="xf">
        <seg>如果从域名解析出来多个IP地址，本方法将从中随机选取一个.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the optional &lt;code&gt;auto_clean&lt;/code&gt; argument is given a &lt;code&gt;true&lt;/code&gt; value, then this file will be removed at request completion or the next time this function or [[#ngx.req.set_body_data|ngx.req.set_body_data]] are called in the same request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024222Z" changeid="xf">
        <seg>如果可选参数 &lt;code&gt;auto_clean&lt;/code&gt; 被设置为 &lt;code&gt;true&lt;/code&gt; , 则文件将在请求结束时，或同一次请求中再次调用 [[#ngx.req.set_body_data|ngx.req.set_body_data]] 时被删除.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the original value is not a valid Lua number in the dictionary, it will return &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;&quot;not a number&quot;&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060254Z" changeid="xf">
        <seg>如果原来的值不是有效的Lua 数值, 返回 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;&quot;not a number&quot;&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body has already been explicitly discarded, either by the [[#ngx.req.discard_body|ngx.req.discard_body]] function or other modules, this function does not run and returns immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022009Z" changeid="xf">
        <seg>如果用[[#ngx.req.discard_bodyngx.req.discard_body]]函数或其它模块显式地丢弃了请求体，则此函数不会执行，立即返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body has already been read, this function does nothing and returns immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022947Z" changeid="xf">
        <seg>如果请求体已经被读取过了，则本函数不做任何事，直接返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body has been read into disk files, try calling the [[#ngx.req.get_body_file|ngx.req.get_body_file]] function instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023315Z" changeid="xf">
        <seg>如果请求体已经被读进磁盘临时文件, 试试调用[[#ngx.req.get_body_file|ngx.req.get_body_file]] 函数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body has been read into memory, try calling the [[#ngx.req.get_body_data|ngx.req.get_body_data]] function instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023749Z" changeid="xf">
        <seg>如果请求体已经被读入内存, 试试调用 [[#ngx.req.get_body_data|ngx.req.get_body_data]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body has not been read yet, call [[#ngx.req.read_body|ngx.req.read_body]] first (or turned on [[#lua_need_request_body|lua_need_request_body]] to force this module to read the request body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023233Z" changeid="xf">
        <seg>如果请求体尚未被读取, 先调用[[#ngx.req.read_body|ngx.req.read_body]] (或打开[[#lua_need_request_body|lua_need_request_body]] 来强制本模块读取请求体.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the request body is already read previously by turning on [[#lua_need_request_body|lua_need_request_body]] or by using other modules, then this function does not run and returns immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021924Z" changeid="xf">
        <seg>如果打开了[[#lua_need_request_bodylua_need_request_body]]或其它模块导致请求体已被读取，则此函数不会执行，立即返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the response header is not present at all, &lt;code&gt;nil&lt;/code&gt; will be returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091108Z" changeid="xf">
        <seg>如果没有响应头，则返回 &lt;code&gt;nil&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the standard Lua 5.1 interpreter is required however, run the following command to install it from the Ubuntu repository:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032353Z" changeid="xf">
        <seg>如果一定要使用标准Lua 5.1 解释器, 运行以下命令从Ubuntu仓库安装:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the user flags is &lt;code&gt;0&lt;/code&gt; (the default), then no flags value will be returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T041159Z" changeid="xf">
        <seg>如果用户标记是 &lt;code&gt;0&lt;/code&gt; (默认值), 将不会返回标记值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value table is empty and the effect is equivalent to the &lt;code&gt;nil&lt;/code&gt; value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020248Z" changeid="xf">
        <seg>如果值是空的table，结果等价于 &lt;code&gt;nil&lt;/code&gt; 值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this method succeeds in storing the current item by forcibly removing other not-yet-expired items in the dictionary via LRU, the &lt;code&gt;forcible&lt;/code&gt; return value will be &lt;code&gt;true&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054231Z" changeid="xf">
        <seg>如果此方法通过采取LRU的方式从字典中删除了一些尚未过期的项, &lt;code&gt;forcible&lt;/code&gt; 返回值为 &lt;code&gt;true&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this option is set to &lt;code&gt;true&lt;/code&gt;, then the current request and associated subrequests will share the same Nginx variable scope.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053745Z" changeid="xf">
        <seg>如果这个选项被置为 &lt;code&gt;true&lt;/code&gt;, 则当前的请求与相关的子请求会共同同样的Nginx 变量域.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If up to tens of existing items have been removed and the storage left is still insufficient (either due to the total capacity limit specified by [[#lua_shared_dict|lua_shared_dict]] or memory segmentation), then the &lt;code&gt;err&lt;/code&gt; return value will be &lt;code&gt;no memory&lt;/code&gt; and &lt;code&gt;success&lt;/code&gt; will be &lt;code&gt;false&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054155Z" changeid="xf">
        <seg>如果已经删除了几十项，剩下的存储空间仍然不够 (受到 [[#lua_shared_dict|lua_shared_dict]] 或内存段的限制),  &lt;code&gt;err&lt;/code&gt; 的返回值将为&lt;code&gt;no memory&lt;/code&gt; ， &lt;code&gt;success&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015751Z" changeid="xf">
        <seg>如果你的Lua代码中已经进行了正确的错误处理和记录日志，那么建议将此命令关闭，以避免在nginx错误日志文件中不必要的数据（这通常有很大的开销）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition to the two settings above, it is possible to specify
values for variables in the subrequest using the &lt;code&gt;vars&lt;/code&gt; option.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T055053Z" changeid="xf">
        <seg>除了上面两种设置外，也可以在子请求中通过 &lt;code&gt;vars&lt;/code&gt; 选项设置变量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, note that this directive can only write out a value to a single Nginx variable at
a time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072520Z" changeid="xf">
        <seg>另外，注意这条命令每次只能写入一个Nginx变量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, race conditions when reloading Lua modules are common for concurrent requests
when the code cache is disabled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T053856Z" changeid="xf">
        <seg>另外，如果禁止了代码缓存，在并发请求中重新加载模块经常会导致race condition。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of domain names, this method will use Nginx core's dynamic resolver to parse the domain name without blocking and it is required to configure the [[HttpCoreModule#resolver|resolver]] directive in the &lt;code&gt;nginx.conf&lt;/code&gt; file like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065622Z" changeid="xf">
        <seg>如果是域名, 本方法将使用Nginx 核心的 动态域名解析器非阻塞地解析域名，要求在 &lt;code&gt;nginx.conf&lt;/code&gt; 文件里使用[[HttpCoreModule#resolver|resolver]] 命令，如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of error, &lt;code&gt;nil&lt;/code&gt; will be returned as well as a string describing the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031817Z" changeid="xf">
        <seg>如果出错，将返回 &lt;code&gt;nil&lt;/code&gt; 和 描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of error, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102255Z" changeid="xf">
        <seg>出错时, 返回&lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of error, the iterator function will return &lt;code&gt;nil&lt;/code&gt; along with a string describing the error and the partial data bytes that have been read so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T094557Z" changeid="xf">
        <seg>如果出错，iterator函数返回 &lt;code&gt;nil&lt;/code&gt; 和一个描述错误的字符串，以及目前读取的部分数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of error, the method returns &lt;code&gt;nil&lt;/code&gt; followed by a string describing the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065735Z" changeid="xf">
        <seg>如果出错, 返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of errors, like seeing a bad regular expression or exceeding the PCRE stack limit, &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023106Z" changeid="xf">
        <seg>如果出错，如正则表达式错误或超过了PCRE的栈空间限制, 返回&lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of errors, like seeing an ill-formed regular expression, &lt;code&gt;nil&lt;/code&gt; and a string describing the error will be returned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025856Z" changeid="xf">
        <seg>如果出错，如正则表达式格式不正确, 返回&lt;code&gt;nil&lt;/code&gt; 和描述错误信息的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of errors, such as connection errors while reading the data, this method will throw out a Lua exception ''or'' terminate the current request with a 500 status code immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022109Z" changeid="xf">
        <seg>在出错的情况下，如在读取数据时的连接错误, 此函数会抛出Lua异常 ''或'' 直接终止当前请求并立即返回 500 状态码.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of failures, like syntax errors in the regular expressions or the &lt;code&gt;&lt;replace&gt;&lt;/code&gt; string argument, it will return &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032209Z" changeid="xf">
        <seg>如果出错, 如正则表达式语法错或 &lt;code&gt;&lt;replace&gt;&lt;/code&gt; 格式错, 返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of success, it returns &lt;code&gt;1&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T070220Z" changeid="xf">
        <seg>成功则返回&lt;code&gt;1&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of success, it returns the data received; in case of error, it returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error and the partial data received so far.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T084505Z" changeid="xf">
        <seg>如果成功则返回接收到的数据; 如果出错则返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串以及接收到的部分数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of success, it returns the data received; in case of error, it returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073343Z" changeid="xf">
        <seg>如果成功则返回接收到的数据; 如果出错则返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of success, it returns the total number of bytes that have been sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T083029Z" changeid="xf">
        <seg>如果成功，则返回发送的总的字节数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of success, the method returns &lt;code&gt;1&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065745Z" changeid="xf">
        <seg>如果成功, 返回 &lt;code&gt;1&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of success, this method returns &lt;code&gt;1&lt;/code&gt;; otherwise, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102138Z" changeid="xf">
        <seg>成功返回 &lt;code&gt;1&lt;/code&gt;; 否则返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In case of table arguments, this method will copy all the string elements piece by piece to the underlying Nginx socket send buffers, which is usually optimal than doing string concatenation operations on the Lua land.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T071922Z" changeid="xf">
        <seg>如果是table参数， 本方法会将所有的字符串元素一块一块地拷贝到下层Nginx socket发送缓冲区，通常这比在Lua里进行字符串拼接要快。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In cases where current request may have a request body and the request body data is not required, The [[#ngx.req.discard_body|ngx.req.discard_body]] function must be used to explicitly discard the request body to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022907Z" changeid="xf">
        <seg>有时候当前请求可能有但不一定有请求体，需要使用 [[#ngx.req.discard_body|ngx.req.discard_body]] 函数来显式地丢弃请求体，以防止在HTTP 1.1 keepalive或HTTP 1.1 pipelining时出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In fact, all CR characters are ignored by the pattern.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T090041Z" changeid="xf">
        <seg>事实上，模式会忽略所有的回车符.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In older versions of Nginx, the limit was &lt;code&gt;50&lt;/code&gt; concurrent subrequests and in more recent versions, Nginx &lt;code&gt;1.1.x&lt;/code&gt; onwards, this was increased to &lt;code&gt;200&lt;/code&gt; concurrent subrequests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082516Z" changeid="xf">
        <seg>在旧版本的Nginx中, 这个上限是 &lt;code&gt;50&lt;/code&gt; 而在最近的版本, Nginx &lt;code&gt;1.1.x&lt;/code&gt; 以上, 这个上限增加到了 &lt;code&gt;200&lt;/code&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In other words, no time-slicing is performed automatically.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T015135Z" changeid="xf">
        <seg>换句话说，分时并不是自动进行的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In synchronous mode, the function will not return until all output data has been written into the system send buffer or until the [[HttpCoreModule#send_timeout|send_timeout]] setting has expired.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042137Z" changeid="xf">
        <seg>在同步模式中， 函数只有当所有输出数据全部写入系统发送缓冲区后，或到达 [[HttpCoreModule#send_timeout|send_timeout]] 设置的超时时限时才返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the case of HTTP 1.1 chunked encoded output, it will just trigger the Nginx core to send out the &quot;last chunk&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015318Z" changeid="xf">
        <seg>在 HTTP 1.1 chunked 编码输出中, 这将导致Nginx核心发送 &quot;last chunk&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the settings above, &lt;code&gt;GET /test?a%20b=1%61+2&lt;/code&gt; will yield:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102753Z" changeid="xf">
        <seg>在上面的设置中, &lt;code&gt;GET /test?a%20b=1%61+2&lt;/code&gt; 的结果为:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, it will immediately return &lt;code&gt;nil&lt;/code&gt; and the string &quot;no memory&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054606Z" changeid="xf">
        <seg>在这种情况下，它将立即返回 &lt;code&gt;nil&lt;/code&gt; 和错误信息 &quot;no memory&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Increments the (numerical) value for &lt;code&gt;key&lt;/code&gt; in the shm-based dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] by the step value &lt;code&gt;value&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060259Z" changeid="xf">
        <seg>为基于共享内存的字典[[#ngx.shared.DICTngx.shared.DICT]]中&lt;code&gt;key&lt;/code&gt;键的数值加上 &lt;code&gt;value&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead, the reading operation on [[#ngx.req.socket|ngx.req.socket]] will just return the error message &quot;client aborted&quot; as the second return value (the first return value is surely &lt;code&gt;nil&lt;/code&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021749Z" changeid="xf">
        <seg>而是从对[[#ngx.req.socket|ngx.req.socket]]的读操作中返回，携带错误信息 &quot;client aborted&quot; 作为第二个返回值 (第一个返回值当然是 &lt;code&gt;nil&lt;/code&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Internal redirection will destroy the original request &lt;code&gt;ngx.ctx&lt;/code&gt; data (if any) and the new request will have an empty &lt;code&gt;ngx.ctx&lt;/code&gt; table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T052643Z" changeid="xf">
        <seg>内部重定向将删除原始请求的 request &lt;code&gt;ngx.ctx&lt;/code&gt; 数据(如果有的话)，新的请求的 &lt;code&gt;ngx.ctx&lt;/code&gt; 是空table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Issue a synchronous but still non-blocking ''Nginx Subrequest'' using &lt;code&gt;uri&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040005Z" changeid="xf">
        <seg>对&lt;code&gt;uri&lt;/code&gt;发起一个同步的但仍是非阻塞的 ''Nginx子请求''。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Issue an &lt;code&gt;HTTP 301&lt;/code&gt; or &lt;code&gt;302&lt;/code&gt; redirection to &lt;code&gt;uri&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034315Z" changeid="xf">
        <seg>发起到&lt;code&gt;uri&lt;/code&gt;的 &lt;code&gt;HTTP 301&lt;/code&gt; 或 &lt;code&gt;302&lt;/code&gt; 重定向.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Issuing a POST subrequest, for example, can be done as follows</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T042121Z" changeid="xf">
        <seg>例如，可以这样发起一个POST子请求</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It also allows the registration of custom meta methods.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035743Z" changeid="xf">
        <seg>而且还允许注册自定义的元方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can also be retrieved later with the value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T041051Z" changeid="xf">
        <seg>也可以在以后与值一起获取到.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can be the current request's [[#ngx.ctx|ngx.ctx]] table, which effectively makes the parent and its subrequest to share exactly the same context table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041754Z" changeid="xf">
        <seg>这个值可以是当前请求的 [[#ngx.ctx|ngx.ctx]] table, 其结果是父请求和子请求共享同一个context able</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is &lt;code&gt;302&lt;/code&gt; (&lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt;) by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034348Z" changeid="xf">
        <seg>默认值是 &lt;code&gt;302&lt;/code&gt; (&lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt;) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is actually implemented like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102528Z" changeid="xf">
        <seg>它的实际实现象这样:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to directly require the packages in external Lua modules:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023904Z" changeid="xf">
        <seg>也可以直接在外部Lua模块里require这两个包:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is also possible to use this &lt;code&gt;ctx&lt;/code&gt; option to share the same [[#ngx.ctx|ngx.ctx]] table between the current (parent) request and the subrequest:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T081945Z" changeid="xf">
        <seg>也可以用 &lt;code&gt;ctx&lt;/code&gt; 在当前（父）请求和子请求之间共享同一个 [[#ngx.ctx|ngx.ctx]] table:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is equivalent to</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033829Z" changeid="xf">
        <seg>等价于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is equivalent to &lt;code&gt;ngx.shared.DICT:set(key, nil)&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T055259Z" changeid="xf">
        <seg>等价于 &lt;code&gt;ngx.shared.DICT:set(key, nil)&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important here to call the [[#tcpsock:settimeout|settimeout]] method ''before'' calling the iterator function (note that the &lt;code&gt;receiveuntil&lt;/code&gt; call is irrelevant here).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T100256Z" changeid="xf">
        <seg>重要的是如果要调用 [[#tcpsock:settimeout|settimeout]] ， 一定要在调用iterator函数''之前''  (注意这里 &lt;code&gt;receiveuntil&lt;/code&gt; 的调用次序无所谓).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important here to call the [[#tcpsock:settimeout|settimeout]] method ''before'' calling this method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074727Z" changeid="xf">
        <seg>要调用 [[#tcpsock:settimeout|settimeout]] 必须在调用本方法 ''之前'' .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important here to call the [[#udpsock:settimeout|settimeout]] method ''before'' calling this method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073723Z" changeid="xf">
        <seg>要调用 [[#udpsock:settimeout|settimeout]] 必须在调用本方法 ''之前'' .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is important to always call the [[#ngx.req.finish_body|ngx.req.finish_body]] after all the data has been appended onto the current request body.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030435Z" changeid="xf">
        <seg>有一点很重要，在所有数据都已加到当前请求体中后，必须调用 [[#ngx.req.finish_body|ngx.req.finish_body]] 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is intended to be compatible with the TCP API of the [http://w3.impa.br/~diego/software/luasocket/tcp.html LuaSocket] library but is 100% nonblocking out of the box.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074242Z" changeid="xf">
        <seg>它被设计为与 [http://w3.impa.br/~diego/software/luasocket/tcp.html LuaSocket]库的 TCP API兼容，但是它天生是100%非阻塞的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is intended to be compatible with the UDP API of the [http://w3.impa.br/~diego/software/luasocket/udp.html LuaSocket] library but is 100% nonblocking out of the box.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065019Z" changeid="xf">
        <seg>它被设计为与 [http://w3.impa.br/~diego/software/luasocket/udp.html LuaSocket]库的 UDP API兼容，但是它天生是100%非阻塞的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended however, to use the [[#ngx.req.read_body|ngx.req.read_body]] and [[#ngx.req.discard_body|ngx.req.discard_body]] functions for finer control over the request body reading process instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102305Z" changeid="xf">
        <seg>推荐使用 [[#ngx.req.read_body|ngx.req.read_body]] 和 [[#ngx.req.discard_body|ngx.req.discard_body]] 函数来对请求体的读取过程进行精细控制。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended to always place the following piece of code at the end of Lua modules that use the I/O operations to prevent casual use of module-level global variables that are shared among ''all'' requests:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T030359Z" changeid="xf">
        <seg>建议总是在使用I/O操作的Lua模块的最后加上下面这段代码以防止随意使用由''所有''请求共享的模块级全局变量:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended to combine the &lt;code&gt;return&lt;/code&gt; statement with this call, i.e., &lt;code&gt;return ngx.redirect(...)&lt;/code&gt;, so as to be more explicit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040140Z" changeid="xf">
        <seg>建议将本方法与 &lt;code&gt;return&lt;/code&gt; 一起使用, 即, &lt;code&gt;return ngx.redirect(...)&lt;/code&gt;, 这样意义更明确.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is recommended, though not necessary, to combine the &lt;code&gt;return&lt;/code&gt; statement with this call, i.e., &lt;code&gt;return ngx.exit(...)&lt;/code&gt;, to give a visual hint to others reading the code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015227Z" changeid="xf">
        <seg>我们建议，虽然不强制, 将&lt;code&gt;return&lt;/code&gt; 语句与此方法一起使用, 如, &lt;code&gt;return ngx.exit(...)&lt;/code&gt;, 为代码的阅读者以提示.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is strongly recommended to combine the &lt;code&gt;return&lt;/code&gt; statement with this call, i.e., &lt;code&gt;return ngx.exec(...)&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032920Z" changeid="xf">
        <seg>强烈建议将此函数与 &lt;code&gt;return&lt;/code&gt; 一起使用, 即, &lt;code&gt;return ngx.exec(...)&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It prevents undesirable race conditions while accessing such variables.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T030628Z" changeid="xf">
        <seg>这避免了访问这些变量时的不希望发生的竞争条件.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns a Lua string rather than a Lua table holding all the parsed query arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023043Z" changeid="xf">
        <seg>它返回装有所有解析过的请求参数的Lua字符串，而不是Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns the &lt;code&gt;1&lt;/code&gt; in case of success and returns &lt;code&gt;nil&lt;/code&gt; with a string describing the error otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073810Z" changeid="xf">
        <seg>成功返回 &lt;code&gt;1&lt;/code&gt; 失败返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It should not be manually modified, renamed, or removed in Lua code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023726Z" changeid="xf">
        <seg>还要在Lua代码中对其进行修改，重命名或删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Its functionality will be implemented in future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101309Z" changeid="xf">
        <seg>其功能将来会实现.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>J             enable the PCRE Javascript compatible mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024036Z" changeid="xf">
        <seg>J             打开 PCRE Javascript兼容模式.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as [[#ngx.print|ngx.print]] but also emit a trailing newline.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041541Z" changeid="xf">
        <seg>同 [[#ngx.print|ngx.print]] 但多发送一个尾部换行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just as any other rewrite phase handlers, [[#rewrite_by_lua|rewrite_by_lua]] also runs in subrequests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074924Z" changeid="xf">
        <seg>与其它的 rewrite phase handlers一样, [[#rewrite_by_lua|rewrite_by_lua]]也运行在 subrequests 中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like [[#ngx.location.capture|ngx.location.capture]], but supports multiple subrequests running in parallel.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082813Z" changeid="xf">
        <seg>同[[#ngx.location.capture|ngx.location.capture]], 但是支持并行的多个子请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like [[#ngx.re.sub|ngx.re.sub]], but does global substitution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032923Z" changeid="xf">
        <seg>类似 [[#ngx.re.sub|ngx.re.sub]], 但是做全局替换.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like the [[#ngx.shared.DICT.set|set]] method, but only stores the key-value pair into the dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] if the key ''does'' exist.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T055106Z" changeid="xf">
        <seg>类似于 [[#ngx.shared.DICT.set|set]] , 但只有在字典[[#ngx.shared.DICTngx.shared.DICT]]中 ''不'' 存在键值的时候才将key-value对写入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just like the [[#ngx.shared.DICT.set|set]] method, but only stores the key-value pair into the dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] if the key does ''not'' exist.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054703Z" changeid="xf">
        <seg>类似于 [[#ngx.shared.DICT.set|set]] , 但只有当键值 ''不'' 存在时才将key-value对存入 [[#ngx.shared.DICT|ngx.shared.DICT]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just to name a few:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031845Z" changeid="xf">
        <seg>以下列出部分:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Just use a Lua table for the argument's value, for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020206Z" changeid="xf">
        <seg>只需要用Lua table作为参数值, 例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys and values are unescaped according to URI escaping rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102737Z" changeid="xf">
        <seg>key和value都根据URI转义规则进行转义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Keys and values will be unescaped according to URI escaping rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013249Z" changeid="xf">
        <seg>键和值都根据URI转义规则进行转义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let us test it:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053622Z" changeid="xf">
        <seg>我们来测试一下:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Library name &lt;code&gt;liblua.so&lt;/code&gt; has been changed in liblua5.1 package, it only comes with &lt;code&gt;liblua5.1.so&lt;/code&gt;, which needs to be symlinked to &lt;code&gt;/usr/lib&lt;/code&gt; so it could be found during the configuration process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032520Z" changeid="xf">
        <seg>liblua5.1包中的库名 &lt;code&gt;liblua.so&lt;/code&gt; 改了，成了 &lt;code&gt;liblua5.1.so&lt;/code&gt;, 需要以 &lt;code&gt;/usr/lib&lt;/code&gt; 中添加符号链接使得在配置过程中能找到这个库.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Likewise, new &quot;eof&quot; flag can also be specified by setting a boolean value to [[#ngx.arg|ngx.arg]][2].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094958Z" changeid="xf">
        <seg>类似的，也可以将[[#ngx.argngx.arg]][2]的值设为新的boolean值来修改 &quot;eof&quot; 标记。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Literal dollar sign characters (&lt;code&gt;$&lt;/code&gt;) in the &lt;code&gt;replace&lt;/code&gt; string argument can be escaped by another dollar sign, for instance,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032454Z" changeid="xf">
        <seg>&lt;code&gt;replace&lt;/code&gt;中的美元符 (&lt;code&gt;$&lt;/code&gt;)可以再用一个美元符进行转义，例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loaded Lua modules persist in the nginx worker process level resulting in a small memory footprint in Lua even when under heavy loads.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041648Z" changeid="xf">
        <seg>被加载的Lua模块保存在nginx worker进程一级，即使在高负载情况下也只有很小的内存开销。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Loading bytecode files via the Lua primitives like &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;dofile&lt;/code&gt; should always work as expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040104Z" changeid="xf">
        <seg>使用Lua内置的操作如 &lt;code&gt;require&lt;/code&gt; 和 &lt;code&gt;dofile&lt;/code&gt; 加载字节码文件应该总能工作.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Location jump will not be triggered otherwise, and only the current request's URI will be modified, which is also the default behavior.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101832Z" changeid="xf">
        <seg>否则不会触发Location跳转, 而只是改变当前请求的 URI, 这也是默认的行为.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Log arguments concatenated to error.log with the given logging level.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041612Z" changeid="xf">
        <seg>用指定的日志级别将参数添加到error.log</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Logically speaking, the [[#ngx.location.capture|ngx.location.capture]] can be implemented like this</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083542Z" changeid="xf">
        <seg>从逻辑上说, [[#ngx.location.capture|ngx.location.capture]] 可以这样来实现</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lua &lt;code&gt;nil&lt;/code&gt; arguments are accepted and result in literal &lt;code&gt;&quot;nil&quot;&lt;/code&gt; string while Lua booleans result in literal &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; string outputs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041655Z" changeid="xf">
        <seg>Lua &lt;code&gt;nil&lt;/code&gt; 将输出 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 字符串 Lua boolean值输出 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lua &lt;code&gt;nil&lt;/code&gt; arguments are accepted and result in literal &lt;code&gt;&quot;nil&quot;&lt;/code&gt; strings while Lua booleans result in literal &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt; strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033946Z" changeid="xf">
        <seg>可接受Lua &lt;code&gt;nil&lt;/code&gt; 参数，写入的值为 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 字符串， 而Lua boolean值会被写入成 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lua &lt;code&gt;nil&lt;/code&gt; values will output &lt;code&gt;&quot;nil&quot;&lt;/code&gt; strings and Lua boolean values will output &lt;code&gt;&quot;true&quot;&lt;/code&gt; and &lt;code&gt;&quot;false&quot;&lt;/code&gt; literal strings respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041036Z" changeid="xf">
        <seg>Lua &lt;code&gt;nil&lt;/code&gt; 值输出为 &lt;code&gt;&quot;nil&quot;&lt;/code&gt; 字符串 ，Lua boolean 值分别输出为 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;false&quot;&lt;/code&gt; 字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Lua tables can be used for both requests and responses when the number of subrequests to be issued is not known in advance:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083446Z" changeid="xf">
        <seg>如果要发起的子请求的数量事先并不确定，可以在请求或响应中使用Lua table:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>LuajIT can be downloaded from the [http://luajit.org/download.html the LuaJIT project website] and Lua 5.1, from the [http://www.lua.org/ Lua project website].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033024Z" changeid="xf">
        <seg>LuajIT 可以从 [http://luajit.org/download.html LuaJIT 官网]下载， Lua 5.1 从 [http://www.lua.org/ Lua官网]下载.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Matches the &lt;code&gt;subject&lt;/code&gt; string using the Perl compatible regular expression &lt;code&gt;regex&lt;/code&gt; with the optional &lt;code&gt;options&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023010Z" changeid="xf">
        <seg>使用Perl兼容的正则表达式&lt;code&gt;regex&lt;/code&gt;和可选的&lt;code&gt;options&lt;/code&gt;选项对&lt;code&gt;subject&lt;/code&gt;字符串进行匹配.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More Nginx APIs for Lua may be supported in this context upon future user requests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064149Z" changeid="xf">
        <seg>如果将来有更多用户要求的话，会为这个上下文添加更多的Nginx API支持。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>More often we just put it into a Lua loop:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025944Z" changeid="xf">
        <seg>更多的时候我们只要将其放入一个Lua循环:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-value arguments are also supported:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102448Z" changeid="xf">
        <seg>也支持多值参数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-value headers can be set this way:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084130Z" changeid="xf">
        <seg>多值头可以这样设置:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multi-value query args are also supported.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020142Z" changeid="xf">
        <seg>支持多值请求参数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013233Z" changeid="xf">
        <seg>如果一个参数的键出现多次，则生成一个包含有所有参数值的table，table中的元素次序与值出现的次序相同.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Multiple occurrences of an argument key will result in a table value holding all the values for that key in order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102717Z" changeid="xf">
        <seg>如果一个参数的key出现多次，则其value是一个按出现顺序保存多个值的table</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named captures are also supported since the &lt;code&gt;v0.7.14&lt;/code&gt; release
and are returned in the same Lua table as key-value pairs as the numbered captures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023355Z" changeid="xf">
        <seg>从&lt;code&gt;v0.7.14&lt;/code&gt;版本开始，支持具名捕捉，捕捉的结果用同一个Lua table返回，以key-value的形式与基于下标的捕捉结果在一起。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named locations are also supported, but query strings are ignored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032332Z" changeid="xf">
        <seg>支持具名location，但是query string将被忽略.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Named locations like &lt;code&gt;@foo&lt;/code&gt; are not allowed due to a limitation in
the nginx core.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041328Z" changeid="xf">
        <seg>由于nginx内核的限制， 不允许有&lt;code&gt;@foo&lt;/code&gt; 这样的具名location。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Near the boundary of the data stream, the data string actually returned could also be shorter than the size limit.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T095716Z" changeid="xf">
        <seg>而在接近数据流边界处, 实际返回的数据也可能比指定的大小小.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nested arrays of strings are permitted and the elements in the arrays will be sent one by one:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041058Z" changeid="xf">
        <seg>支持嵌套的字符串数组，数组中的元素将一个一个地发送:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Network I/O operations in user code should only be done through the Nginx Lua API calls as the Nginx event loop may be blocked and performance drop off dramatically otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024152Z" changeid="xf">
        <seg>用户代码中的网络I/O操作只允许通过Nginx Lua API来进行，否则Nginx事件循环可能被阻塞，导致性能大降。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091743Z" changeid="xf">
        <seg>Nginx 输入过滤器对单个请求可能被调用多次，这是因为响应体可能是分段发送的</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nginx regex group capturing variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;, and etc, can be read by this
interface as well, by writing &lt;code&gt;ngx.var[1]&lt;/code&gt;, &lt;code&gt;ngx.var[2]&lt;/code&gt;, &lt;code&gt;ngx.var[3]&lt;/code&gt;, and etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032429Z" changeid="xf">
        <seg>Nginx 正则表达式组捕捉变量 &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt;等也可以使用这一接口来读取, 写法是 &lt;code&gt;ngx.var[1]&lt;/code&gt;, &lt;code&gt;ngx.var[2]&lt;/code&gt;, &lt;code&gt;ngx.var[3]&lt;/code&gt;, 等等.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nginx variable interpolation is supported in the &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; argument string of this directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073537Z" changeid="xf">
        <seg>本命令的&lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt;参数支持Nginx 变量 interpolation。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nginx variables can be used in the &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; string to provide flexibility.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074301Z" changeid="xf">
        <seg>为了更灵活， &lt;code&gt;&lt;path-to-lua-script-file&gt;&lt;/code&gt; 中允许使用Nginx变量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nginx's subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or ''any'' other nginx C modules like &lt;code&gt;ngx_proxy&lt;/code&gt;, &lt;code&gt;ngx_fastcgi&lt;/code&gt;, &lt;code&gt;ngx_memc&lt;/code&gt;,
&lt;code&gt;ngx_postgres&lt;/code&gt;, &lt;code&gt;ngx_drizzle&lt;/code&gt;, and even ngx_lua itself and etc etc etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040515Z" changeid="xf">
        <seg>Nginx子请求提供了向其它location发起非阻塞的内部请求的强大手段，这些location可以用磁盘文件路径或 ''任何'' 其它ngixn C 模块如 &lt;code&gt;ngx_proxy&lt;/code&gt;, &lt;code&gt;ngx_fastcgi&lt;/code&gt;, &lt;code&gt;ngx_memc&lt;/code&gt;,
&lt;code&gt;ngx_postgres&lt;/code&gt;, &lt;code&gt;ngx_drizzle&lt;/code&gt;, 甚至是ngx_lua自己等等来配置.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No end-of-line translation is performed;
* &lt;code&gt;'*l'&lt;/code&gt;: reads a line of text from the socket.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T085333Z" changeid="xf">
        <seg>不会执行行结束符转换;
* &lt;code&gt;'*l'&lt;/code&gt;: 从socket中按行读取文本.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Non-array table arguments will cause a Lua exception to be thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041130Z" changeid="xf">
        <seg>非数组table参数将抛出Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>None of the current request's subrequests will be affected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021256Z" changeid="xf">
        <seg>当前请求的任何子请求都不会受影响.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note however that Lua global variables (note, not module-level variables) WILL NOT persist between requests because of the one-coroutine-per-request isolation design.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041116Z" changeid="xf">
        <seg>注意，相反， Lua 全局变量 (注意，不是模块级别的变量) 将不会跨请求，这是由一个请求对应一个coroutine的设计理念决定的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;code&gt;ngx.flush&lt;/code&gt; is non functional when in the HTTP 1.0 output buffering mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042406Z" changeid="xf">
        <seg>注意在HTTP 1.0 输出缓冲模式下 &lt;code&gt;ngx.flush&lt;/code&gt; 无效.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that &lt;code&gt;ngx.header&lt;/code&gt; is not a normal Lua table and as such, it is not possible to iterate through it using the Lua &lt;code&gt;ipairs&lt;/code&gt; function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091351Z" changeid="xf">
        <seg>注意 &lt;code&gt;ngx.header&lt;/code&gt; 不是一个正常的Lua table，所以不能使用&lt;code&gt;ipairs&lt;/code&gt;函数来对它进行遍历.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a longer from of the long bracket, &lt;code&gt;[=[...]=]&lt;/code&gt;, may be required if the regex pattern contains &lt;code&gt;&amp;#91;...]&lt;/code&gt; sequences.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031520Z" changeid="xf">
        <seg>注意当正则表达式包括&lt;code&gt;&amp;#91;...]&lt;/code&gt;序列时，可能需要更长的方括号形式&lt;code&gt;[=[...]=]&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a maximum of 100 request arguments are parsed by default (including those with the same name) and that additional request arguments are silently discarded to guard against potential denial of service attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103214Z" changeid="xf">
        <seg>注意，默认最多只解析100个请求参数 (包括名称一样的) ，多出来的请求参数将被简单丢弃，以防止DOS攻击.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that a maximum of 100 request headers are parsed by default (including those with the same name) and that additional request headers are silently discarded to guard against potential denial of service attacks.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015634Z" changeid="xf">
        <seg>注意，默认最多只解析100个请求头 (包括名称一样的) ，多出来的请求头将被简单丢弃，以防止DOS攻击.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that calling this function instead of using &lt;code&gt;ngx.var.request_body&lt;/code&gt; or &lt;code&gt;ngx.var.echo_request_body&lt;/code&gt; is more efficient because it can save one dynamic memory allocation and one data copy.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023523Z" changeid="xf">
        <seg>注意此方法比 &lt;code&gt;ngx.var.request_body&lt;/code&gt; 或 &lt;code&gt;ngx.var.echo_request_body&lt;/code&gt; 更高效，因为它可以节省一次动态内存分配和一次数据拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that common HTTP benchmark tools such as &lt;code&gt;ab&lt;/code&gt; and &lt;code&gt;http_load&lt;/code&gt; issue HTTP 1.0 requests by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040629Z" changeid="xf">
        <seg>注意常用的HTTP benchmark工具如 &lt;code&gt;ab&lt;/code&gt; 和 &lt;code&gt;http_load&lt;/code&gt; 默认发送 HTTP 1.0 请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that if both &lt;code&gt;share_all_vars&lt;/code&gt; and &lt;code&gt;copy_all_vars&lt;/code&gt; are set to true, then &lt;code&gt;share_all_vars&lt;/code&gt; takes precedence.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T055024Z" changeid="xf">
        <seg>注意，如果 &lt;code&gt;share_all_vars&lt;/code&gt; 和 &lt;code&gt;copy_all_vars&lt;/code&gt; 都设为true, &lt;code&gt;share_all_vars&lt;/code&gt; 优先.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it is not possible to use this interface to rewrite URI arguments and that [[#ngx.req.set_uri_args|ngx.req.set_uri_args]] should be used for this instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102203Z" changeid="xf">
        <seg>注意不能使用这个接口来重写URI参数，请使用 [[#ngx.req.set_uri_args|ngx.req.set_uri_args]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that it is recommended to use LuaJIT 2.0 instead of the standard Lua 5.1 interpreter where possible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032325Z" changeid="xf">
        <seg>注意，推荐尽可能使用 LuaJIT 2.0 而不是标准 Lua 5.1 解释器.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that only already defined nginx variables can be written to.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032116Z" changeid="xf">
        <seg>注意只有已经定义了的nginx变量可以被写入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that only three of these constants are utilized by the [[#Nginx API for Lua|Nginx API for Lua]] (i.e., [[#ngx.exit|ngx.exit]] accepts &lt;code&gt;NGX_OK&lt;/code&gt;, &lt;code&gt;NGX_ERROR&lt;/code&gt;, and &lt;code&gt;NGX_DECLINED&lt;/code&gt; as input).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033023Z" changeid="xf">
        <seg>注意这些常量中只有三个能被 [[#Nginx API for Lua|可供Lua调用的Nginx API]]使用 ([[#ngx.exit|ngx.exit]] 接受 &lt;code&gt;NGX_OK&lt;/code&gt;, &lt;code&gt;NGX_ERROR&lt;/code&gt;, and &lt;code&gt;NGX_DECLINED&lt;/code&gt; 作为输入).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that subrequests issued by [[#ngx.location.capture|ngx.location.capture]] inherit all the
request headers of the current request by default and that this may have unexpected side effects on the
subrequest responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082105Z" changeid="xf">
        <seg>注意在默认情况下 [[#ngx.location.capture|ngx.location.capture]] 发起的子请求将从当前请求中继承所有的请求头，这可能会对子请求的响应带来意料之外的副作用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the [[#ngx.var.VARIABLE|ngx.var.HEADER]] API call, which uses core [[HttpCoreModule#$http_HEADER|$http_HEADER]] variables, may be more preferable for reading individual request headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015443Z" changeid="xf">
        <seg>注意，使用内核模块[[HttpCoreModule#$http_HEADER$http_HEADER]]的 [[#ngx.var.VARIABLE|ngx.var.HEADER]] API, 可能更适合用来读取某一个头信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the [http://mdounin.ru/hg/ngx_http_auth_request_module/ ngx_auth_request] module can be approximated by using [[#access_by_lua|access_by_lua]]:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094135Z" changeid="xf">
        <seg>注意 [http://mdounin.ru/hg/ngx_http_auth_request_module/ ngx_auth_request] 模块可以用 [[#access_by_luaaccess_by_lua]]来实现.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the [http://www.grid.net.ru/nginx/eval.en.html ngx_eval] module can be approximated by using [[#rewrite_by_lua|rewrite_by_lua]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074843Z" changeid="xf">
        <seg>注意 [http://www.grid.net.ru/nginx/eval.en.html ngx_eval] 模块可以用 [[#rewrite_by_lua|rewrite_by_lua]]来实现.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so the size limit specified here also applies to every single Nginx worker process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102012Z" changeid="xf">
        <seg>注意cosocket连接池是每个nginx worker进程所有的而不是整个nginx服务器进程所有，所以这里所设置的上限也适用于每个单独的nginx worker 进程.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104342Z" changeid="xf">
        <seg>注意cosocket连接池是每个nginx worker进程所有的而不是整个nginx服务器进程所有，所以这里所设置的上限也适用于每个单独的nginx worker 进程.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the following API functions are currently disabled within this context:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072426Z" changeid="xf">
        <seg>注意在这个上下文中以下 API 函数是被禁止的:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the size of the connection pool cannot be changed once the pool is created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101928Z" changeid="xf">
        <seg>注意当连接池一旦被创建，将不能改变其大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the value of an expired key is not guaranteed to be available so one should never rely on the availability of expired items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034850Z" changeid="xf">
        <seg>注意已过期的键的值并不能保证可用，所以不能依赖于过期项的可用性。.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that there is no need to call this method on socket objects that have invoked the [[#tcpsock:setkeepalive|setkeepalive]] method because the socket object is already closed (and the current connection is saved into the built-in connection pool).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T100751Z" changeid="xf">
        <seg>注意不需要对调用过[[#tcpsock:setkeepalivesetkeepalive]]方法的socket对象调用此方法，因为socket对象已经关闭了 (相应的连接被保存进内置的连接池).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that there is normally no need to manually send out response headers as ngx_lua will automatically send headers out
before content is output with [[#ngx.say|ngx.say]] or [[#ngx.print|ngx.print]] or when [[#content_by_lua|content_by_lua]] exits normally.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040435Z" changeid="xf">
        <seg>注意通常并不需要手动发送响应头，因为在[[#ngx.sayngx.say]] 或 [[#ngx.printngx.print]]之前或[[#content_by_luacontent_by_lua]]显式地退出时ngx_lua将自动地发送响应头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this data sharing is on a ''per-worker'' basis and not on a ''per-server'' basis.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041909Z" changeid="xf">
        <seg>注意这种数据共享是 ''worker''级别 而不是 ''server''级别 的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this handler always runs ''after'' the standard [[HttpAccessModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080947Z" changeid="xf">
        <seg>注意这个handler总是在标准 [[HttpAccessModule]] ''之后''执行 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this handler always runs ''after'' the standard [[HttpRewriteModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074529Z" changeid="xf">
        <seg>注意这个handler总是在标准 [[HttpRewriteModule]] ''之后''执行 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this is very different from [[#ngx.redirect|ngx.redirect]] in that
it is just an internal redirect and no new HTTP traffic is involved.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032556Z" changeid="xf">
        <seg>注意，这跟 [[#ngx.redirect|ngx.redirect]] 是完全不同的，它只是一个内部重定向，并没有新的HTTP流量产生.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that this method does ''not'' affect the [[#lua_socket_keepalive_timeout|lua_socket_keepalive_timeout]] setting; the &lt;code&gt;timeout&lt;/code&gt; argument to the [[#tcpsock:setkeepalive|setkeepalive]] method should be used for this purpose instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101223Z" changeid="xf">
        <seg>注意本方法 ''不会'' 影响 [[#lua_socket_keepalive_timeout|lua_socket_keepalive_timeout]] 设置; 必须通过 [[#tcpsock:setkeepalivesetkeepalive]]的&lt;code&gt;timeout&lt;/code&gt; 参数来达到这个目的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that using the Lua coroutine mechanism means that this function does not block the Nginx event loop even in the synchronous mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042222Z" changeid="xf">
        <seg>注意使用Lua coroutine机制意味着此函数即使在同步模式下也不会阻塞 Nginx 事件循环.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when calling &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; within a [[#access_by_lua|access_by_lua]] handler, the nginx request processing control flow will still continue to the content handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094253Z" changeid="xf">
        <seg>注意在 [[#access_by_luaaccess_by_lua]] handler中调用&lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt;时, nginx请求处理控制流仍然会继续执行 content handler.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that when calling &lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt; within a [[#rewrite_by_lua|rewrite_by_lua]] handler, the nginx request processing control flow will still continue to the content handler.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T075749Z" changeid="xf">
        <seg>注意在 [[#rewrite_by_lua|rewrite_by_lua]] handler中调用&lt;code&gt;ngx.exit(ngx.OK)&lt;/code&gt;时, nginx请求处理控制流仍然会继续执行 content handler.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that while this method accepts all [[#HTTP status constants|HTTP status constants]] as input, it only accepts &lt;code&gt;NGX_OK&lt;/code&gt; and &lt;code&gt;NGX_ERROR&lt;/code&gt; of the [[#core constants|core constants]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015151Z" changeid="xf">
        <seg>注意，虽然这个方法接受所有的 [[#HTTP status constants|HTTP状态常量]]作为输入, 但是在[[#core constantscore constants]]中仅支持 &lt;code&gt;NGX_OK&lt;/code&gt; 和 &lt;code&gt;NGX_ERROR&lt;/code&gt;。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, LRU takes priority over expiration time here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T042217Z" changeid="xf">
        <seg>注意，在这里LRU比过期时间优先级高。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, the &lt;code&gt;options&lt;/code&gt; argument is not optional when the &lt;code&gt;ctx&lt;/code&gt; argument is specified and that the empty Lua string (&lt;code&gt;&quot;&quot;&lt;/code&gt;) must be used as placeholder for &lt;code&gt;options&lt;/code&gt; if no meaningful regex options are required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025331Z" changeid="xf">
        <seg>注意，如果指定了&lt;code&gt;ctx&lt;/code&gt;参数， &lt;code&gt;options&lt;/code&gt; 参数就是必选的，即使不需要有意义的正则选项，也要提供空的Lua字符串 (&lt;code&gt;&quot;&quot;&lt;/code&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that, the actual data returned ''might'' be a little longer than the size limit specified by the &lt;code&gt;size&lt;/code&gt; argument when the boundary pattern has ambiguity for streaming parsing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T095500Z" changeid="xf">
        <seg>注意，如果用来做流解析的边界模式有歧义，实际返回的数据 ''可能'' 会比&lt;code&gt;size&lt;/code&gt;参数指定的长度略长.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Number literals can be used directly as the argument, for instance,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015107Z" changeid="xf">
        <seg>可以直接用数字作为参数，例如，</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022359Z" changeid="xf">
        <seg>在 FreeBSD 上, 你只能在系统级别配置 TCP keepalive, 如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On a ThinkPad T400 2.80 GHz laptop, the Hello World example readily achieves 28k req/sec using &lt;code&gt;http_load -p 10&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T034316Z" changeid="xf">
        <seg>在一个 ThinkPad T400 2.80 GHz 笔记本上, 使用 &lt;code&gt;http_load -p 10&lt;/code&gt;， Hello World例子轻松达到 28k req/sec .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>On the other hand, the following will not work as expected:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074627Z" changeid="xf">
        <seg>而下面的代码将不能得到预期的结果:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can also create infinite re-occuring timers, for instance, a timer getting triggered every &lt;code&gt;5&lt;/code&gt; seconds, by calling &lt;code&gt;ngx.timer.at&lt;/code&gt; recursively in the timer callback function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T023347Z" changeid="xf">
        <seg>也可以通过在回调函数里递归调用 &lt;code&gt;ngx.timer.at&lt;/code&gt;创建无限次重复调用的定时器, 例如, 每 &lt;code&gt;5&lt;/code&gt; 秒触发一次的定时器.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can specify fractional seconds like &lt;code&gt;0.001&lt;/code&gt; to mean 1
millisecond here.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T022207Z" changeid="xf">
        <seg>可以用小数点如 &lt;code&gt;0.001&lt;/code&gt; 表示 1
毫秒.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One can specify time resolution up to 0.001 seconds (i.e., one milliseconds).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015843Z" changeid="xf">
        <seg>时间的精度可以到 0.001 seconds (即毫秒).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only Lua tables are accepted (Only the last element in the table will take effect for standard headers such as &lt;code&gt;Content-Type&lt;/code&gt; that only accept a single value).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T090243Z" changeid="xf">
        <seg>仅支持 Lua table (对于只支持单个值的标准头如&lt;code&gt;Content-Type&lt;/code&gt;，只有table中的最后一个元素起作用</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only [[#tcpsock:receive|receive]] and [[#tcpsock:receiveuntil|receiveuntil]] methods are supported on this object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031646Z" changeid="xf">
        <seg>此对象只支持 [[#tcpsock:receive|receive]] 和 [[#tcpsock:receiveuntil|receiveuntil]] 方法.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only a small set of the [[#Nginx API for Lua|Nginx API for Lua]] is supported in this context:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064106Z" changeid="xf">
        <seg>这个上下文中只支持很少一部分 [[#Nginx API for Lua|Nginx API for Lua]] :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the direct &quot;parent coroutine&quot; can wait on its child &quot;light thread&quot;, otherwise a Lua exception will be raised.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021110Z" changeid="xf">
        <seg>只有直接的&quot;父coroutine&quot;可以等待子&quot;轻量线程&quot;, 否则会抛出Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Only the first occurrence of the match is returned, or &lt;code&gt;nil&lt;/code&gt; if no match is found.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023026Z" changeid="xf">
        <seg>只返回第一个匹配项, 无匹配则返回&lt;code&gt;nil&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Original request headers should be ignored by setting 
[[HttpProxyModule#proxy_pass_request_headers|proxy_pass_request_headers]] to &lt;code&gt;off&lt;/code&gt; in subrequest locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082305Z" changeid="xf">
        <seg>在子请求的location中应设置 
[[HttpProxyModule#proxy_pass_request_headers|proxy_pass_request_headers]] 为 &lt;code&gt;off&lt;/code&gt;来忽略主请求的头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other scripting language implementations typically struggle to match this performance level.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T034138Z" changeid="xf">
        <seg>其它的脚本语言实现一般都很难达到这个级别的性能.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Otherwise, it returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T070237Z" changeid="xf">
        <seg>否则返回 &lt;code&gt;nil&lt;/code&gt; 和描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overrides the current request's request method with the &lt;code&gt;request_id&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095554Z" changeid="xf">
        <seg>用&lt;code&gt;request_id&lt;/code&gt;参数覆盖当前请求的请求方法.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Overriding &lt;code&gt;ngx.ctx&lt;/code&gt; with a new Lua table is also supported, for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035805Z" changeid="xf">
        <seg>用一个新的Lua table来覆盖 &lt;code&gt;ngx.ctx&lt;/code&gt; 也是支持的, 例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Parse the http time string (as returned by [[#ngx.http_time|ngx.http_time]]) into seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022822Z" changeid="xf">
        <seg>解析http时间字符串 (象 [[#ngx.http_time|ngx.http_time]] 的返回值) 得到秒数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pending timers are those timers that have not expired yet.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022736Z" changeid="xf">
        <seg>未过期定时器指尚未过期的定时器.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please also refer to restrictions on capturing locations configured by [[#Locations_Configured_by_Subrequest_Directives_of_Other_Modules|subrequest directives of other modules]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082737Z" changeid="xf">
        <seg>请参阅 [[#Locations_Configured_by_Subrequest_Directives_of_Other_Modules|其它模块的子请求命令]]了解子请求location的限制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please ensure that the file specified by the &lt;code&gt;file_name&lt;/code&gt; argument exists and is readable by an Nginx worker process by setting its permission properly to avoid Lua exception errors.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024321Z" changeid="xf">
        <seg>请保证 &lt;code&gt;file_name&lt;/code&gt; 参数指定的文件真实存在，并且正确设置其访问权限，便利Nginx worker进程能够访问它，以避免抛出Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note however, that Lua code written inlined within nginx.conf
such as those specified by [[#set_by_lua|set_by_lua]], [[#content_by_lua|content_by_lua]],
[[#access_by_lua|access_by_lua]], and [[#rewrite_by_lua|rewrite_by_lua]] will ''always'' be
cached because only the Nginx config file parser can correctly parse the &lt;code&gt;nginx.conf&lt;/code&gt;
file and the only ways to to reload the config file
are to send a &lt;code&gt;HUP&lt;/code&gt; signal or to restart Nginx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T042755Z" changeid="xf">
        <seg>但是请注意，在nginx.conf中内置写入的 Lua 代码，如 [[#set_by_lua|set_by_lua]], [[#content_by_lua|content_by_lua]],
[[#access_by_lua|access_by_lua]], 和 [[#rewrite_by_lua|rewrite_by_lua]]中的，将“总是”被缓存，因为只有 Nginx 配置文件解析器能够正确解析 &lt;code&gt;nginx.conf&lt;/code&gt;
文件，重新加载配置文件的方法是发送 &lt;code&gt;HUP&lt;/code&gt; 信号或重启 Nginx.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note that both &lt;code&gt;ngx.print&lt;/code&gt; and [[#ngx.say|ngx.say]] will always invoke the whole Nginx output body filter chain, which is an expensive operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041427Z" changeid="xf">
        <seg>请注意 &lt;code&gt;ngx.print&lt;/code&gt; 和 [[#ngx.say|ngx.say]] 都将启动整个 Nginx 输出体过滤器链, 开销比较大.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note that ignoring request body is not the right way to discard it, and that this function must be called to avoid breaking things under HTTP 1.1 keepalive or HTTP 1.1 pipelining.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022851Z" changeid="xf">
        <seg>请注意，无视请求体（译注：无视指认为请求体不存在，与本方法的不同是不会从连接中读取请求体数据）不是丢弃它的正确方法, 因此必须调用本方法来防止在HTTP 1.1 keepalive 或 HTTP 1.1 pipelining时出错.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note that the bytecode format used by LuaJIT 2.0 is not compatible with that used by the standard Lua 5.1 interpreter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035547Z" changeid="xf">
        <seg>请注意 LuaJIT 2.0 使用的字节码格式与标准Lua 5.1解释器使用的格式不兼容.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please note that while internally the key-value pair is set atomically, the atomicity does not go across the method call boundary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054402Z" changeid="xf">
        <seg>请注意虽然在内部实现中key-value对的写入是原子操作，但其原子性并不跨越方法调用的边界.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please refer to the official LuaJIT documentation on the &lt;code&gt;-b&lt;/code&gt; option for more details:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035720Z" changeid="xf">
        <seg>请参阅官方 LuaJIT 文档了解 &lt;code&gt;-b&lt;/code&gt; 选项的细节:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please submit bug reports, wishlists, or patches by</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T054117Z" changeid="xf">
        <seg>请用以下方法提交bug，功能需求或补丁</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Please use LuaJIT 2.0, which supports a fully resumable VM, to avoid this.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T025627Z" changeid="xf">
        <seg>请使用 LuaJIT 2.0, 它支持完全可恢复虚拟机, 来避免这个问题.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Possible return values are</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102638Z" changeid="xf">
        <seg>可能的返回值有</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Premature timer expiration happens when the Nginx worker process is
trying to shut down, as in an Nginx configuration reload triggered by
the &lt;code&gt;HUP&lt;/code&gt; signal or in an Nginx server shutdown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T022759Z" changeid="xf">
        <seg>过早的定时器过期的发生是&lt;code&gt;HUP&lt;/code&gt;导致重新加载Nginx配置或Nginx服务器关闭导致Nginx worker进程尝试关闭.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Puts the current socket's connection immediately into the cosocket built-in connection pool and keep it alive until other [[#tcpsock:connect|connect]] method calls request it or the associated maximal idle timeout is expired.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101617Z" changeid="xf">
        <seg>立即将当前socket的连接存入 cosocket 内置连接池，保持其存活状态，直接对其再次调用 [[#tcpsock:connect|connect]] 或设置的最大空闲时间到期了.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read and write Nginx variable values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032052Z" changeid="xf">
        <seg>读写Nginx变量的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Read and write the current request's response status.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083614Z" changeid="xf">
        <seg>读写当前请求的响应状态码。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reading &lt;code&gt;ngx.header.HEADER&lt;/code&gt; will return the value of the response header named &lt;code&gt;HEADER&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T090951Z" changeid="xf">
        <seg>读取 &lt;code&gt;ngx.header.HEADER&lt;/code&gt; 将返回名为 &lt;code&gt;HEADER&lt;/code&gt;的响应头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reads the client request body synchronously without blocking the Nginx event loop.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021331Z" changeid="xf">
        <seg>同步读取客户端请求体，但是不阻塞Nginx事件循环.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receives data from the UDP or datagram unix domain socket object with an optional receive buffer size argument, &lt;code&gt;size&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073612Z" changeid="xf">
        <seg>从UDP或数据报unix domain socket对象接收数据，可用 &lt;code&gt;size&lt;/code&gt; 指定缓冲区大小.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Receives data from the connected socket according to the reading pattern or size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T084300Z" changeid="xf">
        <seg>根据指定的读取模式或大小从已连接的socket中读取数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Redirecting arbitrary external URLs is also supported, for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034626Z" changeid="xf">
        <seg>也支持重定向到任意的外部URLs , 例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Regardless of the presence of the &lt;code&gt;pos&lt;/code&gt; field in the &lt;code&gt;ctx&lt;/code&gt; table, &lt;code&gt;ngx.re.match&lt;/code&gt; will always set this &lt;code&gt;pos&lt;/code&gt; field to the position ''after'' the substring matched by the whole pattern in case of a successful match.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024958Z" changeid="xf">
        <seg>不管&lt;code&gt;ctx&lt;/code&gt; table中是否有 &lt;code&gt;pos&lt;/code&gt; ， &lt;code&gt;ngx.re.match&lt;/code&gt;在成功匹配后，都会将 &lt;code&gt;pos&lt;/code&gt; 的值置为整个模板匹配到的子串的后一位.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Registers a user Lua function as the callback which gets called automatically when the client closes the (downstream) connection prematurely.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021402Z" changeid="xf">
        <seg>将一个用户Lua函数注册成为回调函数，当客户端过早关闭（下游）连接时会调用此回调函数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removing the &lt;code&gt;max_args&lt;/code&gt; cap is strongly discouraged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T012939Z" changeid="xf">
        <seg>强烈不建议去掉&lt;code&gt;max_args&lt;/code&gt; 限制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Removing the &lt;code&gt;max_headers&lt;/code&gt; cap is strongly discouraged.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015726Z" changeid="xf">
        <seg>去除&lt;code&gt;max_headers&lt;/code&gt; 限制是非常不推荐的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request &lt;code&gt;GET /lua&lt;/code&gt; will give the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T054939Z" changeid="xf">
        <seg>&lt;code&gt;GET /lua&lt;/code&gt; 的结果是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Request &lt;code&gt;GET /lua&lt;/code&gt; yields the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T081959Z" changeid="xf">
        <seg>请求 &lt;code&gt;GET /lua&lt;/code&gt; 的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resumes the executation of a user Lua coroutine object previously yielded or just created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035147Z" changeid="xf">
        <seg>恢复一个之前挂起或刚创建的用户Lua coroutine的执行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieves in-memory request body data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023020Z" changeid="xf">
        <seg>获取内存中的请求体数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieves the current request's request method name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095356Z" changeid="xf">
        <seg>获得当前请求的请求方法名称.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieves the current running phase name.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102633Z" changeid="xf">
        <seg>返回当前运行的阶段名称.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieves the file name for the in-file request body data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023558Z" changeid="xf">
        <seg>获取文件中请求体数据的文件名.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Retrieving the value in the dictionary [[#ngx.shared.DICT|ngx.shared.DICT]] for the key &lt;code&gt;key&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034319Z" changeid="xf">
        <seg>获取字典 [[#ngx.shared.DICT|ngx.shared.DICT]] 中键 &lt;code&gt;key&lt;/code&gt; 所对应的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns &lt;code&gt;1&lt;/code&gt; if the callback is registered successfully or returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021430Z" changeid="xf">
        <seg>注册成功返回&lt;code&gt;1&lt;/code&gt; 否则返回 &lt;code&gt;nil&lt;/code&gt; 和错误字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns &lt;code&gt;nil&lt;/code&gt; for unrecognized values.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095131Z" changeid="xf">
        <seg>遇到不支持的版本号返回&lt;code&gt;nil&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;str&lt;/code&gt; is not well formed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020659Z" changeid="xf">
        <seg>如果&lt;code&gt;str&lt;/code&gt;格式错误将返回&lt;code&gt;nil&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns &lt;code&gt;nil&lt;/code&gt; if the request body has not been read or has been read into memory.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023651Z" changeid="xf">
        <seg>如果请求体尚未被读取或已经被读入内存，将返回&lt;code&gt;nil&lt;/code&gt;。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns &lt;code&gt;true&lt;/code&gt; if the current request is an nginx subrequest, or &lt;code&gt;false&lt;/code&gt; otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022917Z" changeid="xf">
        <seg>如果当前请求是nginx子请求，返回&lt;code&gt;true&lt;/code&gt; 否则返回 &lt;code&gt;false&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns &lt;code&gt;true&lt;/code&gt; if the response headers have been sent (by ngx_lua), and &lt;code&gt;false&lt;/code&gt; otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040621Z" changeid="xf">
        <seg>如果响应头已经被(ngx_lua)发送，返回 &lt;code&gt;true&lt;/code&gt;，否则返回 &lt;code&gt;false&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a 3rd value, &lt;code&gt;stale&lt;/code&gt;, indicating whether the key has expired or not.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034747Z" changeid="xf">
        <seg>同时返回第3个值, &lt;code&gt;stale&lt;/code&gt;, 指明此键是否已过期.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Lua table holding all the current request POST query arguments (of the MIME type &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013029Z" changeid="xf">
        <seg>返回当前所有请求的POST请求参数 (MIME类型为 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Lua table holding all the current request URL query arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102601Z" changeid="xf">
        <seg>返回存有当前请求URL请求参数的Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Lua table holding all the current request headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015327Z" changeid="xf">
        <seg>返回持有当前请求所有头的Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Lua table with three slots (&lt;code&gt;res.status&lt;/code&gt;, &lt;code&gt;res.header&lt;/code&gt;, &lt;code&gt;res.body&lt;/code&gt;, and &lt;code&gt;res.truncated&lt;/code&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040924Z" changeid="xf">
        <seg>返回一个Lua table，内容包括三项 (&lt;code&gt;res.status&lt;/code&gt;, &lt;code&gt;res.header&lt;/code&gt;, &lt;code&gt;res.body&lt;/code&gt;, and &lt;code&gt;res.truncated&lt;/code&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a Lua thread (or Lua coroutine) object represents this &quot;light thread&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013842Z" changeid="xf">
        <seg>返回代表这个''轻量线程''的Lua线程 (或称 Lua coroutine) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a floating-point number for the elapsed time in seconds (including milliseconds as the decimal part) from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022221Z" changeid="xf">
        <seg>从nginx缓存的时间返回浮点数形式的从公元纪年到当前时间的秒数（小数部分是毫秒数） (不象Lua date库，这里没有系统调用).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a floating-point number representing the timestamp (including milliseconds as the decimal part) when the current request was created.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094240Z" changeid="xf">
        <seg>返回表示当前请求创建时间的浮点数 (小数部分为毫秒).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a formated string can be used as the cookie expiration time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022457Z" changeid="xf">
        <seg>返回按cookie超时时间格式化的时间字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a formated string can be used as the http header time (for example, being used in &lt;code&gt;Last-Modified&lt;/code&gt; header).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022742Z" changeid="xf">
        <seg>返回http头中时间格式的时间字符串 (例如 &lt;code&gt;Last-Modified&lt;/code&gt; 头).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a quoted SQL string literal according to the MySQL quoting rules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021852Z" changeid="xf">
        <seg>根据MySQL的引号规则返回对参数进行转义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns a read-only cosocket object that wraps the downstream connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031251Z" changeid="xf">
        <seg>返回包装了下游连接的只读cosocket对象.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns current date (in the format &lt;code&gt;yyyy-mm-dd&lt;/code&gt;) from the nginx cached time (no syscall involved unlike Lua's date library).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022056Z" changeid="xf">
        <seg>从nginx缓存的时间中返回当前日期 (格式为&lt;code&gt;yyyy-mm-dd&lt;/code&gt;) (不象Lua date库，这里没有系统调用).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the HTTP version number for the current request as a Lua number.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094434Z" changeid="xf">
        <seg>以Lua number的形式返回当前请求的HTTP版本号.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the binary form of the MD5 digest of the &lt;code&gt;str&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021633Z" changeid="xf">
        <seg>返回&lt;code&gt;str&lt;/code&gt;MD5文摘的二进制数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the binary form of the SHA-1 digest of the &lt;code&gt;str&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021709Z" changeid="xf">
        <seg>返回&lt;code&gt;str&lt;/code&gt;SHA-1文摘的二进制数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the current time stamp (in the format &lt;code&gt;yyyy-mm-dd hh:mm:ss&lt;/code&gt;) of the nginx cached time (no syscall involved unlike Lua's [http://www.lua.org/manual/5.1/manual.html#pdf-os.date os.date] function).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022410Z" changeid="xf">
        <seg>从nginx缓存的时间中返回当前时间戳 (格式为&lt;code&gt;yyyy-mm-dd hh:mm:ss&lt;/code&gt;) (不象Lua 的[http://www.lua.org/manual/5.1/manual.html#pdf-os.date os.date]函数，这里没有系统调用).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the elapsed seconds from the epoch for the current time stamp from the nginx cached time (no syscall involved unlike Lua's date library).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022049Z" changeid="xf">
        <seg>从nginx缓存的时间返回从公元纪年到当前时间的秒数 (不象Lua date库，这里没有系统调用).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the hexadecimal representation of the MD5 digest of the &lt;code&gt;str&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021621Z" changeid="xf">
        <seg>返回&lt;code&gt;str&lt;/code&gt;MD5文摘的16进制文本串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the new resulting number if the operation is successfully completed or &lt;code&gt;nil&lt;/code&gt; and an error message otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060206Z" changeid="xf">
        <seg>如果成功，返回结果值否则返回 &lt;code&gt;nil&lt;/code&gt; 和错误信息.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the number of items that have actually been flushed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060625Z" changeid="xf">
        <seg>返回实际被清除的项的数目。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the original raw HTTP protocol header received by the Nginx server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095215Z" changeid="xf">
        <seg>返回Nginx服务器接收到的原始HTTP协议头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns the seconds or &lt;code&gt;nil&lt;/code&gt; if the input string is in bad forms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022848Z" changeid="xf">
        <seg>如果输入字符串格式不对，返回 &lt;code&gt;nil&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Returns three values:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034945Z" changeid="xf">
        <seg>返回3个值:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rewrite the current request's (parsed) URI by the &lt;code&gt;uri&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095730Z" changeid="xf">
        <seg>用&lt;code&gt;uri&lt;/code&gt;参数覆盖当前请求的 (解析过的) URI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rewrite the current request's URI query arguments by the &lt;code&gt;args&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102310Z" changeid="xf">
        <seg>用&lt;code&gt;args&lt;/code&gt;覆盖当前请求的URI请求参数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Run the Lua source code inlined as the &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; at the &lt;code&gt;log&lt;/code&gt; request processing phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091439Z" changeid="xf">
        <seg>在请求处理的 &lt;code&gt;log&lt;/code&gt; 阶段运行&lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt;中的lua代码.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Running timers are those timers whose user callback functions are still running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022828Z" changeid="xf">
        <seg>正在运行的定时器指用户指定的回调函数仍在运行的定时器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Runs the Lua code specified by the argument &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062828Z" changeid="xf">
        <seg>在Nginx主进程（如果存在的话）加载Nginx配置文件时在全局Lua虚拟机级别运行由参数&lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt;指定的Lua代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See HTTP method constants methods other than POST.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053144Z" changeid="xf">
        <seg>除POST外还有其它的HTTP方法常量。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See [[#Data_Sharing_within_an_Nginx_Worker|Data Sharing within an Nginx Worker]] for the reasons behind this.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T030648Z" changeid="xf">
        <seg>参阅 [[#Data_Sharing_within_an_Nginx_Worker|Data Sharing within an Nginx Worker]] 了解背后的原因.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See [[#HTTP 1.0 support|HTTP 1.0 support]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042416Z" changeid="xf">
        <seg>参阅 [[#HTTP 1.0 support|HTTP 1.0 支持]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See [[#ngx.flush|ngx.flush]] for more details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041336Z" changeid="xf">
        <seg>详情参阅 [[#ngx.flush|ngx.flush]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See [[#ngx.md5_bin|ngx.md5_bin]] if the raw binary MD5 digest is required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021557Z" changeid="xf">
        <seg>如果需要MD5文摘的二进制数据用 [[#ngx.md5_bin|ngx.md5_bin]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See [[#ngx.md5|ngx.md5]] if the hexadecimal form of the MD5 digest is required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021648Z" changeid="xf">
        <seg>如果需要十六进制文本串，使用[[#ngx.md5|ngx.md5]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See [[#ngx.shared.DICT|ngx.shared.DICT]] for details.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102508Z" changeid="xf">
        <seg>详情见[[#ngx.shared.DICT|ngx.shared.DICT]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#lua_check_client_abort|lua_check_client_abort]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021938Z" changeid="xf">
        <seg>参阅[[#lua_check_client_abort|lua_check_client_abort]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.now|ngx.now]] and [[#ngx.update_time|ngx.update_time]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094401Z" changeid="xf">
        <seg>参阅 [[#ngx.now|ngx.now]] 和 [[#ngx.update_time|ngx.update_time]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.on_abort|ngx.on_abort]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022501Z" changeid="xf">
        <seg>参阅 [[#ngx.on_abort|ngx.on_abort]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.get_body_data|ngx.req.get_body_data]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023810Z" changeid="xf">
        <seg>参阅[[#ngx.req.get_body_data|ngx.req.get_body_data]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.get_body_file|ngx.req.get_body_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053310Z" changeid="xf">
        <seg>参阅 [[#ngx.req.get_body_file|ngx.req.get_body_file]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.get_method|ngx.req.get_method]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095659Z" changeid="xf">
        <seg>参阅 [[#ngx.req.get_method|ngx.req.get_method]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.init_body|ngx.req.init_body]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031041Z" changeid="xf">
        <seg>参阅 [[#ngx.req.init_body|ngx.req.init_body]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.read_body|ngx.req.read_body]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022952Z" changeid="xf">
        <seg>参阅[[#ngx.req.read_body|ngx.req.read_body]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.set_body_data|ngx.req.set_body_data]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024328Z" changeid="xf">
        <seg>参阅 [[#ngx.req.set_body_data|ngx.req.set_body_data]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.set_body_file|ngx.req.set_body_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024042Z" changeid="xf">
        <seg>参阅 [[#ngx.req.set_body_file|ngx.req.set_body_file]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.set_method|ngx.req.set_method]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095525Z" changeid="xf">
        <seg>参阅[[#ngx.req.set_method|ngx.req.set_method]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.req.set_uri|ngx.req.set_uri]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102523Z" changeid="xf">
        <seg>参阅[[#ngx.req.set_uri|ngx.req.set_uri]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.shared.DICT.flush_all|ngx.shared.DICT.flush_all]] and [[#ngx.shared.DICT|ngx.shared.DICT]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060709Z" changeid="xf">
        <seg>参阅 [[#ngx.shared.DICT.flush_all|ngx.shared.DICT.flush_all]] 和 [[#ngx.shared.DICT|ngx.shared.DICT]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.shared.DICT.flush_expired|ngx.shared.DICT.flush_expired]] and [[#ngx.shared.DICT|ngx.shared.DICT]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060508Z" changeid="xf">
        <seg>参阅 [[#ngx.shared.DICT.flush_expired|ngx.shared.DICT.flush_expired]] 和 [[#ngx.shared.DICT|ngx.shared.DICT]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.shared.DICT|ngx.shared.DICT]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034609Z" changeid="xf">
        <seg>参阅 [[#ngx.shared.DICT|ngx.shared.DICT]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.socket.tcp|ngx.socket.tcp]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065037Z" changeid="xf">
        <seg>参阅 [[#ngx.socket.tcp|ngx.socket.tcp]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>See also [[#ngx.socket.udp|ngx.socket.udp]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074310Z" changeid="xf">
        <seg>参阅 [[#ngx.socket.udp|ngx.socket.udp]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sends data on the current UDP or datagram unix domain socket object.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T070213Z" changeid="xf">
        <seg>在当前的 UDP 或数据报unix domain socket对象上发送数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sends data without blocking on the current TCP or Unix Domain Socket connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T075105Z" changeid="xf">
        <seg>发送数据，不阻塞当前TCP或Unix domain socket连接.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set the current request's request body using the in-file data specified by the &lt;code&gt;file_name&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024124Z" changeid="xf">
        <seg>将当前请求的请求体设置成&lt;code&gt;file_name&lt;/code&gt; 参数指定的文件的内容.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set the current request's request body using the in-memory data specified by the &lt;code&gt;data&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023909Z" changeid="xf">
        <seg>将当前请求的请求体设置成&lt;code&gt;data&lt;/code&gt; 参数指定的内存数据 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set the current request's request header named &lt;code&gt;header_name&lt;/code&gt; to value &lt;code&gt;header_value&lt;/code&gt;, overriding any existing ones.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020903Z" changeid="xf">
        <seg>将当前请求名为 &lt;code&gt;header_name&lt;/code&gt; 的头的值设为&lt;code&gt;header_value&lt;/code&gt;, 替换其当前的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set the timeout value in milliseconds for subsequent socket operations ([[#tcpsock:connect|connect]], [[#tcpsock:receive|receive]], and iterators returned from [[#tcpsock:receiveuntil|receiveuntil]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101039Z" changeid="xf">
        <seg>以毫秒为单位设置后续 socket操作([[#tcpsock:connectconnect]], [[#tcpsock:receivereceive]], and iterators returned from [[#tcpsock:receiveuntilreceiveuntil]])的超时时间.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set the timeout value in milliseconds for subsequent socket operations (like [[#udpsock:receive|receive]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074059Z" changeid="xf">
        <seg>设置后续socket操作(如 [[#udpsock:receivereceive]])的超时时间，以毫秒计.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Set, add to, or clear the current request's &lt;code&gt;HEADER&lt;/code&gt; response header that is to be sent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084009Z" changeid="xf">
        <seg>对当前请求的 &lt;code&gt;HEADER&lt;/code&gt; 响应头进行设置、添加和清除.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the Lua C-module search path used by scripts specified by [[#set_by_lua|set_by_lua]],
[[#content_by_lua|content_by_lua]] and others.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062333Z" changeid="xf">
        <seg>设置由[[#set_by_luaset_by_lua]],
[[#content_by_luacontent_by_lua]]或其它指定写入的Lua脚本代码使用的C模块查找路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sets the Lua module search path used by scripts specified by [[#set_by_lua|set_by_lua]],
[[#content_by_lua|content_by_lua]] and others.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061758Z" changeid="xf">
        <seg>设置由 [[#set_by_luaset_by_lua]],
[[#content_by_luacontent_by_lua]]或其它指令写入的Lua脚本代码使用的Lua模块查找路径.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting &lt;code&gt;ngx.header.HEADER&lt;/code&gt; after sending out response headers (either explicitly with [[#ngx.send_headers|ngx.send_headers]] or implicitly with [[#ngx.print|ngx.print]] and similar) will throw out a Lua exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T090913Z" changeid="xf">
        <seg>在发送完响应头 (用 [[#ngx.send_headersngx.send_headers]]显式发送 或 用 [[#ngx.printngx.print]] 和类似方法隐式发送)设置&lt;code&gt;ngx.header.HEADER&lt;/code&gt; 将抛出Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting &lt;code&gt;ngx.status&lt;/code&gt; after the response header is sent out has no effect but leaving an error message in your nginx's error log file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083721Z" changeid="xf">
        <seg>在发送了响应头之后设置 &lt;code&gt;ngx.status&lt;/code&gt; 没有作用，但会在ngxin错误日志文件里产生一条错误信息: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting &lt;code&gt;ngx.var.Foo&lt;/code&gt; to a &lt;code&gt;nil&lt;/code&gt; value will unset the &lt;code&gt;$Foo&lt;/code&gt; Nginx variable.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032331Z" changeid="xf">
        <seg>将 &lt;code&gt;ngx.var.Foo&lt;/code&gt; 设置为 &lt;code&gt;nil&lt;/code&gt; 将取消 &lt;code&gt;$Foo&lt;/code&gt; Nginx 变量的定义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Setting a slot to &lt;code&gt;nil&lt;/code&gt; effectively removes it from the response headers:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T090312Z" changeid="xf">
        <seg>将值设置成 &lt;code&gt;nil&lt;/code&gt; 的结果是将它从响应头中删除:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Settings done by this method takes priority over those config directives, i.e., [[#lua_socket_connect_timeout|lua_socket_connect_timeout]], [[#lua_socket_send_timeout|lua_socket_send_timeout]], and [[#lua_socket_read_timeout|lua_socket_read_timeout]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101008Z" changeid="xf">
        <seg>使用本方法作的设置优先级高于使用配置命令, 包括 [[#lua_socket_connect_timeout|lua_socket_connect_timeout]], [[#lua_socket_send_timeout|lua_socket_send_timeout]], 和 [[#lua_socket_read_timeout|lua_socket_read_timeout]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Settings done by this method takes priority over those config directives, like [[#lua_socket_read_timeout|lua_socket_read_timeout]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074130Z" changeid="xf">
        <seg>用本方法作的设置优先级高于使用配置命令如 [[#lua_socket_read_timeout|lua_socket_read_timeout]]等.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to [[#ngx.re.match|ngx.re.match]], but returns a Lua iterator instead, so as to let the user programmer iterate all the matches over the &lt;code&gt;&lt;subject&gt;&lt;/code&gt; string argument with the PCRE &lt;code&gt;regex&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025825Z" changeid="xf">
        <seg>与[[#ngx.re.match|ngx.re.match]]类似, 但返回 a Lua iterator, 使开发者可以遍历所有PCRE &lt;code&gt;regex&lt;/code&gt;对&lt;code&gt;&lt;subject&gt;&lt;/code&gt;字符串的匹配结果.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the [[#ngx.shared.DICT.add|add]] method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T055002Z" changeid="xf">
        <seg>类似于 [[#ngx.shared.DICT.add|add]], 但当共享内存区空间不足时不会（以LRU的方式）覆盖未过期的项.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the [[#ngx.shared.DICT.get|get]] method but returns the value even if the key has already expired.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034724Z" changeid="xf">
        <seg>类似于 [[#ngx.shared.DICT.get|get]] 但即使键过期了，仍返回其值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the [[#ngx.shared.DICT.set|set]] method, but never overrides the (least recently used) unexpired items in the store when running out of storage in the shared memory zone.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054906Z" changeid="xf">
        <seg>与 [[#ngx.shared.DICT.set|set]] 类似, 但在共享存储区空间不够时不会(以LRU的方式)覆盖未过期的项.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create coroutine.create] API, but works in the context of the Lua coroutines created by ngx_lua.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035205Z" changeid="xf">
        <seg>与标准的Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.create coroutine.create] API类似, 但工作在由ngx_lua创建的Lua coroutine上下文中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume coroutine.resume] API, but works in the context of the Lua coroutines created by ngx_lua.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035229Z" changeid="xf">
        <seg>与标准的Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.resume coroutine.resume] API类似, 但工作在由ngx_lua创建的Lua coroutine上下文中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap coroutine.wrap] API, but works in the context of the Lua coroutines created by ngx_lua.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035337Z" changeid="xf">
        <seg>与标准的Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.wrap coroutine.wrap] API类似, 但工作在由ngx_lua创建的Lua coroutine上下文中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similar to the standard Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield coroutine.yield] API, but works in the context of the Lua coroutines created by ngx_lua.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035311Z" changeid="xf">
        <seg>与标准的Lua [http://www.lua.org/manual/5.1/manual.html#pdf-coroutine.yield coroutine.yield] API类似, 但工作在由ngx_lua创建的Lua coroutine上下文中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, Nginx config</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101947Z" changeid="xf">
        <seg>类似的, Nginx 配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if only [[#content_by_lua|content_by_lua]] is specified,
the request body will not be read until the content handler's Lua code is
about to run (i.e., the request body will be read during the content phase).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102227Z" changeid="xf">
        <seg>类似的，, 如果只设置了 [[#content_by_lua|content_by_lua]] , 请求体将在进行内容处理Lua 代码将要运行时被读取 (即, 请求体将在content阶段被读取).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, if using the standard Lua 5.1 interpreter with ngx_lua, Lua compatible bytecode files must be generated using the &lt;code&gt;luac&lt;/code&gt; commandline utility as shown:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035812Z" changeid="xf">
        <seg>类似的, 如果在ngx_lua中使用标准Lua 5.1, 要象下面这样用&lt;code&gt;luac&lt;/code&gt;生成兼容的字节码文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, the following directives provided by [[HttpEncryptedSessionModule]] can be invoked from within Lua too:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042126Z" changeid="xf">
        <seg>类似的, 也可以在Lua中调用 [[HttpEncryptedSessionModule]]提供的命令:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since &lt;code&gt;v0.8.3&lt;/code&gt; this function returns &lt;code&gt;1&lt;/code&gt; on success, or returns &lt;code&gt;nil&lt;/code&gt; and a string describing the error otherwise.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040232Z" changeid="xf">
        <seg>从&lt;code&gt;v0.8.3&lt;/code&gt; 版本开始这个函数成功时返回 &lt;code&gt;1&lt;/code&gt; , 出错时 returns &lt;code&gt;nil&lt;/code&gt; 和 描述错误的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the &lt;code&gt;0.6.9&lt;/code&gt; release, all the header names in the Lua table returned are converted to the pure lower-case form by default, unless the &lt;code&gt;raw&lt;/code&gt; argument is set to &lt;code&gt;true&lt;/code&gt; (default to &lt;code&gt;false&lt;/code&gt;).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015842Z" changeid="xf">
        <seg>从&lt;code&gt;0.6.9&lt;/code&gt;版本开始, 默认Lua table中的所有头名称将被转换成纯小写，除非 &lt;code&gt;raw&lt;/code&gt; 参数被设为 &lt;code&gt;true&lt;/code&gt; (默认为&lt;code&gt;false&lt;/code&gt;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the &lt;code&gt;0.7.20&lt;/code&gt; release, The &lt;code&gt;0&lt;/code&gt; time argument can also be specified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015931Z" changeid="xf">
        <seg>从&lt;code&gt;0.7.20&lt;/code&gt; 版本起, 支持 &lt;code&gt;0&lt;/code&gt; 作为时间参数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since the &lt;code&gt;v0.7.18&lt;/code&gt; release, connecting to a datagram unix domain socket file is also possible on Linux:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065847Z" changeid="xf">
        <seg>从 &lt;code&gt;v0.7.18&lt;/code&gt; 版本开始, 也可以连接到Linux上的数据报unix domain socket 文件:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sleeps for the specified seconds without blocking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015848Z" changeid="xf">
        <seg>非阻塞地睡眠指定的时间.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021224Z" changeid="xf">
        <seg>所以</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So be careful when calling either of these two in a tight loop; buffer the data yourself in Lua and save the calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041512Z" changeid="xf">
        <seg>所以如果在循环中调用它们时要小心，请自行缓冲数据以减少调用次数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So ensure that the
[[EventsModule#worker_connections|worker_connections]] directive is set to
a large enough value that takes into account both the real connections
and fake connections required by timer callbacks (as limited by the
[[#lua_max_running_timers|lua_max_running_timers]] directive).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T043001Z" changeid="xf">
        <seg>所以要确保 
[[EventsModule#worker_connections|worker_connections]] 命令设置得足够大, 同时考虑定时器回调函数(由
[[#lua_max_running_timerslua_max_running_timers]] 命令设置)所需要的真实连接和假连接的数量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So even &lt;code&gt;1&lt;/code&gt; byte buffer size should still work everywhere but the performance could be terrible.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103316Z" changeid="xf">
        <seg>所以即使是 &lt;code&gt;1&lt;/code&gt; 字节的缓冲区大小也可以工作，只是性能会很糟糕。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So for the example above, if the incoming data stream is &lt;code&gt;'hello, world!</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T094506Z" changeid="xf">
        <seg>所以在上面的例子中, 如果输入数据流是 &lt;code&gt;'hello, world!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if using LuaJIT 2.0 with ngx_lua, LuaJIT compatible bytecode files must be generated as shown:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035628Z" changeid="xf">
        <seg>所以如果在ngx_lua中使用 LuaJIT 2.0, 需要这样生成LuaJIT兼容的字节码:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So if you do ''not'' want to re-initialize the shm storage in your &lt;code&gt;init_by_lua&lt;/code&gt; code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your &lt;code&gt;init_by_lua&lt;/code&gt; code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063904Z" changeid="xf">
        <seg>所以如果在这种情况下如果你不希望在&lt;code&gt;init_by_lua&lt;/code&gt;代码中重新对共享存储进行初始化，你只需要在共享存储中设置一个标记，并在 &lt;code&gt;init_by_lua&lt;/code&gt; 代码中检查这个标记.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So it is also prohibited to abort a running &quot;light thread&quot; that is pending on one ore more Nginx subrequests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T014849Z" changeid="xf">
        <seg>所以也禁止中断一个与一个或多个Nginx子请求绑定的正在运行的 &quot;轻量线程&quot; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So objects with the same lifetime as the
request creating them, like [[#ngx.socket.tcp|cosockets]], cannot be shared between the
original request and the timer user callback function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T023043Z" changeid="xf">
        <seg>所以，与创建它们的请求具有相同生命周期的对象，如 [[#ngx.socket.tcp|cosockets]], 不能在原始请求与定时器用户回调函数之间共享.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So one will get Lua exception for accessing the &lt;code&gt;nil&lt;/code&gt; value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T030311Z" changeid="xf">
        <seg>这样就会因为获取不到模块导致Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the following snippet will not work as expected:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031019Z" changeid="xf">
        <seg>所以下面的代码无法正常运行:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So the following will work as expected:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074545Z" changeid="xf">
        <seg>以下代码会得到预期的结果:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So this method can also be used to determine if the current connection comes from the pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102438Z" changeid="xf">
        <seg>所以此方法也可以用来确定当前连接是否是从池中来的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So when a HTTP 1.0 request is made and the [[#lua_http10_buffering|lua_http10_buffering]] directive is turned &lt;code&gt;on&lt;/code&gt;, ngx_lua will buffer the
output of [[#ngx.say|ngx.say]] and [[#ngx.print|ngx.print]] calls and also postpone sending response headers until all the response body output is received.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040345Z" changeid="xf">
        <seg>所以如果是HTTP 1.0请求而且[[#lua_http10_buffering|lua_http10_buffering]] 命令被置为 &lt;code&gt;on&lt;/code&gt;, ngx_lua 将会缓存把 [[#ngx.say|ngx.say]] 和[[#ngx.print|ngx.print]] 的输出，并延迟发送响应头，直到得到所有的响应体.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So when you need to read from an Nginx variable repeatedly in your Lua code, cache the Nginx variable value to your own Lua variable, for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032721Z" changeid="xf">
        <seg>所以如果在Lua代码中需要多次读取一个Nginx变量, 请将Nginx变量的值赋给你自己的Lua变量, 例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Socket objects that have not invoked this method (and associated connections) will be closed when the socket object is released by the Lua GC (Garbage Collector) or the current client HTTP request finishes processing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074009Z" changeid="xf">
        <seg>没有调用此方法的Socket对象 (及相关的连接) 会被Lua GC或当前客户端HTTP请求结束处理过程释放.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some distribution package managers also distribute LuajIT and/or Lua.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033045Z" changeid="xf">
        <seg>有一些发行版包管理器也发布 LuajIT 和/或 Lua.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some special nginx variables like &lt;code&gt;$args&lt;/code&gt; and &lt;code&gt;$limit_rate&lt;/code&gt; can be assigned a value,
some are not, like &lt;code&gt;$arg_PARAMETER&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032243Z" changeid="xf">
        <seg>有些nginx变量，如 &lt;code&gt;$args&lt;/code&gt; 和 &lt;code&gt;$limit_rate&lt;/code&gt; 可以被设值,
有些则不行, 如 &lt;code&gt;$arg_PARAMETER&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Spawns a new user &quot;light thread&quot; with the Lua function &lt;code&gt;func&lt;/code&gt; as well as those optional arguments &lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;, and etc.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T014436Z" changeid="xf">
        <seg>使用Lua函数&lt;code&gt;func&lt;/code&gt;及可选参数&lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt;等创建一个新的用户&quot;轻量线程&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifies the &quot;match limit&quot; used by the PCRE library when executing the [[#ngx.re.match|ngx.re API]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060714Z" changeid="xf">
        <seg>指定在执行[[#ngx.re.matchngx.re API]]时PCRE库所使用的 &quot;match limit&quot; 参数。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifies the buffer size used by cosocket reading operations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103203Z" changeid="xf">
        <seg>指定cosocket读操作的缓冲区大小。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifies the maximum number of entries allowed in the worker process level compiled regex cache.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T054234Z" changeid="xf">
        <seg>设置在worker进程级别允许缓存的编译后正则表达式的条数</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104135Z" changeid="xf">
        <seg>指定与每个远程服务器(由主机-端口号或unix domain socket文件路径标识)所关联的每个cosocket连接池的大小（连接数）上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specify &lt;code&gt;options&lt;/code&gt; to control how the match operation will be performed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023452Z" changeid="xf">
        <seg>指定&lt;code&gt;options&lt;/code&gt; 选项来控制如何进行匹配.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Strings like &lt;code&gt;&quot;GET&quot;&lt;/code&gt; and &lt;code&gt;&quot;POST&quot;&lt;/code&gt; are returned instead of numerical [[#HTTP method constants|method constants]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095438Z" changeid="xf">
        <seg>返回值是如&lt;code&gt;&quot;GET&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;POST&quot;&lt;/code&gt; 这样的字符串而不是数字 [[#HTTP method constants|方法常量]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Subrequests are completely different from HTTP 301/302 redirection (via [[#ngx.redirect|ngx.redirect]]) and internal redirection (via [[#ngx.exec|ngx.exec]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T040817Z" changeid="xf">
        <seg>子请求与 HTTP 301/302 重定向(通过 [[#ngx.redirect|ngx.redirect]]) 和 内部重定向 (通过[[#ngx.exec|ngx.exec]]) 是完全不同的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Substitutes the first match of the Perl compatible regular expression &lt;code&gt;regex&lt;/code&gt; on the &lt;code&gt;subject&lt;/code&gt; argument string with the string or function argument &lt;code&gt;replace&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032053Z" changeid="xf">
        <seg>将 Perl 兼容的正则表达式 &lt;code&gt;regex&lt;/code&gt; 对 &lt;code&gt;subject&lt;/code&gt; 字符串参数的第一个匹配替换为字符串或函数参数 &lt;code&gt;replace&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Such boilerplate &quot;light thread&quot; are also called &quot;entry threads&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T014316Z" changeid="xf">
        <seg>这个标准&quot;轻量线程&quot;也称为&quot;入口线程&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by [[#access_by_lua|access_by_lua]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094042Z" changeid="xf">
        <seg>如果客户端的IP地址在黑名单中，则请求将在[[#access_by_luaaccess_by_lua]]进行MySQL查询进行更复杂的认证之前被拒绝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, it will read that &lt;code&gt;size&lt;/code&gt; of data on each invocation and will return &lt;code&gt;nil&lt;/code&gt; at the last invocation (either sees the boundary pattern or meets an error).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T094911Z" changeid="xf">
        <seg>对它的每次调用都会读取 &lt;code&gt;size&lt;/code&gt; 字节的数据，最后一次调用（遇到边界模式或出错）返回 &lt;code&gt;nil&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, nginx variables cannot be created on-the-fly.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032205Z" changeid="xf">
        <seg>也就是说，nginx变量不能随需创建.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, one should ''not'' assign it to a variable belonging to persistent namespace like a Lua package.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T030136Z" changeid="xf">
        <seg>也就是说， ''不要'' 把它赋值给一个属于持久命名空间如Lua package的变量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, the &lt;code&gt;ngx.ctx.foo&lt;/code&gt; entry persists across the rewrite, access, and content phases of a request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034946Z" changeid="xf">
        <seg>这说明 &lt;code&gt;ngx.ctx.foo&lt;/code&gt; 在请求的rewrite, access, 和 content各个阶段都有效。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, they will take Lua boolean values &lt;code&gt;true&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102847Z" changeid="xf">
        <seg>即他们的值为 boolean 值&lt;code&gt;true&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, when the body filter sees a chunk containing the word &quot;hello&quot;, then it will set the &quot;eof&quot; flag to true immediately, resulting in truncated but still valid responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T095334Z" changeid="xf">
        <seg>当过滤器看到包含 &quot;hello&quot; 的数据块, 就立即将 &quot;eof&quot; 标记设为true, 产生被截断但仍然是有效的响应内容。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>That is, when there are multiple nginx worker processes under an Nginx master, data sharing cannot cross the process boundary between these workers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041345Z" changeid="xf">
        <seg>也就是说，如果在Nginx master下有多个nginx worker进程，数据共享不会跨越这些worker之间的进程边界.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;light threads&quot; are not scheduled in a pre-emptive way.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T015115Z" changeid="xf">
        <seg>&quot;轻量线程&quot;的调度是抢占式的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;match table&quot; fed into the &lt;code&gt;replace&lt;/code&gt; function is exactly the same as the return value of [[#ngx.re.match|ngx.re.match]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032653Z" changeid="xf">
        <seg> &lt;code&gt;replace&lt;/code&gt; 函数的 &lt;code&gt;replace&lt;/code&gt; 参数与 [[#ngx.re.match|ngx.re.match]] 的返回值完全一样.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;parent coroutine&quot; can call [[#ngx.thread.wait|ngx.thread.wait]] to wait on the termination of its child &quot;light thread&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T015844Z" changeid="xf">
        <seg>&quot;父coroutine&quot; 可以调用 [[#ngx.thread.wait|ngx.thread.wait]] 来等待子 &quot;轻量线程&quot; 结束.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &quot;pending
timers&quot; here mean timers that have not yet been expired and &quot;running
timers&quot; are those whose user callbacks are currently running.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042542Z" changeid="xf">
        <seg>&quot;等待中的定时器&quot; 指尚未到期的定时器 &quot;运行中的定时器&quot; 指其user回调函数当前正在运行的定时器.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;-bg&lt;/code&gt; option can be used to include debug information in the LuaJIT bytecode file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035655Z" changeid="xf">
        <seg>可以用 &lt;code&gt;-bg&lt;/code&gt; 选项在LuaJIT字节码文件中包含调试信息:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;&lt;size&gt;&lt;/code&gt; argument accepts size units such as &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102457Z" changeid="xf">
        <seg>&lt;code&gt;&lt;size&gt;&lt;/code&gt; 参数支持象 &lt;code&gt;k&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt;这样的大小单位:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;&lt;time&gt;&lt;/code&gt; argument can be an integer, with an optional time unit, like &lt;code&gt;s&lt;/code&gt; (second), &lt;code&gt;ms&lt;/code&gt; (millisecond), &lt;code&gt;m&lt;/code&gt; (minute).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102710Z" changeid="xf">
        <seg>&lt;code&gt;&lt;time&gt;&lt;/code&gt; 参数可以是整数，时间单位可选, 如&lt;code&gt;s&lt;/code&gt; (秒), &lt;code&gt;ms&lt;/code&gt; (毫秒), &lt;code&gt;m&lt;/code&gt; (分钟).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;[=[...]=]&lt;/code&gt; form may be used as the default form if desired.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031553Z" changeid="xf">
        <seg>如果需要可以将 &lt;code&gt;[=[...]=]&lt;/code&gt; 作为默认的正则书写形式.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;__index&lt;/code&gt; metamethod will not be added when the &lt;code&gt;raw&lt;/code&gt; argument is set to &lt;code&gt;true&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T020715Z" changeid="xf">
        <seg>如果&lt;code&gt;raw&lt;/code&gt;参数被设为&lt;code&gt;true&lt;/code&gt;，则不会添加 &lt;code&gt;__index&lt;/code&gt; 元方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;args&lt;/code&gt; argument can be either a Lua string, as in</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102326Z" changeid="xf">
        <seg> &lt;code&gt;args&lt;/code&gt; 参数可以是 Lua 字符串, 如</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;args&lt;/code&gt; option can also take plain query strings:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053601Z" changeid="xf">
        <seg>&lt;code&gt;args&lt;/code&gt; 选项也可以直接使用 query string字符串:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;args&lt;/code&gt; option can specify extra URI arguments, for instance,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053230Z" changeid="xf">
        <seg> &lt;code&gt;args&lt;/code&gt; 选项可以用来指定其它的 URI 参数, 例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;args&lt;/code&gt;, &lt;code&gt;vars&lt;/code&gt;, or &lt;code&gt;copy_all_vars&lt;/code&gt; options are generally preferable instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053857Z" changeid="xf">
        <seg>更推荐使用 &lt;code&gt;args&lt;/code&gt;, &lt;code&gt;vars&lt;/code&gt;, 或 &lt;code&gt;copy_all_vars&lt;/code&gt; 这些选项.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;auto_clean&lt;/code&gt; is default to &lt;code&gt;false&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024230Z" changeid="xf">
        <seg> &lt;code&gt;auto_clean&lt;/code&gt; 默认为 &lt;code&gt;false&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;copy_all_vars&lt;/code&gt; option provides a copy of the parent request's Nginx variables to subrequests when such subrequests are issued.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T054130Z" changeid="xf">
        <seg> &lt;code&gt;copy_all_vars&lt;/code&gt; 在发起子请求时为子请求提供父请求Nginx变量的拷贝。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;ctx&lt;/code&gt; option can be used to specify a custom Lua table to serve as the [[#ngx.ctx|ngx.ctx]] table for the subrequest.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T081752Z" changeid="xf">
        <seg> &lt;code&gt;ctx&lt;/code&gt; 选项用来为子请求指定自定义的 [[#ngx.ctx|ngx.ctx]] table 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;ctx&lt;/code&gt; table argument combined with the &lt;code&gt;a&lt;/code&gt; regex modifier can be used to construct a lexer atop &lt;code&gt;ngx.re.match&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025221Z" changeid="xf">
        <seg>使用&lt;code&gt;ctx&lt;/code&gt; 参数和 &lt;code&gt;a&lt;/code&gt; 正则修饰符的组合可以在 &lt;code&gt;ngx.re.match&lt;/code&gt; 基础上实现词法分析器.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;header_value&lt;/code&gt; can take an array list of values,
for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021105Z" changeid="xf">
        <seg> &lt;code&gt;header_value&lt;/code&gt; 可以接受一个数组存放多个值,
例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;inclusive&lt;/code&gt; takes a boolean value to control whether to include the pattern string in the returned data string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T100534Z" changeid="xf">
        <seg> &lt;code&gt;inclusive&lt;/code&gt; 是一个布尔值，用来控制在返回的数据字符串中是否包括模式串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;jump&lt;/code&gt; can only be set to &lt;code&gt;true&lt;/code&gt; in [[#rewrite_by_lua|rewrite_by_lua]] and [[#rewrite_by_lua_file|rewrite_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102032Z" changeid="xf">
        <seg> &lt;code&gt;jump&lt;/code&gt; 只能在[[#rewrite_by_luarewrite_by_lua]] 和 [[#rewrite_by_lua_filerewrite_by_lua_file]]中被设为 &lt;code&gt;true&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;log_level&lt;/code&gt; argument can take constants like &lt;code&gt;ngx.ERR&lt;/code&gt; and &lt;code&gt;ngx.WARN&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041720Z" changeid="xf">
        <seg> &lt;code&gt;log_level&lt;/code&gt; 参数可以是象&lt;code&gt;ngx.ERR&lt;/code&gt; &lt;code&gt;ngx.WARN&lt;/code&gt;这样的常量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;method&lt;/code&gt; option is &lt;code&gt;ngx.HTTP_GET&lt;/code&gt; by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053159Z" changeid="xf">
        <seg>默认的 &lt;code&gt;method&lt;/code&gt; 选项是 &lt;code&gt;ngx.HTTP_GET&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;mydata&lt;/code&gt; module in this example will only be loaded and run on the first request to the location &lt;code&gt;/lua&lt;/code&gt;,
and all subsequent requests to the same nginx worker process will use the reloaded instance of the
module as well as the same copy of the data in it, until a &lt;code&gt;HUP&lt;/code&gt; signal is sent to the Nginx master process to force a reload.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041846Z" changeid="xf">
        <seg>本例中的 &lt;code&gt;mydata&lt;/code&gt; 模块代码仅在第一个对&lt;code&gt;/lua&lt;/code&gt;的请求中加载，然后运行, 所有对同一个nginx worker进程的后续请求将使用这个模块的同一个实例，包括其中的数据，直到向Nginx master进程发送 &lt;code&gt;HUP&lt;/code&gt; 信号强制重新加载配置.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;ngx.DECLINED&lt;/code&gt; constant was first introduced in the &lt;code&gt;v0.5.0rc19&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033133Z" changeid="xf">
        <seg>&lt;code&gt;ngx.DECLINED&lt;/code&gt; 常量在 &lt;code&gt;v0.5.0rc19&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;ngx.null&lt;/code&gt; constant is a &lt;code&gt;NULL&lt;/code&gt; light userdata usually used to represent nil values in Lua tables etc and is similar to the [http://www.kyne.com.au/~mark/software/lua-cjson.php lua-cjson] library's &lt;code&gt;cjson.null&lt;/code&gt; constant.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033403Z" changeid="xf">
        <seg>&lt;code&gt;ngx.null&lt;/code&gt; 常量是一个 &lt;code&gt;NULL&lt;/code&gt; 轻量 userdata，通常用于表示Lua table等中的nil值，类似于 [http://www.kyne.com.au/~mark/software/lua-cjson.php lua-cjson] 库的&lt;code&gt;cjson.null&lt;/code&gt; 常量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;ngx.null&lt;/code&gt; constant will yield the &lt;code&gt;&quot;null&quot;&lt;/code&gt; string output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041220Z" changeid="xf">
        <seg> &lt;code&gt;ngx.null&lt;/code&gt; 常量输出为 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;o&lt;/code&gt; option is useful for performance tuning, because the regex pattern in question will only be compiled once, cached in the worker-process level, and shared among all requests in the current Nginx worker process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024700Z" changeid="xf">
        <seg> &lt;code&gt;o&lt;/code&gt; 选项对性能调优很有用，因为正则模板只编译一次，在worker进程级别进行缓存，被当前Nginx worker进程的所有请求所共享.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;rewrite_by_lua&lt;/code&gt; code will always run at the end of the &lt;code&gt;rewrite&lt;/code&gt; request-processing phase unless [[#rewrite_by_lua_no_postpone|rewrite_by_lua_no_postpone]] is turned on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080621Z" changeid="xf">
        <seg>除非[[#rewrite_by_lua_no_postpone|rewrite_by_lua_no_postpone]]被设成on， &lt;code&gt;rewrite_by_lua&lt;/code&gt;总是在&lt;code&gt;rewrite&lt;/code&gt;请求处理阶段的最后执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;rewrite_by_lua_file&lt;/code&gt; code will always run at the end of the &lt;code&gt;rewrite&lt;/code&gt; request-processing phase unless [[#rewrite_by_lua_no_postpone|rewrite_by_lua_no_postpone]] is turned on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080852Z" changeid="xf">
        <seg>除非[[#rewrite_by_lua_no_postpone|rewrite_by_lua_no_postpone]]被设成on， &lt;code&gt;rewrite_by_lua_file&lt;/code&gt;总是在&lt;code&gt;rewrite&lt;/code&gt;请求处理阶段的最后执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;share_all_vars&lt;/code&gt; option controls whether to share nginx variables among the current request and its subrequests.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053706Z" changeid="xf">
        <seg>&lt;code&gt;share_all_vars&lt;/code&gt;选项控制是否将本请求中的Nginx变量值与子请求共享。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;status&lt;/code&gt; argument can be &lt;code&gt;ngx.OK&lt;/code&gt;, &lt;code&gt;ngx.ERROR&lt;/code&gt;, &lt;code&gt;ngx.HTTP_NOT_FOUND&lt;/code&gt;,
&lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt;, or other [[#HTTP status constants|HTTP status constants]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015001Z" changeid="xf">
        <seg> &lt;code&gt;status&lt;/code&gt; 参数可以是&lt;code&gt;ngx.OK&lt;/code&gt;, &lt;code&gt;ngx.ERROR&lt;/code&gt;, &lt;code&gt;ngx.HTTP_NOT_FOUND&lt;/code&gt;,
&lt;code&gt;ngx.HTTP_MOVED_TEMPORARILY&lt;/code&gt;, 或其它[[#HTTP status constants|HTTP状态常量]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;uri&lt;/code&gt; argument must be a Lua string and cannot be of zero length, or a Lua exception will be thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095756Z" changeid="xf">
        <seg> &lt;code&gt;uri&lt;/code&gt; 参数必须是一个Lua string，长度必须大于0，不然会抛出Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;value&lt;/code&gt; argument can be any valid Lua numbers, like negative numbers or floating-point numbers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060325Z" changeid="xf">
        <seg> &lt;code&gt;value&lt;/code&gt; 参数可以是任何有效的 Lua 数值, 如负数或浮点数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The &lt;code&gt;value&lt;/code&gt; argument inserted can be Lua booleans, numbers, strings, or &lt;code&gt;nil&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T035140Z" changeid="xf">
        <seg>被插入的 &lt;code&gt;value&lt;/code&gt; 参数可以是 Lua布尔值, 数字，字符串, 或r &lt;code&gt;nil&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The API is exposed to Lua in the form of two standard packages &lt;code&gt;ngx&lt;/code&gt; and &lt;code&gt;ndk&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023441Z" changeid="xf">
        <seg>这套API是以两个标准包 &lt;code&gt;ngx&lt;/code&gt; and &lt;code&gt;ndk&lt;/code&gt; 的形式暴露给Lua的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The CR and LF characters are not included in the returned line.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T085547Z" changeid="xf">
        <seg>在返回的行文本中不包括回车和换行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The HTTP 1.0 protocol does not support chunked output and requires an explicit &lt;code&gt;Content-Length&lt;/code&gt; header when the response body is not empty in order to support the HTTP 1.0 keep-alive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040218Z" changeid="xf">
        <seg>HTTP 1.0 协议不支持分块输出， 要支持HTTP 1.0 keep-alive，在响应体非空时，在响应头中需要显式地提供&lt;code&gt;Content-Length&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua code cache can be temporarily disabled during development by 
switching [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; in &lt;code&gt;nginx.conf&lt;/code&gt; to avoid reloading Nginx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073832Z" changeid="xf">
        <seg>在开发阶段，Lua代码缓存可以通过在&lt;code&gt;nginx.conf&lt;/code&gt;中设置 [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; 来避免重新加载Nginx配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua code cache can be temporarily disabled during development by switching [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; in &lt;code&gt;nginx.conf&lt;/code&gt; to avoid reloading Nginx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080811Z" changeid="xf">
        <seg>在开发阶段，Lua代码缓存可以通过在&lt;code&gt;nginx.conf&lt;/code&gt;中设置 [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; 来避免重新加载Nginx配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua code cache can be temporarily disabled during development by switching [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; in &lt;code&gt;nginx.conf&lt;/code&gt; to avoid repeatedly reloading Nginx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094420Z" changeid="xf">
        <seg>在开发阶段，Lua代码缓存可以通过在&lt;code&gt;nginx.conf&lt;/code&gt;中设置 [[#lua_code_cache|lua_code_cache]] &lt;code&gt;off&lt;/code&gt; 来避免重新加载Nginx配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding [[#ngx.arg|ngx.arg]][1] with a Lua string or a Lua table of strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094720Z" changeid="xf">
        <seg>Lua 代码可以修改 [[#ngx.arg|ngx.arg]][1] 将自己修改后的输入数据块作为Lua string或装有string的Lua table送到下游的Nginx输出体过滤器中。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua code may make [[#Nginx API for Lua|API calls]] and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074051Z" changeid="xf">
        <seg>Lua代码可以调用 [[#Nginx API for Lua|API]] 并以一个拥有独立的全局环境的新生成的coroutine（即一个sandbox）的形式运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua files referenced in [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#access_by_lua_file|access_by_lua_file]],
and [[#rewrite_by_lua_file|rewrite_by_lua_file]] will not be cached
and the Lua &lt;code&gt;package.loaded&lt;/code&gt; table will be cleared
at the entry point of every request (such that Lua modules
will not be cached either).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T042421Z" changeid="xf">
        <seg>在[[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#access_by_lua_file|access_by_lua_file]],
和 [[#rewrite_by_lua_file|rewrite_by_lua_file]]中引用的Lua文件不会被缓存， Lua的 &lt;code&gt;package.loaded&lt;/code&gt; table会在每个请求的入口被清空 (所以 Lua 模块也不会被缓存).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua interpreter or LuaJIT instance is shared across all the requests in a single nginx worker process but request contexts are segregated using lightweight Lua coroutines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T041534Z" changeid="xf">
        <seg>在单个nginx worker进程中Lua解释器或LuaJIT实例为所有请求所共享，但是请求上下文使用了轻量的Lua coroutine进行了隔离。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua module is actually loaded by the first Nginx request handler and is cached by the &lt;code&gt;require()&lt;/code&gt; built-in in the package.loaded table for later reference, and &lt;code&gt;require()&lt;/code&gt; has the side effect of setting a global variable to the loaded module table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T030008Z" changeid="xf">
        <seg>Lua模块是由第一个Nginx请求处理器加载的，由内置的&lt;code&gt;require()&lt;/code&gt;缓存在package.loaded table中，供后续使用, &lt;code&gt;require()&lt;/code&gt; 有一个副作用，会在加载的模块table中设置一个全局变量.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Lua state (Lua VM instance) is shared across all the requests handled by a single nginx worker process to minimize memory use.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T034219Z" changeid="xf">
        <seg>Lua状态 (Lua虚拟机实例) 在同一个nginx worker进程中被所有请求共享以减少内存占用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Nginx Lua API described below can only be called within the user Lua code run in the context of these configuration directives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023405Z" changeid="xf">
        <seg>以下的 Nginx Lua API 只能由运行在这些配置命令上下文中的Lua代码进行调用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned &lt;code&gt;on&lt;/code&gt; or the [[#ngx.req.read_body|ngx.req.read_body]] function should be called within the Lua code.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101748Z" changeid="xf">
        <seg>Nginx内核默认不读取请求体，如果需要请求体数据, 就需要将本命令置为 &lt;code&gt;on&lt;/code&gt; ，或者在Lua代码中调用 [[#ngx.req.read_body|ngx.req.read_body]] 函数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The [[#ngx.location.capture|ngx.location.capture]] function is just a special form
of this function.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083519Z" changeid="xf">
        <seg> [[#ngx.location.capture|ngx.location.capture]] 函数只是本函数的特殊形式</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The [http://openresty.org ngx_openresty bundle] can be used to install Nginx, ngx_lua, either one of the standard Lua 5.1 interpreter or LuaJIT 2.0, as well as a package of powerful companion Nginx modules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032847Z" changeid="xf">
        <seg>[http://openresty.org ngx_openresty 包] 可以用来安装Nginx, ngx_lua, 标准 Lua 5.1 解释器或 LuaJIT 2.0, 以及一堆强大的Nginx模块.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The [https://groups.google.com/group/openresty openresty] mailing list is for Chinese speakers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032227Z" changeid="xf">
        <seg>[https://groups.google.com/group/openresty openresty].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The [https://groups.google.com/group/openresty-en openresty-en] mailing list is for English speakers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032218Z" changeid="xf">
        <seg>[https://groups.google.com/group/openresty-en openresty-en] </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ability to require these packages was introduced in the &lt;code&gt;v0.2.1rc19&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023954Z" changeid="xf">
        <seg>require 这两个包的能力始于 &lt;code&gt;v0.2.1rc19&lt;/code&gt; 版本.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The arguments &lt;code&gt;thread1&lt;/code&gt;, &lt;code&gt;thread2&lt;/code&gt;, and etc are the Lua thread objects returned by earlier calls of [[#ngx.thread.spawn|ngx.thread.spawn]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020813Z" changeid="xf">
        <seg>参数&lt;code&gt;thread1&lt;/code&gt;, &lt;code&gt;thread2&lt;/code&gt;, 等是由之前[[#ngx.thread.spawnngx.thread.spawn]]调用返回的Lua线程对象.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The basic installation step is a simple &lt;code&gt;./configure --with-luajit &amp;&amp; make &amp;&amp; make install&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032900Z" changeid="xf">
        <seg>基本安装过程是 &lt;code&gt;./configure --with-luajit &amp;&amp; make &amp;&amp; make install&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The callback function can decide what to do with the client abortion event all by itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021609Z" changeid="xf">
        <seg>此回调函数可以完全自主地决定如何处理客户端中断事件.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The changes of every release of this module can be obtained from the ngx_openresty bundle's change logs:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031951Z" changeid="xf">
        <seg>本模块的每次版本发布的变动信息可以从 ngx_openresty 发布包中的变动日志中获得:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; can make [[#Nginx API for Lua|API calls]] and can retrieve input arguments from the &lt;code&gt;ngx.arg&lt;/code&gt; table (index starts from &lt;code&gt;1&lt;/code&gt; and increases sequentially).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072846Z" changeid="xf">
        <seg>&lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt;中的代码可以调用 [[#Nginx API for Lua|API]]并能从 &lt;code&gt;ngx.arg&lt;/code&gt; table中获取输入参数 (下标从 &lt;code&gt;1&lt;/code&gt;开始递增).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The code repository of this project is hosted on github at [http://github.com/chaoslawful/lua-nginx-module chaoslawful/lua-nginx-module].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032723Z" changeid="xf">
        <seg>本项目的代码托管在github [http://github.com/chaoslawful/lua-nginx-module chaoslawful/lua-nginx-module].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The contents in the dictionary storage will be lost, however, when the Nginx server quits.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034227Z" changeid="xf">
        <seg>但是如果Nginx服务器退出了，此字典数据就没有了。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The coroutine (be it a normal Lua coroutine or a &quot;light thread&quot;) that directly spawns the &quot;light thread&quot; is called the &quot;parent coroutine&quot; for the &quot;light thread&quot; newly spawned.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T015816Z" changeid="xf">
        <seg>直接派生出&quot;轻量线程&quot;的这个 coroutine (可能是普通的Lua coroutine 或  &quot;轻量线程&quot;) 称为被创建&quot;轻量线程&quot;的 &quot;父coroutine&quot; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The correct adding order is:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032129Z" changeid="xf">
        <seg>正确的加载次序是:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The cpath string is in standard Lua cpath form, and &lt;code&gt;;;&lt;/code&gt;
can be used to stand for the original cpath.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062407Z" changeid="xf">
        <seg>cpath字符串使用标准的Lua cpath格式， &lt;code&gt;;;&lt;/code&gt;
可用来表示原始的cpath.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The current implementation requires that the iterator returned should only be used in a single request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T030041Z" changeid="xf">
        <seg>目前的实现要求返回的iterator只能用于一个请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The data chunk and &quot;eof&quot; flag passed to the downstream Nginx output filters can also be overridden by assigning values directly to the corresponding table elements.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032000Z" changeid="xf">
        <seg>发往下游Nginx输出过滤器的数据块和 &quot;eof&quot; 标记可以通过对表中相应元素的直接赋值来进行修改。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the &lt;code&gt;o&lt;/code&gt; option was not specified) and there will be one, and only one, warning in the &lt;code&gt;error.log&lt;/code&gt; file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T055812Z" changeid="xf">
        <seg>默认的条数是1024，当达到这个上限时，新的正则表达式将不被缓存 (就象没有设置 &lt;code&gt;o&lt;/code&gt; 一样) ，同时在 &lt;code&gt;error.log&lt;/code&gt; 文件中会记录一条且仅记录一条warning:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default setting is &lt;code&gt;60s&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102733Z" changeid="xf">
        <seg>默认值是 &lt;code&gt;60s&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The default time unit is &lt;code&gt;s&lt;/code&gt;, i.e., &quot;second&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102724Z" changeid="xf">
        <seg>默认的时间单位是 &lt;code&gt;s&lt;/code&gt;, 即, &quot;秒&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The dollar sign characters in the return value of the &lt;code&gt;replace&lt;/code&gt; function argument are not special at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032848Z" changeid="xf">
        <seg>用作 &lt;code&gt;replace&lt;/code&gt; 函数参数的[[#ngx.re.matchngx.re.match]]返回值中的美元符并不是特殊字符.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The effect in action:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015043Z" changeid="xf">
        <seg>看看结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first argument to this method must be the dictionary object itself, for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034445Z" changeid="xf">
        <seg>这个方法的第一个参数必须是字典对象本身, 例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first argument, &lt;code&gt;delay&lt;/code&gt;, specifies the delay for the timer,
in seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T022124Z" changeid="xf">
        <seg>第一个参数, &lt;code&gt;delay&lt;/code&gt;, 指定定时器的延迟,
单位是秒.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The first optional argument, &lt;code&gt;timeout&lt;/code&gt;, can be used to specify the maximal idle timeout (in milliseconds) for the current connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101655Z" changeid="xf">
        <seg>第一个可选参数, &lt;code&gt;timeout&lt;/code&gt;, 可以用来指定当前连接的最大空闲时间 (毫秒) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following dependencies are required to run the test suite:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032010Z" changeid="xf">
        <seg>要运行测试包需要以下依赖:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example demonstrates parallel requests to MySQL, Memcached, and upstream HTTP services in a single Lua handler, and outputting the results in the order that they actually return (very much like the Facebook BigPipe model):</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020548Z" changeid="xf">
        <seg>下面的例子演示了在一个Lua处理器中对 MySQL, Memcached, 和上游HTTP 服务的并行请求, 结果按实际返回的次序输出 (非常象Facebook BigPipe 模型):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example demonstrates the use of &lt;code&gt;ngx.thread.wait&lt;/code&gt; and [[#ngx.location.capture|ngx.location.capture]] to emulate [[#ngx.location.capture_multi|ngx.location.capture_multi]]:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021134Z" changeid="xf">
        <seg>下面的例子演示了用 &lt;code&gt;ngx.thread.wait&lt;/code&gt; 和 [[#ngx.location.capture|ngx.location.capture]] 来模拟 [[#ngx.location.capture_multi|ngx.location.capture_multi]]:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example demonstrates the use of coroutine.yield() in the &quot;light thread&quot; coroutines
to do manual time-slicing:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020120Z" changeid="xf">
        <seg>下面的例子演示了使用&quot;轻量线程&quot; coroutine.yield() 来实现手动分时:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following example emulates the &lt;code&gt;$request_time&lt;/code&gt; variable value (provided by [[HttpLogModule]]) in pure Lua:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094330Z" changeid="xf">
        <seg>下面的例子用纯Lua代码模拟 &lt;code&gt;$request_time&lt;/code&gt; 变量的值 (由 [[HttpLogModule]] 提供) in pure Lua:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following message will be generated if PCRE JIT is enabled:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025641Z" changeid="xf">
        <seg>如果打开了PCRE JIT，将出现以下信息:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following methods are supported on this object:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T064939Z" changeid="xf">
        <seg>该对象支持以下方法:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following option characters are supported:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023458Z" changeid="xf">
        <seg>支持以下选项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following options are supported:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T100458Z" changeid="xf">
        <seg>支持以下选项:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following patterns are supported:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T084804Z" changeid="xf">
        <seg>支持以下模式:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format for the Lua table passed as the &lt;code&gt;args&lt;/code&gt; argument is identical to the format used in the [[#ngx.encode_args|ngx.encode_args]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053541Z" changeid="xf">
        <seg> &lt;code&gt;args&lt;/code&gt; 参数Lua table的格式与 [[#ngx.encode_args|ngx.encode_args]] 所使用的table格式一样.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The header names are matched case-insensitively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091046Z" changeid="xf">
        <seg>头名称的匹配是大小写无关的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The input argument &lt;code&gt;data&lt;/code&gt; can either be a Lua string or a (nested) Lua table holding string fragments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T070353Z" changeid="xf">
        <seg>输入参数 &lt;code&gt;data&lt;/code&gt; 可以是 Lua 字符串或存有字符串片段的 (嵌套) Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The input data chunk is passed via [[#ngx.arg|ngx.arg]][1] (as a Lua string value) and the &quot;eof&quot; flag indicating the end of the response body data stream is passed via [[#ngx.arg|ngx.arg]][2] (as a Lua boolean value).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094231Z" changeid="xf">
        <seg>输入参数块由 [[#ngx.arg|ngx.arg]][1] (作为Lua string)传入， 标记标识响应体数据流结束的&quot;eof&quot;由 [[#ngx.arg|ngx.arg]][2] (作为Lua boolean)传入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iterator function behaves differently (i.e., like a real iterator) when it is called with a &lt;code&gt;size&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T094720Z" changeid="xf">
        <seg>如果带有&lt;code&gt;size&lt;/code&gt;参数， iterator函数的行为略有不同  (象一个真正的iterator) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iterator function can be called multiple times and can be mixed safely with other cosocket method calls or other iterator function calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T094640Z" changeid="xf">
        <seg>iterator函数可以多次调用，并且可以安全地与其它cosocket方法或其它iterator函数混合调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The iterator function will be reset after the last successful invocation that returns &lt;code&gt;nil&lt;/code&gt; data and &lt;code&gt;nil&lt;/code&gt; error.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T095058Z" changeid="xf">
        <seg>在最后一次成功返回&lt;code&gt;nil&lt;/code&gt;数据和&lt;code&gt;nil&lt;/code&gt;错误后，iterator函数将被重置。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The key must already exist in the dictionary, otherwise it will return &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;&quot;not found&quot;&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060225Z" changeid="xf">
        <seg>键必须在字典中已经存在，否则返回 &lt;code&gt;nil&lt;/code&gt; 和 &lt;code&gt;&quot;not found&quot;&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The limit can be manually modified if required by editing the definition of the &lt;code&gt;NGX_HTTP_MAX_SUBREQUESTS&lt;/code&gt; macro in the &lt;code&gt;nginx/src/http/ngx_http_request.h&lt;/code&gt; file in the Nginx source tree.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082635Z" changeid="xf">
        <seg>可以手工修改Nginx代码树中的&lt;code&gt;nginx/src/http/ngx_http_request.h&lt;/code&gt;文件中的 &lt;code&gt;NGX_HTTP_MAX_SUBREQUESTS&lt;/code&gt; 宏定义来修改这个上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The line is terminated by a &lt;code&gt;Line Feed&lt;/code&gt; (LF) character (ASCII 10), optionally preceded by a &lt;code&gt;Carriage Return&lt;/code&gt; (CR) character (ASCII 13).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T085533Z" changeid="xf">
        <seg>每一行以 &lt;code&gt;换行&lt;/code&gt; (LF) 符(ASCII 10)（之前可能有一个 &lt;code&gt;回车&lt;/code&gt; (CR) 符(ASCII 13)）结束.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximal number of pending timers allowed in an Nginx
worker is constrolled by the [[#lua_max_pending_timers|lua_max_pending_timers]]
directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042608Z" changeid="xf">
        <seg>Nginx worker中等待中的定时器最大数目由 [[#lua_max_pending_timers|lua_max_pending_timers]]命令控制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The maximal number of running timers is controlled by the
[[#lua_max_running_timers|lua_max_running_timers]] directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042635Z" changeid="xf">
        <seg>运行中的定时器最大数目由 [[#lua_max_running_timers|lua_max_running_timers]]命令控制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The module provides the full flexibility of scripting while offering performance levels comparable with native C language programs both in terms of CPU time as well as memory footprint.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T034102Z" changeid="xf">
        <seg>本模块提供了脚本语言的全部灵活性，以及无论在CPU时间上还是在内存消耗上都与C语言程序相匹敌的高性能.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The ngx_lua module does not currently support the &lt;code&gt;stat&lt;/code&gt; mode available with the
Apache &lt;code&gt;mod_lua&lt;/code&gt; module but this is planned for implementation in the future.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T043051Z" changeid="xf">
        <seg>ngx_lua 模块目前不支持Apache &lt;code&gt;mod_lua&lt;/code&gt; module 中有的 &lt;code&gt;stat&lt;/code&gt; 模式，但我们计划在将来实现它。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The number &lt;code&gt;8&lt;/code&gt; will be consistently output when accessing &lt;code&gt;/get&lt;/code&gt; regardless of how many Nginx workers there are because the &lt;code&gt;dogs&lt;/code&gt; dictionary resides in the shared memory and visible to ''all'' of the worker processes.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034023Z" changeid="xf">
        <seg>不管有多少个Nginx worker进程，访问&lt;code&gt;/get&lt;/code&gt;时每次都输出 &lt;code&gt;8&lt;/code&gt;  是因为 &lt;code&gt;dogs&lt;/code&gt; 字典位于共享内存中，对 ''所有'' worker进程可见。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;code&gt;exptime&lt;/code&gt; argument specifies expiration time (in seconds) for the inserted key-value pair.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T040906Z" changeid="xf">
        <seg>可选参数 &lt;code&gt;exptime&lt;/code&gt; 指定插入的key-value对的过期时间 (单位是秒).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;code&gt;flags&lt;/code&gt; argument specifies a user flags value associated with the entry to be stored.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T041035Z" changeid="xf">
        <seg>可选的 &lt;code&gt;flags&lt;/code&gt; 参数是与被插入的项相关的用户标志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;code&gt;max_args&lt;/code&gt; argument can be used to specify the maximum number of arguments parsed from the &lt;code&gt;str&lt;/code&gt; argument.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020528Z" changeid="xf">
        <seg>可选的&lt;code&gt;max_args&lt;/code&gt; 参数指定从 &lt;code&gt;str&lt;/code&gt; 解析出的参数数量的上限.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;code&gt;options&lt;/code&gt; argument has exactly the same meaning as in [[#ngx.re.match|ngx.re.match]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032111Z" changeid="xf">
        <seg>可选参数 &lt;code&gt;options&lt;/code&gt; 与 [[#ngx.re.match|ngx.re.match]] 中的语义一致.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;code&gt;options&lt;/code&gt; argument takes exactly the same semantics as the [[#ngx.re.match|ngx.re.match]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T030017Z" changeid="xf">
        <seg>可选的&lt;code&gt;options&lt;/code&gt;参数与 [[#ngx.re.match|ngx.re.match]] 方法中的参数语义完全一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional &lt;code&gt;status&lt;/code&gt; parameter specifies whether
&lt;code&gt;301&lt;/code&gt; or &lt;code&gt;302&lt;/code&gt; to be used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034339Z" changeid="xf">
        <seg>可选的 &lt;code&gt;status&lt;/code&gt; 参数指定使用
&lt;code&gt;301&lt;/code&gt; 还是 &lt;code&gt;302&lt;/code&gt; 。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional boolean &lt;code&gt;jump&lt;/code&gt; argument can trigger location rematch (or location jump) as [[HttpRewriteModule]]'s [[HttpRewriteModule#rewrite|rewrite]] directive, that is, when &lt;code&gt;jump&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; (default to &lt;code&gt;false&lt;/code&gt;), this function will never return and it will tell Nginx to try re-searching locations with the new URI value at the later &lt;code&gt;post-rewrite&lt;/code&gt; phase and jumping to the new location.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101743Z" changeid="xf">
        <seg>可选的boolean参数 &lt;code&gt;jump&lt;/code&gt; 可以象 [[HttpRewriteModule]] 的 [[HttpRewriteModule#rewriterewrite]] 命令一样触发location重匹配 (或称location跳转) , 如果 &lt;code&gt;jump&lt;/code&gt; 是 &lt;code&gt;true&lt;/code&gt; (默认为&lt;code&gt;false&lt;/code&gt;), 这个函数将不会返回，而是告诉 Nginx 在后面的&lt;code&gt;post-rewrite&lt;/code&gt;阶段尝试重新对新的URI值进行location匹配并中转到新的location.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional fourth argument, &lt;code&gt;ctx&lt;/code&gt;, can be a Lua table holding an optional &lt;code&gt;pos&lt;/code&gt; field.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024756Z" changeid="xf">
        <seg>第4个可选参数, &lt;code&gt;ctx&lt;/code&gt;, 是装有 &lt;code&gt;pos&lt;/code&gt; 值的Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The optional second &lt;code&gt;args&lt;/code&gt; can be used to specify extra URI query arguments, for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032417Z" changeid="xf">
        <seg>可选的第二个参数 &lt;code&gt;args&lt;/code&gt; 可用于指定额外的 URI 请求参数, 例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The order in which these modules are added during configuration is important as the position of any filter module in the
filtering chain determines the final output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T032123Z" changeid="xf">
        <seg>这些模块在配置中的添加次序是重要的，因为过滤器链中任何过滤器模块的位置都将对最终输出产生影响.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The output data stream can be aborted immediately by running the following Lua statement:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094434Z" changeid="xf">
        <seg>可以用过执行下面的Lua语句来立即终止响应数据流:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The packages can be introduced into external Lua modules like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023650Z" changeid="xf">
        <seg>它们可以象这样被引入到外部 Lua 模块中:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The parameter &lt;code&gt;sec&lt;/code&gt; is the time stamp in seconds (like those returned from [[#ngx.time|ngx.time]]).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022642Z" changeid="xf">
        <seg>&lt;code&gt;sec&lt;/code&gt;参数是以秒为单位的时间戳 (同 [[#ngx.time|ngx.time]] 的返回值).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The path string is in standard Lua path form, and &lt;code&gt;;;&lt;/code&gt;
can be used to stand for the original search paths.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061902Z" changeid="xf">
        <seg>路径字符串使用标准的Lua路径格式，, &lt;code&gt;;;&lt;/code&gt;可用于表示原始的查找路径。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The possibilities are unlimited as the module allows bringing together various elements within Nginx as well as exposing the power of the Lua language to the user.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T033940Z" changeid="xf">
        <seg>本模块允许将Nginx内部的不同元素放到一起并且将Lua语言的强大赋予了用户，拥有无限的可能性.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The raw binary form of the &lt;code&gt;HMAC-SHA1&lt;/code&gt; digest will be generated, use [[#ngx.encode_base64|ngx.encode_base64]], for example, to encode the result to a textual representation if desired.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021333Z" changeid="xf">
        <seg>此函数返回的是 &lt;code&gt;HMAC-SHA1&lt;/code&gt; 文摘的二进制数据，如果需要，可以使用[[#ngx.encode_base64|ngx.encode_base64]]将其转成文本形式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The regular expressions used in [[#ngx.re.match|ngx.re.match]], [[#ngx.re.gmatch|ngx.re.gmatch]], [[#ngx.re.sub|ngx.re.sub]], and [[#ngx.re.gsub|ngx.re.gsub]] will be cached within this cache if the regex option &lt;code&gt;o&lt;/code&gt; (i.e., compile-once flag) is specified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T055649Z" changeid="xf">
        <seg>[[#ngx.re.match|ngx.re.match]], [[#ngx.re.gmatch|ngx.re.gmatch]], [[#ngx.re.sub|ngx.re.sub]], and [[#ngx.re.gsub|ngx.re.gsub]]中使用的正则表达式，如果设置了 &lt;code&gt;o&lt;/code&gt; (即“仅编译一次”）模式，将在这个缓存中进行缓存。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The request body data read using this function can be retrieved later via [[#ngx.req.get_body_data|ngx.req.get_body_data]] or, alternatively, the temporary file name for the body data cached to disk using [[#ngx.req.get_body_file|ngx.req.get_body_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022257Z" changeid="xf">
        <seg>使用此函数读取的请求体数据也可以延后，通过 [[#ngx.req.get_body_data|ngx.req.get_body_data]] 读取，或使用缓存的磁盘的临时文件名[[#ngx.req.get_body_filengx.req.get_body_file]]进行读取.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is exactly the same as [[#ngx.crc32_long|ngx.crc32_long]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020857Z" changeid="xf">
        <seg>结果与 [[#ngx.crc32_long|ngx.crc32_long]] 一样.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is exactly the same as [[#ngx.crc32_short|ngx.crc32_short]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021034Z" changeid="xf">
        <seg>结果与 [[#ngx.crc32_short|ngx.crc32_short]] 一样.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is exactly the same as the previous example.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032510Z" changeid="xf">
        <seg>结果与上一个例子完全一样.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The resulting object &lt;code&gt;dict&lt;/code&gt; has the following methods:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T033754Z" changeid="xf">
        <seg>返回的 &lt;code&gt;dict&lt;/code&gt; 对象有以下方法:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The return values have exactly the same meaning as [[#coroutine.resume|coroutine.resume]], that is, the first value returned is a boolean value indicating whether the &quot;light thread&quot; terminates successfully or not, and subsequent values returned are the return values of the user Lua function that was used to spawn the &quot;light thread&quot; (in case of success) or the error object (in case of failure).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021038Z" changeid="xf">
        <seg>返回值的意思与 [[#coroutine.resume|coroutine.resume]] 的返回值完全一样, 即, 第一个返回值是表明&quot;轻量线程&quot;是否成功结束的布尔值，后面的值是用来派生出&quot;轻量线程&quot;的Lua函数的返回值(成功的情况)或错误对象（出错的情况）.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The returned file is read only and is usually cleaned up by Nginx's memory pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023710Z" changeid="xf">
        <seg>返回的文件是只读的，通常由Nginx的内存池来清理.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The right way of doing this is as follows:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074753Z" changeid="xf">
        <seg>正确的作法是这样的:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The same applies to assigning an empty table:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T090339Z" changeid="xf">
        <seg>设置成一个空table的效果是一样的:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second argument, &lt;code&gt;callback&lt;/code&gt;, can
be any Lua function, which will be invoked later in a background
&quot;light thread&quot; after the delay specified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T022333Z" changeid="xf">
        <seg>第二个参数, &lt;code&gt;callback&lt;/code&gt;, 可以是任何Lua函数，在指定的延迟时间后被后台的&quot;轻量线程&quot;调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The second optional argument, &lt;code&gt;size&lt;/code&gt;, can be used to specify the maximal number of connections allowed in the connection pool for the current server (i.e., the current host-port pair or the unix domain socket file path).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101853Z" changeid="xf">
        <seg>第二个可选参数, &lt;code&gt;size&lt;/code&gt;, 可以用来指定当前服务器(当前的主机-端口对，或 unix domain socket文件路径)连接池中的最大连接数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The shared dictionary will retain its contents through a server config reload (either by sending the &lt;code&gt;HUP&lt;/code&gt; signal to the Nginx process or by using the &lt;code&gt;-s reload&lt;/code&gt; command-line option).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034202Z" changeid="xf">
        <seg>这部分共享字典的内容即使在服务器重新加载配置时(通过向Nginx进程发送 &lt;code&gt;HUP&lt;/code&gt; 信号或者使用 &lt;code&gt;-s reload&lt;/code&gt; 命令行参数)仍能保持.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The socket object returned by this method is usually used to read the current request's body in a streaming fashion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031946Z" changeid="xf">
        <seg>此方法返回的socket对象通常用来以流的方式读取当前请求的体。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The status of the &quot;light thread&quot; coroutine can be &quot;zombie&quot; if
# the current &quot;light thread&quot; already terminates (either successfully or with an error),
# its parent coroutine is still alive, and
# its parent coroutine is not waiting on it with [[#ngx.thread.wait|ngx.thread.wait]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020048Z" changeid="xf">
        <seg> &quot;轻量线程&quot; coroutine 在下面的情况下可能成为 &quot;僵尸&quot; 
# 当前 &quot;轻量线程&quot; 已经结束 (成功或者出错),
# 父corotine仍然活着，而且
# 父coroutine没有用 [[#ngx.thread.wait|ngx.thread.wait]] 等待它.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The support for the options table argument was first introduced in the &lt;code&gt;v0.5.7&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T075013Z" changeid="xf">
        <seg>这个可选的table参数在 &lt;code&gt;v0.5.7&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The table keys must be Lua strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020133Z" changeid="xf">
        <seg>table的key必须是 Lua 字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The time resolution is &lt;code&gt;0.001&lt;/code&gt; seconds.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T040916Z" changeid="xf">
        <seg>时间精度为 &lt;code&gt;0.001&lt;/code&gt; 秒.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The total latency is the longest latency of the individual subrequests rather than the sum.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083402Z" changeid="xf">
        <seg>总的延迟是各个子请求延时的最大值，而不是它们的和.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The upper limit of the regex cache can be tuned via the [[#lua_regex_cache_max_entries|lua_regex_cache_max_entries]] directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024723Z" changeid="xf">
        <seg>可以使用[[#lua_regex_cache_max_entrieslua_regex_cache_max_entries]]来调整正则缓存的上限.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The usage of this function is often like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030641Z" changeid="xf">
        <seg>这个函数的用法通常是这样的:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user callback will be
called automatically by the Nginx core with the arguments &lt;code&gt;premature&lt;/code&gt;,
&lt;code&gt;user_arg1&lt;/code&gt;, &lt;code&gt;user_arg2&lt;/code&gt;, and etc, where the &lt;code&gt;premature&lt;/code&gt;
argument takes a boolean value indicating whether it is a premature timer
expiration or not, and &lt;code&gt;user_arg1&lt;/code&gt;, &lt;code&gt;user_arg2&lt;/code&gt;, and etc, are
those (extra) user arguments specified when calling &lt;code&gt;ngx.timer.at&lt;/code&gt;
as the remaining arguments.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T022558Z" changeid="xf">
        <seg>用户回调函数将被Nginx核心自动调用，调用参数为&lt;code&gt;premature&lt;/code&gt;,
&lt;code&gt;user_arg1&lt;/code&gt;, &lt;code&gt;user_arg2&lt;/code&gt;, 等, 其中 &lt;code&gt;premature&lt;/code&gt;
参数是布尔值，表示是否是过早的定时器过期,  &lt;code&gt;user_arg1&lt;/code&gt;, &lt;code&gt;user_arg2&lt;/code&gt;, 等是调用&lt;code&gt;ngx.timer.at&lt;/code&gt;时指定的那些参数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user flags argument was first introduced in the &lt;code&gt;v0.5.0rc2&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T041138Z" changeid="xf">
        <seg>用户标记参数在 &lt;code&gt;v0.5.0rc2&lt;/code&gt; 版本中引入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The user flags is stored as an unsigned 32-bit integer internally.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T041111Z" changeid="xf">
        <seg>用户标记在实现上是以无符号 32位整数存储的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value returned will have the original data type when they were inserted into the dictionary, for example, Lua booleans, numbers, or strings.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034427Z" changeid="xf">
        <seg>返回的值拥有其被写入字典时同样的数据类型，例如, Lua 布尔值, 数字, 或字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Their value type will also be stored into the dictionary and the same data type can be retrieved later via the [[#ngx.shared.DICT.get|get]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T040836Z" changeid="xf">
        <seg>类型信息也会被存入字典，这样后续调用[[#ngx.shared.DICT.getget]]时可以取出同样类型的数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;GET /main&lt;/code&gt; will give the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T052547Z" changeid="xf">
        <seg>&lt;code&gt;GET /main&lt;/code&gt; 将输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;GET /orig&lt;/code&gt; will give</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035529Z" changeid="xf">
        <seg>&lt;code&gt;GET /orig&lt;/code&gt; 的结果</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;GET /t&lt;/code&gt; will just return the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T095045Z" changeid="xf">
        <seg>请求 &lt;code&gt;GET /t&lt;/code&gt; 将产生以下输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;GET /test&lt;/code&gt; will yield the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034603Z" changeid="xf">
        <seg>&lt;code&gt;GET /test&lt;/code&gt; 的输出如下</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;GET /test?foo=bar&amp;bar=baz&amp;bar=blah&lt;/code&gt; will yield the response body</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102627Z" changeid="xf">
        <seg>&lt;code&gt;GET /test?foo=bar&amp;bar=baz&amp;bar=blah&lt;/code&gt; 的结果是响应体</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then &lt;code&gt;res.header[&quot;Set-Cookie&quot;]&lt;/code&gt; will be evaluated to the table value
&lt;code&gt;{&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;}&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041130Z" changeid="xf">
        <seg>那么 &lt;code&gt;res.header[&quot;Set-Cookie&quot;]&lt;/code&gt; 的值是table
&lt;code&gt;{&quot;a=3&quot;, &quot;foo=bar&quot;, &quot;baz=blah&quot;}&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then for the incoming data stream &lt;code&gt;'hello, world!</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T095340Z" changeid="xf">
        <seg>对于输入数据流 &lt;code&gt;'hello, world!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then for the input data stream &lt;code&gt;&quot;hello world _END_ blah blah blah&quot;&lt;/code&gt;, then the example above will output &lt;code&gt;hello world _END_&lt;/code&gt;, including the pattern string &lt;code&gt;_END_&lt;/code&gt; itself.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T100620Z" changeid="xf">
        <seg>对于输入数据流 &lt;code&gt;&quot;hello world _END_ blah blah blah&quot;&lt;/code&gt;, 上面的例子将输出 &lt;code&gt;hello world _END_&lt;/code&gt;, 包括模式串&lt;code&gt;_END_&lt;/code&gt; 本身.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then it will generate the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053818Z" changeid="xf">
        <seg>将会生成这样的输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then request &lt;code&gt;GET /lua&lt;/code&gt; gives</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T052942Z" changeid="xf">
        <seg>请求 &lt;code&gt;GET /lua&lt;/code&gt; 得到</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Then, enable the &quot;debug&quot; error log level in &lt;code&gt;error_log&lt;/code&gt; directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025626Z" changeid="xf">
        <seg>然后在&lt;code&gt;error_log&lt;/code&gt;命令中打开 &quot;debug&quot; 错误日志级别.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a hard coded &lt;code&gt;2048&lt;/code&gt; byte limitation on error message lengths in the Nginx core.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034124Z" changeid="xf">
        <seg>Nginx 内核中硬编码限制了错误信息长度为 &lt;code&gt;2048&lt;/code&gt; 字节.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a hard-coded upper limit on the number of concurrent subrequests possible for every main request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082432Z" changeid="xf">
        <seg>对每个主请求，对同时并发的子请求的数量有一个硬编码的上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is no way to use the [[#tcpsock:settimeout|settimeout]] method to specify connecting timeout for this method and the [[#lua_socket_connect_timeout|lua_socket_connect_timeout]] directive must be set at configure time instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102619Z" changeid="xf">
        <seg>不能使用 [[#tcpsock:settimeout|settimeout]] 来设置本方法的连接超时，必须用 [[#lua_socket_connect_timeout|lua_socket_connect_timeout]] 命令在配置阶段设置.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These
variables are set after the sharing or copying of variables has been
evaluated, and provides a more efficient method of passing specific
values to a subrequest over encoding them as URL arguments and 
unescaping them in the Nginx config file.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T080709Z" changeid="xf">
        <seg>这些变量的设置发生在共享或拷贝的变量被求值以后， 这样提供了一种比将参数编码成URL参数并在Nginx配置文件中对它们进行反转义更高效的传递参数的方法。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are usually used by the [[#ngx.log|ngx.log]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033708Z" changeid="xf">
        <seg>这些常量通常被用在 [[#ngx.log|ngx.log]] 方法中.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These constants are usually used in [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] method calls.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033519Z" changeid="xf">
        <seg>这些常量多用于 [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] 调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These options can be combined:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024538Z" changeid="xf">
        <seg>以上选项可以组合使用:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These packages are in the default global scope within ngx_lua and are always available within ngx_lua directives.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023617Z" changeid="xf">
        <seg>这两个包在ngx_lua模块的默认全局作用域中， 在ngx_lua命令里总是可以访问到.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These two forms are fundamentally equivalent.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034524Z" changeid="xf">
        <seg>这两种形式本质上是一样的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API requires the OpenSSL library enabled in the Nginx build (usually by passing the &lt;code&gt;--with-http_ssl_module&lt;/code&gt; option to the &lt;code&gt;./configure&lt;/code&gt; script).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021436Z" changeid="xf">
        <seg>本API需要在编译Nginx时打开OpenSSL库 (&lt;code&gt;./configure&lt;/code&gt;命令加上 &lt;code&gt;--with-http_ssl_module&lt;/code&gt; 选项).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API was first enabled in the &lt;code&gt;v0.6.0&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035407Z" changeid="xf">
        <seg>此API在 &lt;code&gt;v0.6.0&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API was first enabled in the &lt;code&gt;v0.7.0&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020632Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.7.0&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API was first introduced in &lt;code&gt;v0.3.1rc32&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022235Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc32&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API was first introduced in ngx_lua v0.3.1rc6.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040807Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc6&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API was first introduced in the &lt;code&gt;v0.3.1rc8&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020943Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc8&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API was first introduced in the &lt;code&gt;v0.5.10&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102904Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.10&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API was first introduced in the &lt;code&gt;v0.6.0&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035111Z" changeid="xf">
        <seg>此API在 &lt;code&gt;v0.6.0&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API was first introduced in the &lt;code&gt;v0.7.4&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021934Z" changeid="xf">
        <seg>此API在 &lt;code&gt;v0.7.4&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This API was first introduced in the &lt;code&gt;v0.8.0&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042207Z" changeid="xf">
        <seg>此API在 &lt;code&gt;v0.8.0&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows named</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023723Z" changeid="xf">
        <seg>此选项允许具名</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This also applies to [[#access_by_lua|access_by_lua]] and [[#access_by_lua_file|access_by_lua_file]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102318Z" changeid="xf">
        <seg>这也适用于 [[#access_by_lua|access_by_lua]] 和 [[#access_by_lua_file|access_by_lua_file]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This argument can be set to zero to remove the limit and to process all request arguments received:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103315Z" changeid="xf">
        <seg>这个参数设成0表示无上限，会处理接收到的所有的请求参数：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This argument can be set to zero to remove the limit and to process all request headers received:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015711Z" changeid="xf">
        <seg>这个参数设成0表示无上限，会处理接收到的所有的请求头：</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103245Z" changeid="xf">
        <seg>这个缓冲区不需要大于能够一次装下所有的东西，因为 cosocket 支持 100% 无缓冲读取和解析.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This buffering mechanism is mainly used for HTTP 1.0 keep-alive which replies on a proper &lt;code&gt;Content-Length&lt;/code&gt; response header.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020002Z" changeid="xf">
        <seg>这个缓冲机制主要用于HTTP 1.0 keep-alive，基于正确的 &lt;code&gt;Content-Length&lt;/code&gt; 响应头.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This call involves a syscall and thus has some overhead, so do not abuse it.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022312Z" changeid="xf">
        <seg>这个函数包括一个系统调用，有一定的开销，请勿滥用。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be particularly useful for streaming output.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041327Z" changeid="xf">
        <seg>这在做流式输出时特别有用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This can be striped out by specifying the &lt;code&gt;-s&lt;/code&gt; option as shown:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035859Z" changeid="xf">
        <seg>可以用 &lt;code&gt;-s&lt;/code&gt; 选项去掉调试信息:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This constant was first introduced in the &lt;code&gt;v0.5.0rc5&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033120Z" changeid="xf">
        <seg>此常量在 &lt;code&gt;v0.5.0rc5&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This data sharing technique is essential for high performance Lua applications based on this module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041236Z" changeid="xf">
        <seg>这种数据共享技术对于使用本模块的高性能Lua应用是至关重要的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This depends on</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022301Z" changeid="xf">
        <seg>这取决于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive can be freely mixed with all directives of the [[HttpRewriteModule]], [[HttpSetMiscModule]], and [[HttpArrayVarModule]] modules.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073130Z" changeid="xf">
        <seg>这条命令可以随意与 [[HttpRewriteModule]], [[HttpSetMiscModule]], 和[[HttpArrayVarModule]] 模块中的命令混合使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015637Z" changeid="xf">
        <seg>本命令可以用来打开/关闭TCP或UDP cosocket出错时的错误日志。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104426Z" changeid="xf">
        <seg>本命令控制cosocket内置连接池中连接的默认最大空闲时间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:connect|connect]] method and can be overridden by the [[#tcpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102621Z" changeid="xf">
        <seg>本命令控制 TCP/unix-domain socket 对象[[#tcpsock:connect|connect]] 方法中使用的默认超时时间， 可以用 [[#tcpsock:settimeout|settimeout]] 方法进行修改.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive controls the default timeout value used in TCP/unix-domain socket object's [[#tcpsock:receive|receive]] method and iterator functions returned by the [[#tcpsock:receiveuntil|receiveuntil]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103048Z" changeid="xf">
        <seg>本命令控制 TCP/unix-domain socket 对象[[#tcpsock:receive|receive]] 方法中使用的默认超时时间， 可以用 [[#tcpsock:settimeout|settimeout]] 方法进行修改.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive controls whether to check for premature client connection abortion.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021207Z" changeid="xf">
        <seg>本命令控制是否检测客户端连接过早中断。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072341Z" changeid="xf">
        <seg>这条命令是被设计用来执行短的，能很快结束的代码块，在它执行时Nginx事件循环是被阻塞的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive is turned &lt;code&gt;on&lt;/code&gt; by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020446Z" changeid="xf">
        <seg>本命令默认值为 &lt;code&gt;on&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073335Z" changeid="xf">
        <seg>这条命令需要 [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] 模块.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.2.1rc20&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094634Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.2.1rc20&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.3.1rc22&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102526Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc22&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.0rc19&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020454Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc19&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.0rc1&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T102745Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc1&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.0rc29&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020716Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.0rc31&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101428Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc31&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.0rc32&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091605Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc32&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.13&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015801Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.13&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.5.5&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064451Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.5&lt;/code&gt; 版本中引入。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.7.4&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022456Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.7.4&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.8.0&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022653Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.8.0&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This directive was first introduced in the &lt;code&gt;v0.8.5&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T061011Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.8.5&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes ngx_lua [https://github.com/chaoslawful/lua-nginx-module/tags v0.8.5] released on 18 July 2013.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T035049Z" changeid="xf">
        <seg>本文对应的是 ngx_lua [https://github.com/chaoslawful/lua-nginx-module/tags v0.8.5]版本，发布于2013年7月8日.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document describes ngx_lua [https://github.com/chaoslawful/lua-nginx-module/tags v0.8.6] released on 6 August 2013.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T062523Z" changeid="xf">
        <seg>本文对应的是 ngx_lua [https://github.com/chaoslawful/lua-nginx-module/tags v0.8.6]版本，发布于2013年8月6日.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This does not replace the current access logs, but runs after.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091507Z" changeid="xf">
        <seg>它不会覆盖当前的访问日志，而是在记录访问日志之后运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042137Z" changeid="xf">
        <seg>这条功能需要 [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] 模块.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was first introduced in the &lt;code&gt;v0.2.1rc12&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T030151Z" changeid="xf">
        <seg>本功能在 &lt;code&gt;v0.2.1rc12&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was first introduced in the &lt;code&gt;v0.2.1rc13&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032857Z" changeid="xf">
        <seg>本功能在 &lt;code&gt;v0.2.1rc13&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was first introduced in the &lt;code&gt;v0.2.1rc15&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T033004Z" changeid="xf">
        <seg>本功能在 &lt;code&gt;v0.2.1rc15&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was first introduced in the &lt;code&gt;v0.3.1rc22&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034237Z" changeid="xf">
        <seg>本功能在 &lt;code&gt;v0.3.1rc22&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was first introduced in the &lt;code&gt;v0.5.0rc17&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060501Z" changeid="xf">
        <seg>本功能在 &lt;code&gt;v0.5.0rc17&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was first introduced in the &lt;code&gt;v0.5.0rc1&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074306Z" changeid="xf">
        <seg>本功能在 &lt;code&gt;v0.5.1rc1&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was first introduced in the &lt;code&gt;v0.5.7&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065030Z" changeid="xf">
        <seg>本功能在 &lt;code&gt;v0.5.7&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was first introduced in the &lt;code&gt;v0.6.3&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060703Z" changeid="xf">
        <seg>本功能在 &lt;code&gt;v0.6.3&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was first introduced in the &lt;code&gt;v0.7.18&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T054613Z" changeid="xf">
        <seg>本功能在 &lt;code&gt;v0.7.18&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was first introduced in the &lt;code&gt;v0.7.3&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T061002Z" changeid="xf">
        <seg>本功能在 &lt;code&gt;v0.7.3&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This feature was introduced in the &lt;code&gt;v0.2.1rc11&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025657Z" changeid="xf">
        <seg>此功能在 &lt;code&gt;v0.2.1rc11&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function can be used with [[#ngx.req.append_body|ngx.req.append_body]], [[#ngx.req.finish_body|ngx.req.finish_body]], and [[#ngx.req.socket|ngx.req.socket]] to implement efficient input filters in pure Lua (in the context of [[#rewrite_by_lua|rewrite_by_lua]]* or [[#access_by_lua|access_by_lua]]*), which can be used with other Nginx content handler or upstream modules like [[HttpProxyModule]] and [[HttpFastcgiModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030858Z" changeid="xf">
        <seg>此函数与 [[#ngx.req.append_body|ngx.req.append_body]], [[#ngx.req.finish_body|ngx.req.finish_body]], 和 [[#ngx.req.socket|ngx.req.socket]]一起使用，可以实现高效的纯Lua输入过滤器 (在[[#rewrite_by_lua|rewrite_by_lua]]* 或 [[#access_by_lua|access_by_lua]]* 中), 过滤器可与其它 Nginx 内容处理器或上游模块 [[HttpProxyModule]] 和 [[HttpFastcgiModule]]一起使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function can be used with [[#ngx.req.init_body|ngx.req.init_body]], [[#ngx.req.append_body|ngx.req.append_body]], and [[#ngx.req.socket|ngx.req.socket]] to implement efficient input filters in pure Lua (in the context of [[#rewrite_by_lua|rewrite_by_lua]]* or [[#access_by_lua|access_by_lua]]*), which can be used with other Nginx content handler or upstream modules like [[HttpProxyModule]] and [[HttpFastcgiModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031219Z" changeid="xf">
        <seg>此函数与 [[#ngx.req.init_body|ngx.req.iit_body]], [[#ngx.req.append_body|ngx.req.append_body]], 和 [[#ngx.req.socket|ngx.req.socket]]一起使用，可以实现高效的纯Lua输入过滤器 (在[[#rewrite_by_lua|rewrite_by_lua]]* 或 [[#access_by_lua|access_by_lua]]* 中), 过滤器可与其它 Nginx 内容处理器或上游模块 [[HttpProxyModule]] 和 [[HttpFastcgiModule]]一起使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function can be used with [[#ngx.req.init_body|ngx.req.init_body]], [[#ngx.req.finish_body|ngx.req.finish_body]], and [[#ngx.req.socket|ngx.req.socket]] to implement efficient input filters in pure Lua (in the context of [[#rewrite_by_lua|rewrite_by_lua]]* or [[#access_by_lua|access_by_lua]]*), which can be used with other Nginx content handler or upstream modules like [[HttpProxyModule]] and [[HttpFastcgiModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T031031Z" changeid="xf">
        <seg>此函数与 [[#ngx.req.init_body|ngx.req.iit_body]], [[#ngx.req.finish_body|ngx.req.finish_body]], 和 [[#ngx.req.socket|ngx.req.socket]]一起使用，可以实现高效的纯Lua输入过滤器 (在[[#rewrite_by_lua|rewrite_by_lua]]* 或 [[#access_by_lua|access_by_lua]]* 中), 过滤器可与其它 Nginx 内容处理器或上游模块 [[HttpProxyModule]] 和 [[HttpFastcgiModule]]一起使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function is a shortcut for combining [[#ngx.socket.tcp|ngx.socket.tcp()]] and the [[#tcpsock:connect|connect()]] method call in a single operation.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102513Z" changeid="xf">
        <seg>此函数是将 [[#ngx.socket.tcp|ngx.socket.tcp()]] 和 [[#tcpsock:connect|connect()]] 组合到一个操作中的简写.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function is added for [http://w3.impa.br/~diego/software/luasocket/tcp.html LuaSocket] API compatibility and does nothing for now.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101300Z" changeid="xf">
        <seg>加入此函数是为了兼容[http://w3.impa.br/~diego/software/luasocket/tcp.html LuaSocket] API，它什么也不做.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function is an asynchronous call and returns immediately.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022931Z" changeid="xf">
        <seg>本函数是异步调用，会立即返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function issues several parallel subrequests specified by the input table and returns their results in the same order.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082915Z" changeid="xf">
        <seg>这个函数发起在输入table中指定的若干并行子请求，并以指定的顺序返回其结果。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function requires SHA-1 support in the Nginx build.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021728Z" changeid="xf">
        <seg>此函数需要编译Nginx时添加 SHA-1 支持.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function returns &lt;code&gt;nil&lt;/code&gt; if
# the request body has not been read,
# the request body has been read into disk temporary files,
# or the request body has zero size.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023149Z" changeid="xf">
        <seg>在以下情况下此函数返回 &lt;code&gt;nil&lt;/code&gt; 
# 请求体尚未被读取,
# 请求体已经被读进磁盘临时文件,
# 请求体长度为0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.3.1rc17&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T022550Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc17&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.3.1rc18&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024035Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc18&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.3.1rc29&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021444Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc29&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.5.0rc1&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032239Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc1&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.5.0rc6&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021758Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc6&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.5.11&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030910Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.11&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function was first introduced in the &lt;code&gt;v0.7.7&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T094353Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.7.7&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function will not return until all the subrequests terminate.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082941Z" changeid="xf">
        <seg>这个函数只有在所有子请求都结束后才会返回。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This function will return but with no returned values when the &lt;code&gt;jump&lt;/code&gt; argument is &lt;code&gt;false&lt;/code&gt; or absent altogether.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101914Z" changeid="xf">
        <seg>&lt;code&gt;jump&lt;/code&gt;参数为&lt;code&gt;false&lt;/code&gt;或不提供时，这个函数会返回，但没有返回值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This however carries some risks and is not ordinarily recommended.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074328Z" changeid="xf">
        <seg>但这种做法会带来风险，通常并不推荐。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This however is not normally allowed within ngx_lua and will usually result in error messages like &lt;code&gt;lua handler aborted: runtime error: attempt to yield across C-call boundary&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T025337Z" changeid="xf">
        <seg>这在 ngx_lua 中是不允许的，将会导致错误信息如 &lt;code&gt;lua handler aborted: runtime error: attempt to yield across C-call boundary&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interface was first introduced in the &lt;code&gt;v0.3.1rc13&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102518Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc13&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This interface was first introduced in the &lt;code&gt;v0.3.1rc14&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102234Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc14&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is an asynchronous call and will return immediately without waiting for all the data to be written into the system send buffer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041241Z" changeid="xf">
        <seg>这是一个异常调用，立即返回 ，不需要等待所有数据被写进系统发送缓冲区.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is because they have two separate versions of &lt;code&gt;ngx.ctx.blah&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035434Z" changeid="xf">
        <seg>这是因为它们是两个不同的版本.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is functionally identical to the previous examples.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053619Z" changeid="xf">
        <seg>这段代码与前面的代码在功能上完全一致。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is not recommended however).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023246Z" changeid="xf">
        <seg>虽然我们并不推荐这样做).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly the case when LuaJIT 2.0 is enabled.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T034115Z" changeid="xf">
        <seg>在使用LuaJit 2.0时尤其如此.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is particularly useful in the context of [[#header_filter_by_lua|header_filter_by_lua]] and [[#header_filter_by_lua_file|header_filter_by_lua_file]], for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091141Z" changeid="xf">
        <seg>这在 [[#header_filter_by_lua|header_filter_by_lua]] 和 [[#header_filter_by_lua_file|header_filter_by_lua_file]]的上下文中特别有用, 例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the UTC time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022428Z" changeid="xf">
        <seg>这是UTC时间.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the inverse function of [[#ngx.encode_args|ngx.encode_args]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020448Z" changeid="xf">
        <seg>此函数是 [[#ngx.encode_args|ngx.encode_args]] 的反函数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is the local time.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021952Z" changeid="xf">
        <seg>这是本地时间.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This issue is due to limitations in the Nginx event model and only appears to affect Mac OS X.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T024512Z" changeid="xf">
        <seg>此问题源于Nginx事件模型的限制，似乎仅在Mac OS X上发生.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This limit can be manually modified by editing the &lt;code&gt;NGX_MAX_ERROR_STR&lt;/code&gt; macro definition in the &lt;code&gt;src/core/ngx_log.h&lt;/code&gt; file in the Nginx source tree.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034356Z" changeid="xf">
        <seg>可以手工修改Nginx代码树中的&lt;code&gt;src/core/ngx_log.h&lt;/code&gt;文件中的 &lt;code&gt;NGX_MAX_ERROR_STR&lt;/code&gt; 宏定义来修改这个上限。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This limit includes trailing newlines and leading time stamps.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034151Z" changeid="xf">
        <seg>这个限制包括了最后的换行和头部的时间戳。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This mechanism allows calling other nginx C modules' directives that are implemented by [https://github.com/simpl/ngx_devel_kit Nginx Devel Kit] (NDK)'s set_var submodule's &lt;code&gt;ndk_set_var_value&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042046Z" changeid="xf">
        <seg>此机制允许调用由[https://github.com/simpl/ngx_devel_kit Nginx Devel Kit] (NDK) set_var 子模块的 &lt;code&gt;ndk_set_var_value&lt;/code&gt;实现的其它nginx C模块命令。.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method ''must'' be called before [[#ngx.send_headers|ngx.send_headers]] or explicit response body
outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032715Z" changeid="xf">
        <seg>这个方法 ''必须'' 在 [[#ngx.send_headers|ngx.send_headers]] 或使用[[#ngx.printngx.print]] or [[#ngx.sayngx.say]]进行显式的响应体输出之前调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method ''must'' be called before [[#ngx.send_headers|ngx.send_headers]] or explicit response body outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034739Z" changeid="xf">
        <seg>这个方法 ''必须'' 在 [[#ngx.send_headers|ngx.send_headers]] 或使用[[#ngx.printngx.print]] or [[#ngx.sayngx.say]]进行显式的响应体输出之前调用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method also makes the current cosocket object enter the &quot;closed&quot; state, so there is no need to manually call the [[#tcpsock:close|close]] method on it afterwards.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102212Z" changeid="xf">
        <seg>此方法将使当前cosocket对象进入 &quot;closed&quot; 状态, 所以后续不需要对其调用 [[#tcpsock:close|close]] .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method call terminates the current request's processing and never returns.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040107Z" changeid="xf">
        <seg>这个方法将终止当前请求的处理，永不返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method does not actuall free up all the memory blocks in the dictionary but just marks all the existing items as expired.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060448Z" changeid="xf">
        <seg>此方法事实上不会释放字典中所有的内存块，只是让所有现有的项置过期。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is a synchronous operation and is 100% nonblocking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T072039Z" changeid="xf">
        <seg>这是一个同步的，100%非阻塞的操作.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is a synchronous operation just like the [[#tcpsock:send|send]] method and is 100% nonblocking.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T084433Z" changeid="xf">
        <seg>与[[#tcpsock:sendsend]]一样，本方法是一个同步的100％非阻塞的操作.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is a synchronous operation that will not return until ''all'' the data has been flushed into the system socket send buffer or an error occurs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T083016Z" changeid="xf">
        <seg>本方法是个同步操作，直到 ''所有''数据被写入系统socket发送缓冲区，或者出错时才返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is similar to the [[HttpEchoModule#echo_exec|echo_exec]] directive of the [[HttpEchoModule]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034223Z" changeid="xf">
        <seg>此方法类似于 [[HttpEchoModule]] 的 [[HttpEchoModule#echo_exec|echo_exec]] 命令.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method is very much like the [[HttpRewriteModule#rewrite|rewrite]] directive with the &lt;code&gt;redirect&lt;/code&gt; modifier in the standard
[[HttpRewriteModule]], for example, this &lt;code&gt;nginx.conf&lt;/code&gt; snippet</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034849Z" changeid="xf">
        <seg>此方法很象标准[[HttpRewriteModule]]中带有&lt;code&gt;redirect&lt;/code&gt;选项的 [[HttpRewriteModule#rewrite|rewrite]] 命令, 例如这段 &lt;code&gt;nginx.conf&lt;/code&gt; 配置</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method may lock the dictionary for quite a while and block all the nginx worker processes that are trying to access the dictionary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060953Z" changeid="xf">
        <seg>这个方法可能会将字典锁一段时间，阻塞试图访问此字典的所有nginx worker进程。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method never returns.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T032605Z" changeid="xf">
        <seg>这个方法永不返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method performs better on relatively long &lt;code&gt;str&lt;/code&gt; inputs (i.e., longer than 30 ~ 60 bytes), as compared to [[#ngx.crc32_short|ngx.crc32_short]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021022Z" changeid="xf">
        <seg>此方法对于相对长的 &lt;code&gt;str&lt;/code&gt; 参数(大于 30 ~ 60 字节) 比 [[#ngx.crc32_short|ngx.crc32_short]]要快.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method performs better on relatively short &lt;code&gt;str&lt;/code&gt; inputs (i.e., less than 30 ~ 60 bytes), as compared to [[#ngx.crc32_long|ngx.crc32_long]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020846Z" changeid="xf">
        <seg>此方法对于相对短的 &lt;code&gt;str&lt;/code&gt; 参数(小于 30 ~ 60 字节) 比 [[#ngx.crc32_long|ngx.crc32_long]]要快.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method requires the PCRE library enabled in Nginx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025349Z" changeid="xf">
        <seg>此方法需要Nginx编译时加上 PCRE 库.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method returns an iterator Lua function that can be called to read the data stream until it sees the specified pattern or an error occurs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T093815Z" changeid="xf">
        <seg>本方法返回一个iterator Lua函数，此函数被用来读取数据流，直到遇到指定的模式或出错。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method returns the (successfully) reused times for the current connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T102240Z" changeid="xf">
        <seg>本方法返回当前连接被 (成功) 使用的次数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method returns the resulting new string as well as the number of successful substitutions.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032135Z" changeid="xf">
        <seg>返回生成的新字符串以及成功匹配的数目.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method was first introduced in the &lt;code&gt;0.8.6&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034900Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.8.6&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method was first introduced in the &lt;code&gt;v0.3.1rc27&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020344Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc27&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method was first introduced in the &lt;code&gt;v0.5.0rc1&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T075024Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc1&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method was first introduced in the &lt;code&gt;v0.5.6&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095522Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.6&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method was first introduced in the &lt;code&gt;v0.5.7&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T070130Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.7&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method was first introduced in the &lt;code&gt;v0.7.17&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095144Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.7.17&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method was introduced in the &lt;code&gt;0.5.0rc30&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015942Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc30&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method was introduced in the &lt;code&gt;v0.5.0rc29&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020553Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.5.0rc29&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This method will not return until it reads exactly this size of data or an error occurs.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T084723Z" changeid="xf">
        <seg>本方法将在读取到这个数值大小的数据或出错时才返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This module embeds Lua, via the standard Lua 5.1 interpreter or [http://luajit.org/luajit.html LuaJIT 2.0], into Nginx and by leveraging Nginx's subrequests, allows the integration of the powerful Lua threads (Lua coroutines) into the Nginx event model.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T081520Z" changeid="xf">
        <seg>此模块将Lua（标准的Lua 5.1或 [http://luajit.org/luajit.html LuaJIT 2.0]）嵌入Nginx, 利用了Nginx的subrequest，把强大的Lua协程（Lua coroutines）集成进Nginx的事件模型。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This module is under active development and is production ready.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034954Z" changeid="xf">
        <seg>模块持续更新中，可用于生产环境。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option is set to &lt;code&gt;false&lt;/code&gt; by default</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053909Z" changeid="xf">
        <seg>此选项默认设为 &lt;code&gt;false&lt;/code&gt; </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option was first introduced in the &lt;code&gt;v0.3.1rc25&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041804Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc25&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option was first introduced in the &lt;code&gt;v0.3.1rc31&lt;/code&gt; release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041909Z" changeid="xf">
        <seg>本命令在 &lt;code&gt;v0.3.1rc31&lt;/code&gt; 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This setting can be overridden by cosocket objects' [[#tcpsock:setkeepalive|setkeepalive]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104518Z" changeid="xf">
        <seg>可以用 cosocket 对象的' [[#tcpsock:setkeepalive|setkeepalive]] 方法来修改.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This setting can be overridden by the [[#tcpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T103137Z" changeid="xf">
        <seg>可以用 [[#tcpsock:settimeout|settimeout]] 方法进行修改.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This should be called
before sending out the response headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T083630Z" changeid="xf">
        <seg>对它的调用应在发送响应头之前。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This table can be used to store per-request Lua context data and has a life time identical to the current request (as with the Nginx variables).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T034514Z" changeid="xf">
        <seg>这个table可用于存储每个请求的Lua上下文数据，其生命周期与当前请求一致 (和 Nginx 变量一样).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This transformation can be turned off via the [[#lua_transform_underscores_in_response_headers|lua_transform_underscores_in_response_headers]] directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084048Z" changeid="xf">
        <seg>这个转换可以通过 [[#lua_transform_underscores_in_response_headers|lua_transform_underscores_in_response_headers]] 命令来关闭.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This trick can be used do back-ground jobs without letting the HTTP clients to wait on the connection, as in the following example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015420Z" changeid="xf">
        <seg>这个技巧可以用来运行后台任务，而不必让HTTP客户端等待连接，如下例:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will be the case if &lt;code&gt;rewrite ^ /bar last&lt;/code&gt; is used as this will similarly initiate an internal redirection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080429Z" changeid="xf">
        <seg>如果写成 &lt;code&gt;rewrite ^ /bar last&lt;/code&gt; 也是同样结果，因为这也会类似地引发内部重定向</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will guarantee that local variables in the Lua module functions are all declared with the &lt;code&gt;local&lt;/code&gt; keyword, otherwise a runtime exception will be thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T030550Z" changeid="xf">
        <seg>这全保证Lua模块函数中的本地变量都被加上 &lt;code&gt;local&lt;/code&gt; 关键字, 否则就会抛出运行时异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This will truncate the response body and usually result in incomplete and also invalid responses.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T095128Z" changeid="xf">
        <seg>这将会截断响应体，通常会造成不完整并且是无效的响应</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This works because required Lua modules are loaded only once and all coroutines will share the same copy of the module (both its code and data).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041006Z" changeid="xf">
        <seg>其工作原理是被require的Lua模块仅加载一次，所有的coroutine将共享这个模块的同一个拷贝 (包括代码和数据).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T091814Z" changeid="xf">
        <seg>所以，在单个请求的生命周期中本命令中的代码也可能运行多次。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time consuming code sequences should therefore be avoided.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T093152Z" changeid="xf">
        <seg>所以应避免在这里编写耗时较长的代码序列。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timeout for the connecting operation is controlled by the [[#lua_socket_connect_timeout|lua_socket_connect_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074705Z" changeid="xf">
        <seg>连接操作的超时由 [[#lua_socket_connect_timeout|lua_socket_connect_timeout]] 配置命令和 [[#tcpsock:settimeout|settimeout]] 控制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timeout for the iterator function's reading operation is controlled by the [[#lua_socket_read_timeout|lua_socket_read_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T095747Z" changeid="xf">
        <seg>iterator 函数读操作的超时由 [[#lua_socket_read_timeout|lua_socket_read_timeout]] 配置命令和 [[#tcpsock:settimeout|settimeout]] 方法控制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timeout for the reading operation is controlled by the [[#lua_socket_read_timeout|lua_socket_read_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T090157Z" changeid="xf">
        <seg>读操作的超时由 [[#lua_socket_read_timeout|lua_socket_read_timeout]] 配置命令和 [[#tcpsock:settimeout|settimeout]] 方法控制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timeout for the reading operation is controlled by the [[#lua_socket_read_timeout|lua_socket_read_timeout]] config directive and the [[#udpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T073526Z" changeid="xf">
        <seg>读操作的超时由 [[#lua_socket_read_timeout|lua_socket_read_timeout]] 配置命令和 [[#udpsock:settimeout|settimeout]] 方法控制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Timeout for the sending operation is controlled by the [[#lua_socket_send_timeout|lua_socket_send_timeout]] config directive and the [[#tcpsock:settimeout|settimeout]] method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T083116Z" changeid="xf">
        <seg>发送操作的超时由 [[#lua_socket_send_timeout|lua_socket_send_timeout]] 配置命令和 [[#tcpsock:settimeout|settimeout]] 管理.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid this, ''double'' escape the backslash:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031110Z" changeid="xf">
        <seg>为了避免错误，要进行 ''双重'' 转义 :</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid this, define a real Lua module and use the Lua &lt;code&gt;require&lt;/code&gt; builtin instead.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T025404Z" changeid="xf">
        <seg>为避免这种错误，定义一个真正的 Lua 模块而用内置的 &lt;code&gt;require&lt;/code&gt; 加载.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To confirm that PCRE JIT is enabled, activate the Nginx debug log by adding the &lt;code&gt;--with-debug&lt;/code&gt; option to Nginx or ngx_openresty's &lt;code&gt;./configure&lt;/code&gt; script.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025557Z" changeid="xf">
        <seg>要确认打开了 PCRE JIT , 给Nginx 或 ngx_openresty's &lt;code&gt;./configure&lt;/code&gt;加上&lt;code&gt;--with-debug&lt;/code&gt;选项，打开Nginx debug日志.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To ensure code caching, you can either use the [[#init_by_lua|init_by_lua]]
or [[#init-by_lua_file|init_by_lua_file]] directives to load all such files or just make these Lua files true Lua modules
and load them via &lt;code&gt;require&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T043004Z" changeid="xf">
        <seg>为了保证代码被缓存，你要么用 [[#init_by_lua|init_by_lua]]
或 [[#init-by_lua_file|init_by_lua_file]] 命令来加载文件或将这些Lua文件写成真正的Lua模块，并使用 &lt;code&gt;require&lt;/code&gt; 来加载.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To force &lt;code&gt;curl&lt;/code&gt; to send HTTP 1.0 requests, use the &lt;code&gt;-0&lt;/code&gt; option.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040646Z" changeid="xf">
        <seg>要强制 &lt;code&gt;curl&lt;/code&gt; 发送 HTTP 1.0 请求, 使用 &lt;code&gt;-0&lt;/code&gt; 选项.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To force in-file request bodies, try turning on [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023805Z" changeid="xf">
        <seg>要强制使用文件请求体, 打开 [[HttpCoreModule#client_body_in_file_only|client_body_in_file_only]].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To force in-memory request bodies, try setting [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] to the same size value in [[HttpCoreModule#client_max_body_size|client_max_body_size]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023610Z" changeid="xf">
        <seg>要强制使用内存请求体，将 [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] 设置成与 [[HttpCoreModule#client_max_body_size|client_max_body_size]] 同样的值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To globally share data among all the requests handled by the same nginx worker process, encapsulate the shared data into a Lua module, use the Lua &lt;code&gt;require&lt;/code&gt; builtin to import the module, and then manipulate the shared data in Lua.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T040828Z" changeid="xf">
        <seg>要在同一个nginx worker进程处理的所有请求之间共享数据，将共享数据封装到一个Lua模块中，使用内置的 &lt;code&gt;require&lt;/code&gt; 引入模块, 然后用Lua操作共享的数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To output very large response data in a streaming fashion (via the [[#ngx.flush|ngx.flush]] call, for example), this directive MUST be turned off to minimize memory usage.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T020427Z" changeid="xf">
        <seg>如果要以流的方式输出大的响应数据 (例如通过 [[#ngx.flush|ngx.flush]] 调用), 本命令必须关闭来使内存的使用最小化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To prevent
extreme consequences like crashing the Nginx server, there are
built-in limitations on both the number of &quot;pending timers&quot; and the
number of &quot;running timers&quot; in an Nginx worker process.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T042441Z" changeid="xf">
        <seg>为了避免象导致Nginx服务器崩溃这种极端后果，对于一个Nginx worker进程中的&quot;等待中&quot;的定时器和&quot;运行中&quot;的定时器数量都有内置的限制.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To quote the PCRE manpage, &quot;the limit ... has the effect of limiting the amount of backtracking that can take place.&quot;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060826Z" changeid="xf">
        <seg>引自 PCRE manpage： &quot;这个上限... 是用来限制正则表达式中允许的backtracking的最大数目&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To read an individual header:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015343Z" changeid="xf">
        <seg>要读取某一个头:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To read the request body data within the [[HttpCoreModule#$request_body|$request_body]] variable, 
[[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] must have the same value as [[HttpCoreModule#client_max_body_size|client_max_body_size]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T101851Z" changeid="xf">
        <seg>要在 [[HttpCoreModule#$request_body|$request_body]] 变量中读取请求体数据, 
[[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] 必须与 [[HttpCoreModule#client_max_body_size|client_max_body_size]] 的值相同.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To return an error page with custom contents, use code snippets like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015018Z" changeid="xf">
        <seg>要返回带有自定义内容的错误页面, 使用这样的代码:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To run in synchronous mode, call &lt;code&gt;ngx.flush(true)&lt;/code&gt; after calling &lt;code&gt;ngx.print&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041314Z" changeid="xf">
        <seg>要在同步模式中运行，在&lt;code&gt;ngx.print&lt;/code&gt; 之后调用 &lt;code&gt;ngx.flush(true)&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To terminate the current request from within a [[#access_by_lua|access_by_lua]] handler, calling [[#ngx.exit|ngx.exit]] with status &gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;) and status &lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) for successful quits and &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (or its friends) for failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T052115Z" changeid="xf">
        <seg>要在 [[#access_by_lua|access_by_lua]] 处理器中终止请求处理, 如果是成功退出，要调用 [[#ngx.exit|ngx.exit]]将状态码设置为 &gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;)  &lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) 的值，如果是失败退出调用 &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (或类似的值).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To terminate the current request from within a [[#rewrite_by_lua|rewrite_by_lua]] handler, calling [[#ngx.exit|ngx.exit]] with status &gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;) and status &lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) for successful quits and &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (or its friends) for failures.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T075938Z" changeid="xf">
        <seg>To terminate the current request from within a 要在 [[#rewrite_by_lua|rewrite_by_lua]] handler中终止请求处理, 如果是成功退出，要调用 [[#ngx.exit|ngx.exit]]将状态码设置为 &gt;= 200 (&lt;code&gt;ngx.HTTP_OK&lt;/code&gt;)  &lt; 300 (&lt;code&gt;ngx.HTTP_SPECIAL_RESPONSE&lt;/code&gt;) 的值，如果是失败退出调用 &lt;code&gt;ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)&lt;/code&gt; (或类似的值).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>U             similar to &quot;u&quot; but disables PCRE's UTF-8 validity check on</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024503Z" changeid="xf">
        <seg>U             类似于 &quot;u&quot; 但禁止  PCRE 对目标字符串进行UTF-8校验</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI arguments can be specified as well, for example:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040041Z" changeid="xf">
        <seg>也可以指定URI参数URI, 例如:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>URI query strings can be concatenated to URI itself, for instance,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041236Z" changeid="xf">
        <seg>URI query string可以被添加到URI本身 如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unconditionally removes the key-value pair from the shm-based dictionary [[#ngx.shared.DICT|ngx.shared.DICT]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T055249Z" changeid="xf">
        <seg>从基于共享内存的字典[[#ngx.shared.DICTngx.shared.DICT]]中无条件删除key-value对.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unconditionally sets a key-value pair into the shm-based dictionary [[#ngx.shared.DICT|ngx.shared.DICT]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034939Z" changeid="xf">
        <seg>无条件向基于共享内存的字典 [[#ngx.shared.DICTngx.shared.DICT]]中写入一个key-value对.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscores (&lt;code&gt;_&lt;/code&gt;) in the header names will also be replaced by dashes (&lt;code&gt;-&lt;/code&gt;) and the header names will be matched case-insensitively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091034Z" changeid="xf">
        <seg>同样，头名称中的下划线 (&lt;code&gt;_&lt;/code&gt;) 将被替换成减号 (&lt;code&gt;-&lt;/code&gt;) ，头名称的匹配是大小写无关的。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Underscores (&lt;code&gt;_&lt;/code&gt;) in the header names will be replaced by hyphens (&lt;code&gt;-&lt;/code&gt;) by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084030Z" changeid="xf">
        <seg>默认会将头名称中的下划线(&lt;code&gt;_&lt;/code&gt;) 换成减号 (&lt;code&gt;-&lt;/code&gt;) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unescape &lt;code&gt;str&lt;/code&gt; as an escaped URI component.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020028Z" changeid="xf">
        <seg>将URI片段 &lt;code&gt;str&lt;/code&gt; 解转义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike [http://httpd.apache.org/docs/2.3/mod/mod_lua.html Apache's mod_lua] and [http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet Lighttpd's mod_magnet], Lua code executed using this module can be ''100% non-blocking'' on network traffic as long as the [[#Nginx API for Lua|Nginx API for Lua]] provided by this module is used to handle
requests to upstream services such as MySQL, PostgreSQL, Memcached, Redis, or upstream HTTP web services.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T081650Z" changeid="xf">
        <seg>与[http://httpd.apache.org/docs/2.3/mod/mod_lua.html Apache's mod_lua] 和 [http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet Lighttpd's mod_magnet] 不同, 只要使用[[#Nginx API for Lua|Nginx API for Lua]]来处理到upstream服务如MySQL，PostgreSQL，Memcached, Redis或upstream web service的请求, 使用本模块运行的Lua代码在处理网络请求时可以是 ''100% 非阻塞的''。 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike as with LuaJIT, debug information is included in standard Lua 5.1 bytecode files by default.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035843Z" changeid="xf">
        <seg>与LuaJIT不同, 标准 Lua 5.1 字节码文件中默认就携带调试信息.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unlike the [[#ngx.shared.DICT.flush_all|flush_all]] method, this method actually free up the memory used by the expired items.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060654Z" changeid="xf">
        <seg>与 [[#ngx.shared.DICT.flush_all|flush_all]] 不同, 本方法会事实上释放已过期项目占用的内存.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unmatched subpatterns will have &lt;code&gt;nil&lt;/code&gt; values in their &lt;code&gt;captures&lt;/code&gt; table fields.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024115Z" changeid="xf">
        <seg>没有匹配上的子模板在&lt;code&gt;captures&lt;/code&gt; table中的值为&lt;code&gt;nil&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updates of the Nginx time cache an be forced by calling [[#ngx.update_time|ngx.update_time]] first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022129Z" changeid="xf">
        <seg>可以先用[[#ngx.update_timengx.update_time]]强制刷新Nginx时间缓存.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updating query arguments via the nginx variable &lt;code&gt;$args&lt;/code&gt; (or &lt;code&gt;ngx.var.args&lt;/code&gt; in Lua) at runtime is also supported:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103027Z" changeid="xf">
        <seg>还支持在运行时用ngxin变量 &lt;code&gt;$args&lt;/code&gt; (或Lua &lt;code&gt;ngx.var.args&lt;/code&gt; )来更新请求参数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use normal locations combined with the &lt;code&gt;internal&lt;/code&gt; directive to
prepare internal-only locations.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T041432Z" changeid="xf">
        <seg>对普通的location使用 &lt;code&gt;internal&lt;/code&gt; 命令来准备只作内部使用的location.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of jump in other contexts is prohibited and will throw out a Lua exception.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102102Z" changeid="xf">
        <seg>在其它的上下文中使用jump是被禁止的，会抛出Lua异常。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use of the [http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall package.seeall] flag is strongly discouraged due to its various bad side-effects.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T023835Z" changeid="xf">
        <seg>由于其所带来的各种不好的负作用，强烈不推荐使用 [http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall package.seeall] 标记。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the [[#ngx.req.get_post_args|ngx.req.get_post_args]] function instead if a Lua table is required.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T023105Z" changeid="xf">
        <seg>如果需要Lua table请使用[[#ngx.req.get_post_args|ngx.req.get_post_args]] 函数.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>User &quot;light threads&quot; can create &quot;light threads&quot; themselves and normal user coroutiens created by [[#coroutine.create|coroutine.create]] can also create &quot;light threads&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T015657Z" changeid="xf">
        <seg>用户 &quot;轻量线程&quot; 自己也可以创建 &quot;轻量线程&quot; , 由 [[#coroutine.createcoroutine.create]]创建的普通用户coroutine也可以创建&quot;轻量线程&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uses Lua code specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; to define an output body filter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094824Z" changeid="xf">
        <seg>用 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; 中的代码来定义一个输出体过滤器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Uses Lua code specified in &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; to define an output header filter.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T094508Z" changeid="xf">
        <seg>用 &lt;code&gt;&lt;lua-script-str&gt;&lt;/code&gt; 中的代码来定义一个输出头过滤器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Usually you can register (true) Lua global variables or pre-load Lua modules at server start-up by means of this hook.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063000Z" changeid="xf">
        <seg>通常你可以使用这个hook在服务器启动时来注册（真正的）Lua全局变量 或预加载Lua模块。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Waits on one or more child &quot;light threads&quot; and returns the results of the first &quot;light thread&quot; that terminates (either successfully or with an error).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T020729Z" changeid="xf">
        <seg>等待一个或多个子 &quot;轻量线程&quot; 并返回第一个结束(成功或出错)的 &quot;轻量线程&quot; 的结果 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can also use the numerical code directly as the second &lt;code&gt;status&lt;/code&gt; argument:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034651Z" changeid="xf">
        <seg>我们也可以直接在 &lt;code&gt;status&lt;/code&gt; 参数中使用数字状态码:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;code&gt;ngx.flush(true)&lt;/code&gt; is called immediately after [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]], it causes the latter functions to run in synchronous mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042340Z" changeid="xf">
        <seg>如果在[[#ngx.printngx.print]] 或 [[#ngx.sayngx.say]]之后立即调用 &lt;code&gt;ngx.flush(true)&lt;/code&gt; , 将导致前者运行于同步模式。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;code&gt;status == 0&lt;/code&gt; (i.e., &lt;code&gt;ngx.OK&lt;/code&gt;), it will only quit the current phase handler (or the content handler if the [[#content_by_lua|content_by_lua]] directive is used) and continue to run later phases (if any) for the current request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T014940Z" changeid="xf">
        <seg>如果&lt;code&gt;status == 0&lt;/code&gt; (即, &lt;code&gt;ngx.OK&lt;/code&gt;), 将只退出当前的阶段处理器 ( 如果使用了[[#content_by_luacontent_by_lua]]，则是当前的内容处理器)，会继续执行当前请求的后续阶段（如果有的话）。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When &lt;code&gt;status &gt;= 200&lt;/code&gt; (i.e., &lt;code&gt;ngx.HTTP_OK&lt;/code&gt; and above), it will interrupt the execution of the current request and return status code to nginx.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T014812Z" changeid="xf">
        <seg>如果 &lt;code&gt;status &gt;= 200&lt;/code&gt; (即, &lt;code&gt;ngx.HTTP_OK&lt;/code&gt; 及以上), 它将中断当前请求的执行直接将状态码返回给nginx.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When Nginx receives the &lt;code&gt;HUP&lt;/code&gt; signal and starts reloading the config file, the Lua VM will also be re-created and &lt;code&gt;init_by_lua&lt;/code&gt; will run again on the new Lua VM.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T062921Z" changeid="xf">
        <seg>如果 Nginx 收到&lt;code&gt;HUP&lt;/code&gt; 信号，开始重新加载配置文件, Lua虚拟机将被重新创建， &lt;code&gt;init_by_lua&lt;/code&gt;会在新的Lua虚拟机中被重新运行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a &lt;code&gt;FIN&lt;/code&gt; packet or something like that).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021900Z" changeid="xf">
        <seg>如果TCP keepalive被禁止, 需要依赖客户端来完美地关闭socket (发送 &lt;code&gt;FIN&lt;/code&gt; 或类似的包).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When [[#lua_check_client_abort|lua_check_client_abort]] is set to &lt;code&gt;off&lt;/code&gt; (which is the default), then this function call will always return the error message &quot;lua_check_client_abort is off&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T021842Z" changeid="xf">
        <seg>如果[[#lua_check_client_abort|lua_check_client_abort]] 设为 &lt;code&gt;off&lt;/code&gt; (这是默认值), 则此函数总是返回错误信息 &quot;lua_check_client_abort is off&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a match is found, a Lua table &lt;code&gt;captures&lt;/code&gt; is returned, where &lt;code&gt;captures[0]&lt;/code&gt; holds the whole substring being matched, and &lt;code&gt;captures[1]&lt;/code&gt; holds the first parenthesized sub-pattern's capturing, &lt;code&gt;captures[2]&lt;/code&gt; the second, and so on.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024139Z" changeid="xf">
        <seg>如果有匹配，返回 Lua table &lt;code&gt;captures&lt;/code&gt; , 其中 &lt;code&gt;captures[0]&lt;/code&gt; 装有匹配到的整个子串, &lt;code&gt;captures[1]&lt;/code&gt; 装有第一个对第一个括号子模板的捕捉结果, &lt;code&gt;captures[2]&lt;/code&gt; 装有第二个，依此类推.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a relative path like &lt;code&gt;foo/bar.lua&lt;/code&gt; is given, they will be turned into the absolute path relative to the &lt;code&gt;server prefix&lt;/code&gt; path determined by the &lt;code&gt;-p PATH&lt;/code&gt; command-line option while starting the Nginx server.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T072132Z" changeid="xf">
        <seg>如果指定的是相对路径如 &lt;code&gt;foo/bar.lua&lt;/code&gt; , 它们将被加上 &lt;code&gt;server prefix&lt;/code&gt; 转换成绝对路径。&lt;code&gt;server prefix&lt;/code&gt;可由在Nginx服务器启动时使用&lt;code&gt;-p PATH&lt;/code&gt; 命令行参数来得到。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a timer expires, the user Lua code in the timer callback is
running in a &quot;light thread&quot; detached completely from the original
request creating the timer.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T022951Z" changeid="xf">
        <seg>当定时器过期时, 定时器回调函数中的用户Lua代码将在一个与创建定时器的请求脱离的&quot;轻量线程&quot;中运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called with the default argument, it issues an asynchronous call (Returns immediately without waiting for output data to be written into the system send buffer).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T042016Z" changeid="xf">
        <seg>当用默认参数调用时, 会发起一个异步调用 (立即返回， 不需要等待所有数据被写进系统发送缓冲区).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When called without any argument, the iterator function returns the received data right ''before'' the specified pattern string in the incoming data stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T094443Z" changeid="xf">
        <seg>如果不加任何参数调用iterator函数，它将返回输入数据流中在指定的模式字符串 ''之前'' 的数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message &quot;N lua_max_running_timers are not enough&quot; where &quot;N&quot; is the current value of this directive.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022944Z" changeid="xf">
        <seg>当数量超限时，, Nginx将停止运行最新过期的定时器并记录错误日志消息 &quot;N lua_max_running_timers are not enough&quot; ，其中 &quot;N&quot; 是本命令当前所设置的值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When exceeding this limit, the [[#ngx.timer.at|ngx.timer.at]] call will immediately return &lt;code&gt;nil&lt;/code&gt; and the error string &quot;too many pending timers&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T022644Z" changeid="xf">
        <seg>当定时器数量超限时, [[#ngx.timer.at|ngx.timer.at]] 调用将立即返回 &lt;code&gt;nil&lt;/code&gt; 和错误信息 &quot;too many pending timers&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When it fails to allocate memory for the current key-value item, then &lt;code&gt;set&lt;/code&gt; will try removing existing items in the storage according to the Least-Recently Used (LRU) algorithm.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013649Z" changeid="xf">
        <seg>如果为当前的键－值对项分配内存失败, &lt;code&gt;set&lt;/code&gt; 将尝试用LRU算法从存储区删除某些已经存在的项.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When match fails, the &lt;code&gt;ctx&lt;/code&gt; table will be left intact.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T025013Z" changeid="xf">
        <seg>如果匹配失败, &lt;code&gt;ctx&lt;/code&gt; table将不变.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When setting &lt;code&gt;nil&lt;/code&gt; or an empty Lua string value to &lt;code&gt;ngx.arg[1]&lt;/code&gt;, no data chunk will be passed to the downstream Nginx output filters at all.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T094846Z" changeid="xf">
        <seg>如果将&lt;code&gt;ngx.arg[1]&lt;/code&gt;设置成 &lt;code&gt;nil&lt;/code&gt; 或空的Lua string , 将不会有数据发往下游 Nginx输出过滤器。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When setting the limit to 0, the default &quot;match limit&quot; when compiling the PCRE library is used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060942Z" changeid="xf">
        <seg>如果此值设为0, 将使用编译 PCRE 库时的默认“match limit”值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the &lt;code&gt;&lt;max_count&gt;&lt;/code&gt; argument is given the value &lt;code&gt;0&lt;/code&gt;, then all the keys will be returned even there is more than 1024 keys in the dictionary.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060848Z" changeid="xf">
        <seg>如果 &lt;code&gt;&lt;max_count&gt;&lt;/code&gt; 参数是值是 &lt;code&gt;0&lt;/code&gt;, 即使有多于1024项，也全部返回.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the &lt;code&gt;body&lt;/code&gt; option is not specified, the &lt;code&gt;POST&lt;/code&gt; and &lt;code&gt;PUT&lt;/code&gt; subrequests will inherit the request bodies of the parent request (if any).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082353Z" changeid="xf">
        <seg>如果没有指定 &lt;code&gt;body&lt;/code&gt; 选项， &lt;code&gt;POST&lt;/code&gt; 和 &lt;code&gt;PUT&lt;/code&gt; 子请求将从父请求中继承请求体(如果有的话).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the &lt;code&gt;header_value&lt;/code&gt; argument is &lt;code&gt;nil&lt;/code&gt;, the request header will be removed.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021220Z" changeid="xf">
        <seg>如果 &lt;code&gt;header_value&lt;/code&gt; 参数是&lt;code&gt;nil&lt;/code&gt;, 这个请求头将被删除.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the &lt;code&gt;max_count&lt;/code&gt; argument is given &lt;code&gt;0&lt;/code&gt; or not given at all, then it means unlimited.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T060610Z" changeid="xf">
        <seg>如果 &lt;code&gt;max_count&lt;/code&gt; 参数没有或是 &lt;code&gt;0&lt;/code&gt;, 那就是清除所有的.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the &lt;code&gt;pos&lt;/code&gt; field in the &lt;code&gt;ctx&lt;/code&gt; table argument is specified, &lt;code&gt;ngx.re.match&lt;/code&gt; will start matching from that offset.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024832Z" changeid="xf">
        <seg>如果&lt;code&gt;ctx&lt;/code&gt; table中指定了 &lt;code&gt;pos&lt;/code&gt;，则 &lt;code&gt;ngx.re.match&lt;/code&gt; 将从这个位置开始匹配 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the &lt;code&gt;replace&lt;/code&gt; argument is of type &quot;function&quot;, then it will be invoked with the &quot;match table&quot; as the argument to generate the replace string literal for substitution.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032622Z" changeid="xf">
        <seg>如果 &lt;code&gt;replace&lt;/code&gt; 参数的类型是 &quot;函数&quot;, 则它会作用于 &quot;匹配结果table&quot; 生成替换后的字符串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the &lt;code&gt;replace&lt;/code&gt; is a string, then it is treated as a special template for string replacement.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032241Z" changeid="xf">
        <seg>如果 &lt;code&gt;replace&lt;/code&gt; 是航空器, 则它将被用作字符串替换的特殊模板.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached 
and the Nginx config must be reloaded each time the Lua source file is modified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073711Z" changeid="xf">
        <seg>如果Lua代码缓存被打开 (这是默认行为), 用户代码在第一个请求中被加载并缓存，每次Lua代码文件被修改后，需要重新加载Nginx配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T080754Z" changeid="xf">
        <seg>如果Lua代码缓存被打开 (这是默认行为), 用户代码在第一个请求中被加载并缓存，每次Lua代码文件被修改后，需要重新加载Nginx配置文件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the Lua code may change the length of the response body, then it is required to always clear out the &lt;code&gt;Content-Length&lt;/code&gt; response header (if any) in a header filter to enforce streaming output, as in</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T095500Z" changeid="xf">
        <seg>如果Lua 代码可能改变响应体的长度, 就总是需要用头过滤器来清除 &lt;code&gt;Content-Length&lt;/code&gt; 响应头 (如果有的话)来保证流输出的正确性, 例如</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the Nginx worker
is trying to shut down, one can no longer call &lt;code&gt;ngx.timer.at&lt;/code&gt; to
create new timers and in that case &lt;code&gt;ngx.timer.at&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt; and
a string describing the error, that is, &quot;process exiting&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T022846Z" changeid="xf">
        <seg>当Nginx worker进程尝试关闭时，不能再调用 &lt;code&gt;ngx.timer.at&lt;/code&gt; 创建新的定时器，&lt;code&gt;ngx.timer.at&lt;/code&gt; 将返回&lt;code&gt;nil&lt;/code&gt; 及错误字符串 &quot;process exiting&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104240Z" changeid="xf">
        <seg>当连接池使用超限时, 池中最不经常使用的 (空闲) 连接将被关闭，为当前连接腾出空间。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the current request's request body has been read into memory or buffered into a disk file, then the old request body's memory will be freed or the disk file will be cleaned up immediately, respectively.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T024023Z" changeid="xf">
        <seg>如果当前请求的请求体已经被读入内存，则旧的请求体内存将被释放；如果已经被读入磁盘文件，则此文件将被立即删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the data can no longer be hold in the memory buffer for the request body, then the data will be flushed onto a temporary file just like the standard request body reader in the Nginx core.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030341Z" changeid="xf">
        <seg>当请求体数据不再能保留在内存中时，数据将被写到一个临时文件里，就象Nginx核心中的标准请求体读取器一样.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the limit is hit, the error string &quot;pcre_exec() failed: -8&quot; will be returned by the [[#ngx.re.match|ngx.re API]] functions on the Lua land.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T060911Z" changeid="xf">
        <seg>当达到这个上限时, 在Lua一方，[[#ngx.re.matchngx.re API]]会返回 &quot;pcre_exec() failed: -8&quot; 错误信息。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When the user &quot;light thread&quot; terminates with a Lua error, however, it will not abort other running &quot;light threads&quot; like the &quot;entry thread&quot; does.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T014727Z" changeid="xf">
        <seg>但是如果用户 &quot;轻量线程&quot; 由于Lua错误而终止， 它不会象&quot;入口线程&quot;那样导致其它正在运行的 &quot;轻量线程&quot; 被中断.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this argument is omitted, the default setting in the [[#lua_socket_pool_size|lua_socket_pool_size]] config directive will be used.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T101952Z" changeid="xf">
        <seg>如果没有这个参数，将使用 [[#lua_socket_pool_size|lua_socket_pool_size]] 配置命令中的默认设置.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this directive is turned on, the ngx_lua module will monitor the premature connection close event on the downstream connections.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T021251Z" changeid="xf">
        <seg>如果本命令被打开， ngx_lua 模块将监视下游连接的过早连接关闭事件。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this is used in the context of the [[#set_by_lua|set_by_lua]] or [[#set_by_lua_file|set_by_lua_file]] directives, this table is read-only and holds the input arguments to the config directives:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024553Z" changeid="xf">
        <seg>如果被用于 [[#set_by_lua|set_by_lua]] 或 [[#set_by_lua_file|set_by_lua_file]] 命令的上下文中, 这个table是只读的，装有配置命令的输入参数:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this limit is exceeded, the following error message is added to the &lt;code&gt;error.log&lt;/code&gt; file:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T082536Z" changeid="xf">
        <seg>如果超限， &lt;code&gt;error.log&lt;/code&gt; 文件中将记录以下错误日志:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this table is used in the context of [[#body_filter_by_lua|body_filter_by_lua]] or [[#body_filter_by_lua_file|body_filter_by_lua_file]], the first element holds the input data chunk to the output filter code and the second element holds the boolean flag for the &quot;eof&quot; flag indicating the end of the whole output data stream.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T031853Z" changeid="xf">
        <seg>如果在 [[#body_filter_by_lua|body_filter_by_lua]] 或 [[#body_filter_by_lua_file|body_filter_by_lua_file]]中使用这个table, 第一个元素保存的是发给输出过滤器的数据块，第二个元素保存的是标记整个输出数据流&quot;eof&quot;的boolean值。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When this timeout reaches, idle connections will be closed and removed from the pool.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130805T104454Z" changeid="xf">
        <seg>如果超时, 空闲的连接将被关闭并从池中删除。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you disable the HTTP 1.1 keep-alive feature for your downstream connections, you can rely on descent HTTP clients to close the connection actively for you when you call this method.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015356Z" changeid="xf">
        <seg>如果对下游连接禁止了HTTP 1.1 keep-alive功能, 可以使用此方法让良好实现的HTTP客户端来关闭连接。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With the settings above,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013300Z" changeid="xf">
        <seg>按以上设置,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this approach, the backslashes are only stripped by the Lua language parser and therefore only need to be escaped once each.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031714Z" changeid="xf">
        <seg>使用这种方法，反斜线仅会被Lua语言解析器处理一次，因此不必多次转义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this in place, developers can adopt an edit-and-refresh approach.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T042537Z" changeid="xf">
        <seg>有了它，开发者可以采用象开发php那样修改-刷新即可 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Within external script files, PCRE sequences presented as long-bracketed Lua string literals do not require modification.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031802Z" changeid="xf">
        <seg>在外部脚本文件里，用双方括号表示的Lua字符串不需要作修改。.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Writes argument values into the nginx &lt;code&gt;error.log&lt;/code&gt; file with the &lt;code&gt;ngx.NOTICE&lt;/code&gt; log level.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033822Z" changeid="xf">
        <seg>将参数值以&lt;code&gt;ngx.NOTICE&lt;/code&gt;级别写入nginx &lt;code&gt;error.log&lt;/code&gt; 文件.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yields the executation of the current user Lua coroutine.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T035249Z" changeid="xf">
        <seg>挂起当前Lua coroutine的执行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You always need to check the &lt;code&gt;res.truncated&lt;/code&gt; boolean flag to see if &lt;code&gt;res.body&lt;/code&gt; contains truncated data.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T052843Z" changeid="xf">
        <seg>你总是需要检查 &lt;code&gt;res.truncated&lt;/code&gt; boolean 标记来确认 &lt;code&gt;res.body&lt;/code&gt; 是否包含被截断的数据.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can also initialize the [[#lua_shared_dict|lua_shared_dict]] shm storage at this phase.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T063111Z" changeid="xf">
        <seg>也可以在这个阶段对 [[#lua_shared_dict|lua_shared_dict]] 共享存储进行初始化。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can call coroutine.status() and coroutine.yield() on the &quot;light thread&quot; coroutines.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T015906Z" changeid="xf">
        <seg>你可以对&quot;轻量线程&quot;coroutine调用 coroutine.status() 和 coroutine.yield() .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can forcibly update the Nginx time cache by calling [[#ngx.update_time|ngx.update_time]] first.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T022228Z" changeid="xf">
        <seg>可以先用[[#ngx.update_timengx.update_time]]强制刷新Nginx时间缓存.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specify the optional
&lt;code&gt;no_request_line&lt;/code&gt; argument as a &lt;code&gt;true&lt;/code&gt; value to exclude the request line from the result.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T095331Z" changeid="xf">
        <seg>要从结果中去掉请求行，可以将可选的
&lt;code&gt;no_request_line&lt;/code&gt; 参数设为 &lt;code&gt;true&lt;/code&gt; .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You must call [[#ngx.thread.wait|ngx.thread.wait]] to wait for those &quot;light thread&quot; to terminate before quitting the &quot;world&quot;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T014930Z" changeid="xf">
        <seg>要退出整个&quot;世界&quot;， 你必须调用 [[#ngx.thread.wait|ngx.thread.wait]] 来等待这些 &quot;轻量线程&quot; 结束.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the &lt;code&gt;root&lt;/code&gt; account.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T064438Z" changeid="xf">
        <seg>要非常小心避免Lua代码中潜在的安全漏洞，因为Nginx主进程经常用 &lt;code&gt;root&lt;/code&gt; 帐号来运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[http://openresty.org The ngx_openresty bundle] associated with this module comes with a set of companion Nginx modules and Lua libraries that provide interfaces with these data storage mechanisms.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041636Z" changeid="xf">
        <seg>与本模块紧密联系的[http://openresty.org The ngx_openresty 包] 带有一系列 Nginx modules 和 Lua 库可以提供与这些数据存储机制交互的方法.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>a             anchored mode (only match from the beginning)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023526Z" changeid="xf">
        <seg>a             锚模式(仅从头部开始匹配)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>an array-like Lua table.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023759Z" changeid="xf">
        <seg>数组型的 Lua table.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and old &lt;code&gt;Foo&lt;/code&gt; headers will be overridden if there is any.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021146Z" changeid="xf">
        <seg>如果之前设置了 &lt;code&gt;Foo&lt;/code&gt; 头，旧的值将被覆盖.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then accessing it from &lt;code&gt;nginx.conf&lt;/code&gt;:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T041138Z" changeid="xf">
        <seg>然后在 &lt;code&gt;nginx.conf&lt;/code&gt; 中访问它:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>assuming memcached (or something else) is listening on the unix domain socket file &lt;code&gt;/tmp/memcached.sock&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T074635Z" changeid="xf">
        <seg>假设 memcached (或其它的什么东西) 正监听 unix domain socket 文件&lt;code&gt;/tmp/memcached.sock&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>assuming the datagram service is listening on the unix domain socket file &lt;code&gt;/tmp/some-datagram-service.sock&lt;/code&gt; and the client socket will use the &quot;autobind&quot; feature on Linux.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T070018Z" changeid="xf">
        <seg>假设数据报服务监听的是 unix domain socket 文件&lt;code&gt;/tmp/some-datagram-service.sock&lt;/code&gt; 客户端socket会使用Linux的 &quot;自动绑定&quot; 功能.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>at least PCRE 8.12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024228Z" changeid="xf">
        <seg>至少PCRE 8.12版本.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because &lt;code&gt;if&lt;/code&gt; runs ''before'' [[#rewrite_by_lua|rewrite_by_lua]] even if it is placed after [[#rewrite_by_lua|rewrite_by_lua]] in the config.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074742Z" changeid="xf">
        <seg>因为 &lt;code&gt;if&lt;/code&gt; 虽然写在[[#rewrite_by_luarewrite_by_lua]]之后，但还是在  [[#rewrite_by_lua|rewrite_by_lua]] ''之前''执行。</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>because &lt;code&gt;set $a 12&lt;/code&gt; and &lt;code&gt;set $b &quot;&quot;&lt;/code&gt; run ''before'' [[#rewrite_by_lua|rewrite_by_lua]].</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T074615Z" changeid="xf">
        <seg>因为&lt;code&gt;set $a 12&lt;/code&gt; 和 &lt;code&gt;set $b &quot;&quot;&lt;/code&gt; 在[[#rewrite_by_luarewrite_by_lua]] ''之前'' 执行 .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can be coded as</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102216Z" changeid="xf">
        <seg>可以写成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can be coded in Lua as</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101956Z" changeid="xf">
        <seg>可以用Lua写成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can be coded in Lua like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T101939Z" changeid="xf">
        <seg>可以用Lua这样写:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>can be implemented in ngx_lua as:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T051940Z" changeid="xf">
        <seg>可以用 ngx_lua 这样实现:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>d             enable the DFA mode (or the longest token match semantics).</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023605Z" changeid="xf">
        <seg>d             打开 DFA 模式 (最长字元匹配语义).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first introduced in ngx_lua v0.3.1rc30.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023649Z" changeid="xf">
        <seg>在 ngx_lua v0.3.1rc30 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first introduced in ngx_lua v0.8.1.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024516Z" changeid="xf">
        <seg>在 ngx_lua v0.8.1 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>first introduced in the v0.7.14 release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024216Z" changeid="xf">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for example,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023806Z" changeid="xf">
        <seg>例如,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>for optimum performance,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024002Z" changeid="xf">
        <seg>为了最优的性能,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gives</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020210Z" changeid="xf">
        <seg>输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gives something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053151Z" changeid="xf">
        <seg>输出象这样:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>gives the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053452Z" changeid="xf">
        <seg>结果是</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>i             case insensitive mode (similar to Perl's /i modifier)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023904Z" changeid="xf">
        <seg>i             大小写无关模式(类似于Perl的 /i 修饰符)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>in the response headers.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084218Z" changeid="xf">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T042134Z" changeid="xf">
        <seg>等价于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>is equivalent to the following Lua code</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040006Z" changeid="xf">
        <seg>等价于以下Lua代码</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>j             enable PCRE JIT compilation, this requires PCRE 8.21+ which</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023942Z" changeid="xf">
        <seg>j             打开PCRE JIT编译, 需要带有--enable-jit选项编译的 PCRE 8.21+ </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>local regex = &quot;\d+&quot;  -- THIS IS WRONG!!</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T031030Z" changeid="xf">
        <seg>local regex = &quot;\d+&quot;  -- 这是错误的!!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>m             multi-line mode (similar to Perl's /m modifier)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024247Z" changeid="xf">
        <seg>m             多行模式(类似于Perl /m 修饰符)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>modifications of the Nginx variables in the subrequest will affect the current (parent) request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T042105Z" changeid="xf">
        <seg>在子请求中修改nginx变量将影响到当前（父）请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>modifications of the nginx variables in the subrequest will not affect the current (parent) request.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T042009Z" changeid="xf">
        <seg>在子请求中修改nginx变量不会影响当前（父）请求.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>must be built with the --enable-jit option.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023946Z" changeid="xf">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_COPY      (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033219Z" changeid="xf">
        <seg>ngx.HTTP_COPY      ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_LOCK      (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033254Z" changeid="xf">
        <seg>ngx.HTTP_LOCK      ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_MKCOL     (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033209Z" changeid="xf">
        <seg>ngx.HTTP_MKCOL     ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_MOVE      (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033233Z" changeid="xf">
        <seg>ngx.HTTP_MOVE      ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_OPTIONS   (added in the v0.5.0rc24 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033202Z" changeid="xf">
        <seg>ngx.HTTP_OPTIONS   ( v0.5.0rc24 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_PATCH     (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033303Z" changeid="xf">
        <seg>ngx.HTTP_PATCH     ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_PROPFIND  (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033239Z" changeid="xf">
        <seg>ngx.HTTP_PROPFIND  ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_PROPPATCH (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033250Z" changeid="xf">
        <seg>ngx.HTTP_PROPPATCH ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_TRACE     (added in the v0.8.2 release)
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033307Z" changeid="xf">
        <seg>ngx.HTTP_TRACE     ( v0.8.2 版本引入)&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.HTTP_UNLOCK    (added in the v0.8.2 release)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T033259Z" changeid="xf">
        <seg>ngx.HTTP_UNLOCK    ( v0.8.2 版本引入)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.arg[2] = true  -- new eof</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T052216Z" changeid="xf">
        <seg>ngx.arg[2] = true  -- 新的 eof</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.eof()  -- descent HTTP client will close the connection at this point</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T015439Z" changeid="xf">
        <seg>ngx.eof()  -- 良好实现的HTTP客户端将在此时关闭连接</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.req.append_body(chunk) -- each chunk can be 4KB</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030711Z" changeid="xf">
        <seg>ngx.req.append_body(chunk) -- 每一块可以是 4KB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.req.init_body(128 * 1024)  -- buffer is 128KB</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T030656Z" changeid="xf">
        <seg>ngx.req.init_body(128 * 1024)  -- 缓冲区大小128KB</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx.var.diff = a - b;  -- write to $diff directly</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073042Z" changeid="xf">
        <seg>ngx.var.diff = a - b;  -- 直接写入 $diff </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ngx_lua - Embed the power of Lua into Nginx</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T034801Z" changeid="xf">
        <seg>ngx_lua - 在Nging中嵌入强大的Lua</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>o             compile-once mode (similar to Perl's /o modifier),</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024304Z" changeid="xf">
        <seg>o             编译一次模式 (类似于 Perl /o 修饰符),</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102220Z" changeid="xf">
        <seg>或</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or a Lua table holding the query arguments' key-value pairs, as in</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102350Z" changeid="xf">
        <seg>或存有请求参数名－值对的 Lua table, 如</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or equivalently,</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102003Z" changeid="xf">
        <seg>或等价的,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or use Lua's syntactic sugar for method calls:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T034508Z" changeid="xf">
        <seg>或使用Lua方法调用的语法糖:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>outputs something like this:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053201Z" changeid="xf">
        <seg>输出象这样:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>permanent;  # nginx config
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053410Z" changeid="xf">
        <seg>permanent;  # nginx配置
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>rather than the original &lt;code&gt;&quot;hello&quot;&lt;/code&gt; value.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T035540Z" changeid="xf">
        <seg>而不是原始的 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 值.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>redirect;  # nginx config
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053351Z" changeid="xf">
        <seg>redirect;  # nginx配置&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>regardless of the actual request query string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T103101Z" changeid="xf">
        <seg>，与实际的请求query string无关.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>resolver 8.8.8.8;  # use Google's public DNS nameserver
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T065647Z" changeid="xf">
        <seg>resolver 8.8.8.8;  # 使用 Google 的公开 DNS 服务器
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return a + b;          -- return the $sum value normally</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073056Z" changeid="xf">
        <seg>return a + b;          -- 照常返回 $sum 值</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return ngx.redirect('/foo');  -- Lua code
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053404Z" changeid="xf">
        <seg>return ngx.redirect('/foo');  -- Lua代码
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>return ngx.redirect('/foo', ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053416Z" changeid="xf">
        <seg>return ngx.redirect('/foo', ngx.HTTP_MOVED_PERMANENTLY)  -- Lua代码
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>s             single-line mode (similar to Perl's /s modifier)</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024353Z" changeid="xf">
        <seg>s             单行模式 (类似于Perl /s 修饰符)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set $a 12; # create and initialize $a</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015451Z" changeid="xf">
        <seg>set $a 12; # 创建并初始化 $a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set $b &quot;&quot;; # create and initialize $b</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T051858Z" changeid="xf">
        <seg>set $b &quot;&quot;; # 创建并初始化 $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set $b ''; # create and initialize $b</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T015501Z" changeid="xf">
        <seg>set $b ''; # 创建并初始化 $b</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set $diff ''; # we have to predefine the $diff variable here</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130802T073026Z" changeid="xf">
        <seg>set $diff ''; # 必须先定义 $diff 变量</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>set $my_var ''; # this line is required to create $my_var at config time</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032145Z" changeid="xf">
        <seg>set $my_var ''; # 这一行是必需的，在config期间创建 $my_var </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>sock:settimeout(1000)  -- one second timeout</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T053707Z" changeid="xf">
        <seg>sock:settimeout(1000)  -- 1秒超时</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>subpattern names to be repeated, returning the captures in</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024042Z" changeid="xf">
        <seg>子模板的名称重复, 返回的捕捉结果是一个</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that is, this method will escape argument keys and values according to URI rules and
concatenate them together into a complete query string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T053512Z" changeid="xf">
        <seg>也就是说, 这个方法会根据 URI 规范对参数的key和value进行转义并将其拼接成一个完整的 query string.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>that writes out &lt;code&gt;88&lt;/code&gt;, the sum of &lt;code&gt;32&lt;/code&gt; and &lt;code&gt;56&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T024807Z" changeid="xf">
        <seg>输出 &lt;code&gt;88&lt;/code&gt;,  &lt;code&gt;32&lt;/code&gt; 和 &lt;code&gt;56&lt;/code&gt;的和.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the --enable-utf8 option or else a Lua exception will be thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024424Z" changeid="xf">
        <seg> --enable-utf8 选项编译，否则将抛出Lua异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the subject string.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024506Z" changeid="xf">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>the value of &lt;code&gt;ngx.req.get_headers()[&quot;Foo&quot;]&lt;/code&gt; will be a Lua (array) table such as:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T015528Z" changeid="xf">
        <seg>&lt;code&gt;ngx.req.get_headers()[&quot;Foo&quot;]&lt;/code&gt; 的值是这样的 Lua (数组) table:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this option requires</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024224Z" changeid="xf">
        <seg>此选项需要</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this option requires at least PCRE 8.12.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023836Z" changeid="xf">
        <seg>此选项需要至少 PCRE 8.12版本.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this option should always be used together with the 'o' option.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024016Z" changeid="xf">
        <seg>此选项总是应于 'o' 选项一起使用.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this option was</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024215Z" changeid="xf">
        <seg>此选项在v0.7.14版本中引入 </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this option was first introduced in the v0.7.14 release.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023821Z" changeid="xf">
        <seg>此选项在 v0.7.14 版本中引入.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this requires PCRE 6.0+ or else a Lua exception will be thrown.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T023632Z" changeid="xf">
        <seg>此选项需要 PCRE 6.0+ ，没有将抛出Lua 异常.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>this requires PCRE to be built with</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024411Z" changeid="xf">
        <seg>此选项要求 PCRE 带</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to be returned when reading &lt;code&gt;ngx.header.Foo&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091256Z" changeid="xf">
        <seg>.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to enable the worker-process-level compiled-regex cache</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024332Z" changeid="xf">
        <seg>打开 worker进程级别的正则表达式编译缓存</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>to prevent (temporary) memory leaking within the current request's lifetime.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T032806Z" changeid="xf">
        <seg>以避免在当前请求生命周期中出现（临时的）内存泄漏.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>u             UTF-8 mode.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024357Z" changeid="xf">
        <seg>u             UTF-8 模式.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where &lt;code&gt;$0&lt;/code&gt; referring to the whole substring matched by the pattern and &lt;code&gt;$1&lt;/code&gt; referring to the first parenthesized capturing substring.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T032323Z" changeid="xf">
        <seg>其中 &lt;code&gt;$0&lt;/code&gt; 指代匹配的整个子串， &lt;code&gt;$1&lt;/code&gt; 指代收第一个括号捕捉的子串.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>where in the latter case, this method will escape argument keys and values according to the URI escaping rule.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102442Z" changeid="xf">
        <seg>对后一种情况, 本方法会用URI转义规则对key和value进行转义.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is equivalent to</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T034602Z" changeid="xf">
        <seg>等价于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which is functionally equivalent to</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102134Z" changeid="xf">
        <seg>在功能上等价于</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which will result in a query string like &lt;code&gt;a=3&amp;b=5&amp;b=6&lt;/code&gt;.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T102510Z" changeid="xf">
        <seg>生成的query string是 &lt;code&gt;a=3&amp;b=5&amp;b=6&lt;/code&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>while</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T040024Z" changeid="xf">
        <seg>而</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will not work as expected.</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T030821Z" changeid="xf">
        <seg>以上代码无法正常运行.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will produce two new request headers:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T021120Z" changeid="xf">
        <seg>将生成两个请求头:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will result in</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T091252Z" changeid="xf">
        <seg>的结果是在读取&lt;code&gt;ngx.header.Foo&lt;/code&gt;时返回</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will yield</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130806T084214Z" changeid="xf">
        <seg>将会在响应头中生成</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will yield the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130807T041110Z" changeid="xf">
        <seg>将输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will yield the response body like</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013117Z" changeid="xf">
        <seg>输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>will yield:</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130809T013312Z" changeid="xf">
        <seg>将输出:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>x             extended mode (similar to Perl's /x modifier)
&lt;/geshi&gt;</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T024530Z" changeid="xf">
        <seg>x             扩展模式 (类似于Perl /x 修饰符)
&lt;/geshi&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>yields</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T020118Z" changeid="xf">
        <seg>输出</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>yields the output</seg>
      </tuv>
      <tuv lang="ZH-CN" changedate="20130808T021342Z" changeid="xf">
        <seg>输出</seg>
      </tuv>
    </tu>
  </body>
</tmx>
